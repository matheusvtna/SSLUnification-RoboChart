
--
-- RoboChart generator version 3.0.0.202206212138
-- Automatically generated on 08-11-2023 12:25:46
--
-- Iterated compression status: true
-- Assertions compression status: false
--

	module carryBallOnBallPlacement_BehaviorController
		shared_variable_events = {|
		|}
		
	exports
		transparent diamond
		transparent sbisim
		transparent dbisim
		transparent chase

		-- declaring controller events
		channel receiveFrame: InOut.core_string
		channel receiveField: InOut.core_string
		channel receiveTactic: InOut.Tactic
		channel sendAction: InOut.core_string
		channel sendSkill: InOut.carryBallOnBallPlacement_Skill
		
		channel set_nodeStatus: NODE_STATUS
		channel get_nodeStatus: NODE_STATUS
		
		
		-- declaring call and ret events for undefined operations
		
		-- declaring controller termination channel
		channel terminate
		
		-- channel set with all visible events
		sem__events = {|
			terminate
		,	receiveFrame,
			receiveField,
			receiveTactic,
			sendAction,
			sendSkill
		|}
		
		-- set of visible memory events
		visibleMemoryEvents = {|get_nodeStatus,set_nodeStatus|}

		-- defined operations
	
		-- declaring machines
		module stm_behavior_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sWaitTactic|
			              NID_jCheckCurrentTactic|
			              NID_jStopLastTactic|
			              NID_jStartCurrentTactic
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_currentTactic, set_currentTactic, setL_currentTactic, setR_currentTactic: Tactic
			channel get_lastTactic, set_lastTactic, setL_lastTactic, setR_lastTactic: Tactic
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel receiveFrame__: NIDS.InOut.core_string
			channel receiveFrame: InOut.core_string
			channel receiveField__: NIDS.InOut.core_string
			channel receiveField: InOut.core_string
			channel receiveTactic__: NIDS.InOut.Tactic
			channel receiveTactic: InOut.Tactic
			channel sendAction__: NIDS.InOut.core_string
			channel sendAction: InOut.core_string
			channel sendSkill__: NIDS.InOut.carryBallOnBallPlacement_Skill
			channel sendSkill: InOut.carryBallOnBallPlacement_Skill
			channel startCarryBallOnBallPlacement__: NIDS.InOut
			channel startCarryBallOnBallPlacement: InOut
			channel stopCarryBallOnBallPlacement__: NIDS.InOut
			channel stopCarryBallOnBallPlacement: InOut
			channel startHalt__: NIDS.InOut
			channel startHalt: InOut
			channel stopHalt__: NIDS.InOut
			channel stopHalt: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sWaitTactic::enter,
			jCheckCurrentTactic::enter,
			jStopLastTactic::enter,
			jStartCurrentTactic::enter
			|}
			
			enteredSS = 	{|
			sWaitTactic::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	receiveFrame,
				receiveField,
				receiveTactic,
				sendAction,
				sendSkill,
				startCarryBallOnBallPlacement,
				stopCarryBallOnBallPlacement,
				startHalt,
				stopHalt
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sWaitTactic : core_clock_type 
			--channel increment__
			
			CLID_sWaitTactic_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
		
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sWaitTactic
				module sWaitTactic
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: jCheckCurrentTactic
				module jCheckCurrentTactic
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: jStopLastTactic
				module jStopLastTactic
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Junction: jStartCurrentTactic
				module jStartCurrentTactic
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = share__choice(get_currentTactic?currentTactic -> get_lastTactic?lastTactic -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitTactic::enter -> SKIP))))
						 [] dbisim((true)&(receiveTactic__!NID_sWaitTactic.in?currentTactic:{currentTactic|currentTactic <- Tactic, true} -> share__choice(set_currentTactic!currentTactic -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; jCheckCurrentTactic::enter -> SKIP)))
						 [] dbisim(((currentTactic==lastTactic))&(internal__!NID_jCheckCurrentTactic -> SKIP ;  ((SKIP ; sWaitTactic::enter -> SKIP))))
						 [] dbisim(((currentTactic!=lastTactic))&(internal__!NID_jCheckCurrentTactic -> SKIP ;  ((SKIP ; jStopLastTactic::enter -> SKIP))))
						 [] dbisim(((lastTactic==Tactic_PLACE_BALL_IN_POSITION))&(internal__!NID_jStopLastTactic -> SKIP ;  ((true&(share__choice(stopCarryBallOnBallPlacement.out -> SKIP)) ; jStartCurrentTactic::enter -> SKIP))))
						 [] dbisim(((lastTactic==Tactic_HALT))&(internal__!NID_jStopLastTactic -> SKIP ;  ((true&(share__choice(stopHalt.out -> SKIP)) ; jStartCurrentTactic::enter -> SKIP))))
						 [] dbisim(((currentTactic==Tactic_PLACE_BALL_IN_POSITION))&(internal__!NID_jStartCurrentTactic -> SKIP ;  ((true&(share__choice(startCarryBallOnBallPlacement.out -> SKIP)) ; sWaitTactic::enter -> SKIP))))
						 [] dbisim(((currentTactic==Tactic_HALT))&(internal__!NID_jStartCurrentTactic -> SKIP ;  ((true&(share__choice(startHalt.out -> SKIP)) ; sWaitTactic::enter -> SKIP))))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sWaitTactic::enter,
							jCheckCurrentTactic::enter,
							jStopLastTactic::enter,
							jStartCurrentTactic::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,receiveTactic__.NID_sWaitTactic.in,internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic,internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic,internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__)
								   [| { share__, terminate } |] (
								   sWaitTactic::D__(id__)
								   [| { share__, terminate } |] (
								   jCheckCurrentTactic::D__(id__)
								   [| { share__, terminate } |] (
								   jStopLastTactic::D__(id__)
								   [| { share__, terminate } |] (
								   jStartCurrentTactic::D__(id__)
								   )
								   )
								   )
								   )
								 )
								 [[sWaitTactic::interrupt <- x__ | x__ <- {|interrupt,receiveTactic__.NID_sWaitTactic.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 [[jCheckCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic|}]]
								 [[jStopLastTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic|}]]
								 [[jStartCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_currentTactic |} ]] 
								  [[set_currentTactic <- setL_currentTactic,set_lastTactic <- setL_lastTactic]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_currentTactic
								 			,setL_lastTactic
								 			,setR_currentTactic
								 			|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_currentTactic,setL_lastTactic |} ]]
								  [[set_currentTactic <- setR_currentTactic]]
								 )
								)[[setL_currentTactic <- set_currentTactic,setL_lastTactic <- set_lastTactic]]
								 [[setR_currentTactic <- set_currentTactic]]
								)
							)
							 \ hideSet)
							[[
								receiveFrame__.x____ <- receiveFrame,
								receiveField__.x____ <- receiveField,
								receiveTactic__.x____ <- receiveTactic,
								sendAction__.x____ <- sendAction,
								sendSkill__.x____ <- sendSkill,
								startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
								stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
								startHalt__.x____ <- startHalt,
								stopHalt__.x____ <- stopHalt
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitTactic,sWaitTactic::entered|}
					 within
						(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
					)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitTactic,sWaitTactic::entered|}
					 within
						(dbisim(
							sbisim(
								MachineBody(id__)
								[| {|get_CLID_sWaitTactic,sWaitTactic::entered,terminate|} |]
								dbisim(Clock_CLID_sWaitTactic(id__,0))
							)\{|get_CLID_sWaitTactic|}
						)
						) \ union(stateClockSync,enteredSS)
					)
					)
				
				Stateful(id__) = 
					((let
						getsetLocalChannels = {|get_currentTactic,set_currentTactic,
						get_lastTactic,set_lastTactic,
						get_nodeStatus,set_nodeStatus|}
						clockSync = {||}
					within
						(Behaviour(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											IteratedBehaviour(id__)
											[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
											Memory_nodeStatus(NODE_STATUS_RUNNING)
										)\{|get_nodeStatus,set_nodeStatus|}
									)
									[| {|get_lastTactic,set_lastTactic,terminate|} |]
									Memory_lastTactic(Tactic_HALT)
								)\{|get_lastTactic,set_lastTactic|}
							)
							[| {|get_currentTactic,set_currentTactic,terminate|} |]
							Memory_currentTactic(Tactic_HALT)
						)\{|get_currentTactic,set_currentTactic|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {||}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sWaitTactic::enter,
							jCheckCurrentTactic::enter,
							jStopLastTactic::enter,
							jStartCurrentTactic::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,receiveTactic__.NID_sWaitTactic.in,internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic,internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic,internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sWaitTactic::VS_O__(id__)
								   [| { share__, terminate } |] (
								   jCheckCurrentTactic::VS_O__(id__)
								   [| { share__, terminate } |] (
								   jStopLastTactic::VS_O__(id__)
								   [| { share__, terminate } |] (
								   jStartCurrentTactic::VS_O__(id__)
								   )
								   )
								   )
								   )
								 )
								 [[sWaitTactic::interrupt <- x__ | x__ <- {|interrupt,receiveTactic__.NID_sWaitTactic.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 [[jCheckCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic|}]]
								 [[jStopLastTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic|}]]
								 [[jStartCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__,setR_currentTactic |} ]] 
								  [[set_currentTactic <- setL_currentTactic,set_lastTactic <- setL_lastTactic]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_currentTactic
								 			,setL_lastTactic
								 			,setR_currentTactic
								 			|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_currentTactic,setL_lastTactic |} ]]
								  [[set_currentTactic <- setR_currentTactic]]
								 )
								)[[setL_currentTactic <- set_currentTactic,setL_lastTactic <- set_lastTactic]]
								 [[setR_currentTactic <- set_currentTactic]]
								)
							)
							 \ hideSet)
							[[
								receiveFrame__.x____ <- receiveFrame,
								receiveField__.x____ <- receiveField,
								receiveTactic__.x____ <- receiveTactic,
								sendAction__.x____ <- sendAction,
								sendSkill__.x____ <- sendSkill,
								startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
								stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
								startHalt__.x____ <- startHalt,
								stopHalt__.x____ <- stopHalt
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitTactic,sWaitTactic::entered|}
					 within
						(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitTactic,sWaitTactic::entered|}
					 within
						(dbisim(
							sbisim(
								MachineBody_VS_O(id__)
								[| {|get_CLID_sWaitTactic,sWaitTactic::entered,terminate|} |]
								dbisim(Clock_CLID_sWaitTactic(id__,0))
							)\{|get_CLID_sWaitTactic|}
						)
						) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				Stateful_VS_O(id__) = 
					dbisim((let
						getsetLocalChannels = {|get_currentTactic,set_currentTactic,
						get_lastTactic,set_lastTactic,
						get_nodeStatus,set_nodeStatus|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											IteratedBehaviour_VS_O(id__)
											[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
											Memory_nodeStatus(NODE_STATUS_RUNNING)
										)\{|get_nodeStatus,set_nodeStatus|}
									)
									[| {|get_lastTactic,set_lastTactic,terminate|} |]
									Memory_lastTactic(Tactic_HALT)
								)\{|get_lastTactic,set_lastTactic|}
							)
							[| {|get_currentTactic,set_currentTactic,terminate|} |]
							Memory_currentTactic(Tactic_HALT)
						)\{|get_currentTactic,set_currentTactic|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_currentTactic(currentTactic) =
					get_currentTactic!currentTactic -> Memory_currentTactic(currentTactic)
					[]
					set_currentTactic?x__ -> Memory_currentTactic(x__)
					[]
					terminate -> SKIP
				Memory_lastTactic(lastTactic) =
					get_lastTactic!lastTactic -> Memory_lastTactic(lastTactic)
					[]
					set_lastTactic?x__ -> Memory_lastTactic(x__)
					[]
					terminate -> SKIP
				Memory_nodeStatus(nodeStatus) =
					get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
					[]
					set_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_currentTactic(Tactic_HALT)
				[| { terminate } |] (
				Memory_lastTactic(Tactic_HALT)
				[| { terminate } |] (
				Memory_nodeStatus(NODE_STATUS_RUNNING)
				)
				)
				
				getsetLocalChannels = {|get_currentTactic,set_currentTactic,get_lastTactic,set_lastTactic,get_nodeStatus,set_nodeStatus|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__) \ localClockResets
				D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
				O__(id__) = dbisim(D__(id__))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = dbisim(FVS__(id__))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
				HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sWaitTactic(id__,x__) = 
					TimeOut_1(
						sWaitTactic::entered -> Clock_CLID_sWaitTactic(id__,0)
						[]
						get_CLID_sWaitTactic!x__ -> Clock_CLID_sWaitTactic(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sWaitTactic(id__,clock_type_plus(x__,1,CLID_sWaitTactic_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sWaitTactic(id__,0))
				
				stateClockSync = {|get_CLID_sWaitTactic,sWaitTactic::entered|}
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
				}
		endmodule
		module stm_carry_ball_on_ball_placement_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_robotHasMovedAwayFromBall, set_robotHasMovedAwayFromBall, setL_robotHasMovedAwayFromBall, setR_robotHasMovedAwayFromBall: core_boolean
			channel get_runningStm, set_runningStm, setL_runningStm, setR_runningStm: core_string
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startCarryBallOnBallPlacement__: NIDS.InOut
			channel startCarryBallOnBallPlacement: InOut
			channel stopCarryBallOnBallPlacement__: NIDS.InOut
			channel stopCarryBallOnBallPlacement: InOut
			channel startGoToBehindBall__: NIDS.InOut
			channel startGoToBehindBall: InOut
			channel stopGoToBehindBall__: NIDS.InOut
			channel stopGoToBehindBall: InOut
			channel startApproachBall__: NIDS.InOut
			channel startApproachBall: InOut
			channel stopApproachBall__: NIDS.InOut
			channel stopApproachBall: InOut
			channel startCarryBall__: NIDS.InOut
			channel startCarryBall: InOut
			channel stopCarryBall__: NIDS.InOut
			channel stopCarryBall: InOut
			channel startMoveAwayFromPosition__: NIDS.InOut
			channel startMoveAwayFromPosition: InOut
			channel stopMoveAwayFromPosition__: NIDS.InOut
			channel stopMoveAwayFromPosition: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startCarryBallOnBallPlacement,
				stopCarryBallOnBallPlacement,
				startGoToBehindBall,
				stopGoToBehindBall,
				startApproachBall,
				stopApproachBall,
				startCarryBall,
				stopCarryBall,
				startMoveAwayFromPosition,
				stopMoveAwayFromPosition
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sRun : core_clock_type 
			channel get_CLID_sWaitStart : core_clock_type 
			channel get_CLID_sFinal : core_clock_type 
			--channel increment__
			
			CLID_sRun_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sWaitStart_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sFinal_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
		
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sWaitStart
				module sWaitStart
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sRun
				module sRun
				
				enterSS = 
						{|			sInitial::enter,
							sGoToBehindBall::enter,
							sGiveSpaceToGetBall::enter,
							sApproachBall::enter,
							sPlaceBall::enter,
							sMoveAwayFromBall::enter,
							sFinal::enter
						|}
				enteredSS = 
						{|			sGoToBehindBall::entered,
							sGiveSpaceToGetBall::entered,
							sApproachBall::entered,
							sPlaceBall::entered,
							sMoveAwayFromBall::entered,
							sFinal::entered
						|}
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					-- declaring identifiers of transitions
					datatype NIDS = 
					              NID_sInitial|
					              NID_sGoToBehindBall|
					              NID_sGiveSpaceToGetBall|
					              NID_sApproachBall|
					              NID_sPlaceBall|
					              NID_sMoveAwayFromBall|
					              NID_sFinal
					
					channel internal__ : NIDS
					channel startCarryBallOnBallPlacement__: NIDS.InOut
					channel stopCarryBallOnBallPlacement__: NIDS.InOut
					channel startGoToBehindBall__: NIDS.InOut
					channel stopGoToBehindBall__: NIDS.InOut
					channel startApproachBall__: NIDS.InOut
					channel stopApproachBall__: NIDS.InOut
					channel startCarryBall__: NIDS.InOut
					channel stopCarryBall__: NIDS.InOut
					channel startMoveAwayFromPosition__: NIDS.InOut
					channel stopMoveAwayFromPosition__: NIDS.InOut
					
					channel get_CLID_sApproachBall : core_clock_type 
					channel get_CLID_sGiveSpaceToGetBall : core_clock_type 
					channel get_CLID_sPlaceBall : core_clock_type 
					channel get_CLID_sGoToBehindBall : core_clock_type 
					channel get_CLID_sMoveAwayFromBall : core_clock_type 
					--channel increment__
					
					CLID_sApproachBall_clock_type(id__) = 
						let
							max = (clock_type_max(Union({
					{}
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					CLID_sGiveSpaceToGetBall_clock_type(id__) = 
						let
							max = (clock_type_max(Union({
					{}
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					CLID_sPlaceBall_clock_type(id__) = 
						let
							max = (clock_type_max(Union({
					{}
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					CLID_sGoToBehindBall_clock_type(id__) = 
						let
							max = (clock_type_max(Union({
					{}
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					CLID_sMoveAwayFromBall_clock_type(id__) = 
						let
							max = (clock_type_max(Union({
					{}
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: sInitial
					module sInitial
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sGoToBehindBall
					module sGoToBehindBall
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sGiveSpaceToGetBall
					module sGiveSpaceToGetBall
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sApproachBall
					module sApproachBall
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sPlaceBall
					module sPlaceBall
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sMoveAwayFromBall
					module sMoveAwayFromBall
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: sFinal
					module sFinal
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		dbisim(
								 			sbisim(
								 				dbisim(
								 					sbisim(
								 						dbisim(
								 							sbisim(
								 								dbisim(
								 									sbisim(
								 										(let
								 											-- IMPLEMENTATION NOTE:
								 											-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 											-- modules for defining the semantics of each node.
								 											enterSS = {|
								 											sInitial::enter,
								 											sGoToBehindBall::enter,
								 											sGiveSpaceToGetBall::enter,
								 											sApproachBall::enter,
								 											sPlaceBall::enter,
								 											sMoveAwayFromBall::enter,
								 											sFinal::enter
								 											|}
								 											hideSet = union(enterSS,{|exit,exited,internal__|})
								 										within 
								 											((let
								 												-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 												-- because CSPM modules are used for the semantics of Node.
								 												flowevts = union(enterSS,{|exit,exited,interrupt|})
								 												transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
								 											within
								 												((
								 												 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 												   sInitial::D__(id__)
								 												   [| { share__, terminate } |] (
								 												   sGoToBehindBall::D__(id__)
								 												   [| { share__, terminate } |] (
								 												   sGiveSpaceToGetBall::D__(id__)
								 												   [| { share__, terminate } |] (
								 												   sApproachBall::D__(id__)
								 												   [| { share__, terminate } |] (
								 												   sPlaceBall::D__(id__)
								 												   [| { share__, terminate } |] (
								 												   sMoveAwayFromBall::D__(id__)
								 												   [| { share__, terminate } |] (
								 												   sFinal::D__(id__)
								 												   )
								 												   )
								 												   )
								 												   )
								 												   )
								 												   )
								 												 )
								 												 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
								 												 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
								 												 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
								 												 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
								 												 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
								 												 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 												 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 												 )
								 												  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 												  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
								 												 )
								 												 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 												 			,setL_nodeStatus
								 												 			,setL_robotHasMovedAwayFromBall
								 												|}) |]
								 												 ((sInitial::enter -> Transitions(id__))
								 												  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
								 												 )
								 												)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
								 												)
								 											)
								 											 \ hideSet)
								 											[[
								 												startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
								 												stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
								 												startGoToBehindBall__.x____ <- startGoToBehindBall,
								 												stopGoToBehindBall__.x____ <- stopGoToBehindBall,
								 												startApproachBall__.x____ <- startApproachBall,
								 												stopApproachBall__.x____ <- stopApproachBall,
								 												startCarryBall__.x____ <- startCarryBall,
								 												stopCarryBall__.x____ <- stopCarryBall,
								 												startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
								 												stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
								 												| x____ <- NIDS
								 											]]
								 										)
								 										[| {|get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered,terminate|} |]
								 										dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
								 									)\{|get_CLID_sMoveAwayFromBall|}
								 								)
								 								[| {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered,terminate|} |]
								 								dbisim(Clock_CLID_sGoToBehindBall(id__,0))
								 							)\{|get_CLID_sGoToBehindBall|}
								 						)
								 						[| {|get_CLID_sPlaceBall,sPlaceBall::entered,terminate|} |]
								 						dbisim(Clock_CLID_sPlaceBall(id__,0))
								 					)\{|get_CLID_sPlaceBall|}
								 				)
								 				[| {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,terminate|} |]
								 				dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
								 			)\{|get_CLID_sGiveSpaceToGetBall|}
								 		)
								 		[| {|get_CLID_sApproachBall,sApproachBall::entered,terminate|} |]
								 		dbisim(Clock_CLID_sApproachBall(id__,0))
								 	)\{|get_CLID_sApproachBall|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotHasMovedAwayFromBall,setR_runningStm |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_runningStm <- setL_runningStm]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_nodeStatus
								 			,setL_robotHasMovedAwayFromBall
								 			,setL_runningStm
								 			,setR_nodeStatus
								 			 			,setR_robotHasMovedAwayFromBall
								 			 			,setR_runningStm
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall,setL_runningStm |} ]]
								  [[set_nodeStatus <- setR_nodeStatus,set_robotHasMovedAwayFromBall <- setR_robotHasMovedAwayFromBall,set_runningStm <- setR_runningStm]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_runningStm <- set_runningStm]]
								 [[setR_nodeStatus <- set_nodeStatus,setR_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setR_runningStm <- set_runningStm]]
								)\union(enteredSS,{terminate}) 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		dbisim(
								 			sbisim(
								 				dbisim(
								 					sbisim(
								 						dbisim(
								 							sbisim(
								 								dbisim(
								 									sbisim(
								 										(let
								 											-- IMPLEMENTATION NOTE:
								 											-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 											-- modules for defining the semantics of each node.
								 											enterSS = {|
								 											sInitial::enter,
								 											sGoToBehindBall::enter,
								 											sGiveSpaceToGetBall::enter,
								 											sApproachBall::enter,
								 											sPlaceBall::enter,
								 											sMoveAwayFromBall::enter,
								 											sFinal::enter
								 											|}
								 											hideSet = union(enterSS,{|exit,exited,internal__|})
								 										within 
								 											((let
								 												-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 												-- because CSPM modules are used for the semantics of Node.
								 												flowevts = union(enterSS,{|exit,exited,interrupt|})
								 												transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
								 											within
								 												((
								 												 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 												   sInitial::VS_O__(id__)
								 												   [| { share__, terminate } |] (
								 												   sGoToBehindBall::VS_O__(id__)
								 												   [| { share__, terminate } |] (
								 												   sGiveSpaceToGetBall::VS_O__(id__)
								 												   [| { share__, terminate } |] (
								 												   sApproachBall::VS_O__(id__)
								 												   [| { share__, terminate } |] (
								 												   sPlaceBall::VS_O__(id__)
								 												   [| { share__, terminate } |] (
								 												   sMoveAwayFromBall::VS_O__(id__)
								 												   [| { share__, terminate } |] (
								 												   sFinal::VS_O__(id__)
								 												   )
								 												   )
								 												   )
								 												   )
								 												   )
								 												   )
								 												 )
								 												 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
								 												 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
								 												 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
								 												 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
								 												 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
								 												 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 												 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 												 )
								 												  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 												  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
								 												 )
								 												 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 												 			,setL_nodeStatus
								 												 			,setL_robotHasMovedAwayFromBall
								 												|}) |]
								 												 ((sInitial::enter -> Transitions(id__))
								 												  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
								 												 )
								 												)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
								 												)
								 											)
								 											 \ hideSet)
								 											[[
								 												startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
								 												stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
								 												startGoToBehindBall__.x____ <- startGoToBehindBall,
								 												stopGoToBehindBall__.x____ <- stopGoToBehindBall,
								 												startApproachBall__.x____ <- startApproachBall,
								 												stopApproachBall__.x____ <- stopApproachBall,
								 												startCarryBall__.x____ <- startCarryBall,
								 												stopCarryBall__.x____ <- stopCarryBall,
								 												startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
								 												stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
								 												| x____ <- NIDS
								 											]]
								 										)
								 										[| {|get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered,terminate|} |]
								 										dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
								 									)\{|get_CLID_sMoveAwayFromBall|}
								 								)
								 								[| {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered,terminate|} |]
								 								dbisim(Clock_CLID_sGoToBehindBall(id__,0))
								 							)\{|get_CLID_sGoToBehindBall|}
								 						)
								 						[| {|get_CLID_sPlaceBall,sPlaceBall::entered,terminate|} |]
								 						dbisim(Clock_CLID_sPlaceBall(id__,0))
								 					)\{|get_CLID_sPlaceBall|}
								 				)
								 				[| {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,terminate|} |]
								 				dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
								 			)\{|get_CLID_sGiveSpaceToGetBall|}
								 		)
								 		[| {|get_CLID_sApproachBall,sApproachBall::entered,terminate|} |]
								 		dbisim(Clock_CLID_sApproachBall(id__,0))
								 	)\{|get_CLID_sApproachBall|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotHasMovedAwayFromBall,setR_runningStm |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_runningStm <- setL_runningStm]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_nodeStatus
								 			,setL_robotHasMovedAwayFromBall
								 			,setL_runningStm
								 			,setR_nodeStatus
								 			 			,setR_robotHasMovedAwayFromBall
								 			 			,setR_runningStm
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall,setL_runningStm |} ]]
								  [[set_nodeStatus <- setR_nodeStatus,set_robotHasMovedAwayFromBall <- setR_robotHasMovedAwayFromBall,set_runningStm <- setR_runningStm]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_runningStm <- set_runningStm]]
								 [[setR_nodeStatus <- set_nodeStatus,setR_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setR_runningStm <- set_runningStm]]
								)\{terminate} 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
						
						Transitions(id__) = ((let
							Trans = share__choice(get_nodeStatus?nodeStatus -> get_robotHasMovedAwayFromBall?robotHasMovedAwayFromBall -> TimeOut_1(
								 (share__ -> SKIP
								 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP))))
								 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(startApproachBall.out -> SKIP)) ; sApproachBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(startCarryBall.out -> SKIP)) ; sPlaceBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(startMoveAwayFromPosition.out -> SKIP)) ; sMoveAwayFromBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(startMoveAwayFromPosition.out -> SKIP)) ; sGiveSpaceToGetBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP)) ; sFinal::enter -> SKIP)))
								 [] dbisim((robotHasMovedAwayFromBall)&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sApproachBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sPlaceBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sMoveAwayFromBall::enter -> SKIP)))
								 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGiveSpaceToGetBall::enter -> SKIP)))
								 []
								 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
								 []
								 terminate -> SKIP
								 )
							,SKIP);Trans
							)
						within
							Trans [|{terminate}|> SKIP
						)
						)
						
						
						-- Clocks
						Clock_CLID_sApproachBall(id__,x__) = 
							TimeOut_1(
								sApproachBall::entered -> Clock_CLID_sApproachBall(id__,0)
								[]
								get_CLID_sApproachBall!x__ -> Clock_CLID_sApproachBall(id__,x__)
								[]
								terminate -> SKIP,Clock_CLID_sApproachBall(id__,clock_type_plus(x__,1,CLID_sApproachBall_clock_type(id__))))
						Clock_CLID_sGiveSpaceToGetBall(id__,x__) = 
							TimeOut_1(
								sGiveSpaceToGetBall::entered -> Clock_CLID_sGiveSpaceToGetBall(id__,0)
								[]
								get_CLID_sGiveSpaceToGetBall!x__ -> Clock_CLID_sGiveSpaceToGetBall(id__,x__)
								[]
								terminate -> SKIP,Clock_CLID_sGiveSpaceToGetBall(id__,clock_type_plus(x__,1,CLID_sGiveSpaceToGetBall_clock_type(id__))))
						Clock_CLID_sPlaceBall(id__,x__) = 
							TimeOut_1(
								sPlaceBall::entered -> Clock_CLID_sPlaceBall(id__,0)
								[]
								get_CLID_sPlaceBall!x__ -> Clock_CLID_sPlaceBall(id__,x__)
								[]
								terminate -> SKIP,Clock_CLID_sPlaceBall(id__,clock_type_plus(x__,1,CLID_sPlaceBall_clock_type(id__))))
						Clock_CLID_sGoToBehindBall(id__,x__) = 
							TimeOut_1(
								sGoToBehindBall::entered -> Clock_CLID_sGoToBehindBall(id__,0)
								[]
								get_CLID_sGoToBehindBall!x__ -> Clock_CLID_sGoToBehindBall(id__,x__)
								[]
								terminate -> SKIP,Clock_CLID_sGoToBehindBall(id__,clock_type_plus(x__,1,CLID_sGoToBehindBall_clock_type(id__))))
						Clock_CLID_sMoveAwayFromBall(id__,x__) = 
							TimeOut_1(
								sMoveAwayFromBall::entered -> Clock_CLID_sMoveAwayFromBall(id__,0)
								[]
								get_CLID_sMoveAwayFromBall!x__ -> Clock_CLID_sMoveAwayFromBall(id__,x__)
								[]
								terminate -> SKIP,Clock_CLID_sMoveAwayFromBall(id__,clock_type_plus(x__,1,CLID_sMoveAwayFromBall_clock_type(id__))))
						
						StateClocks(id__) = dbisim(Clock_CLID_sApproachBall(id__,0))
						[| { terminate } |] (
						dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
						[| { terminate } |] (
						dbisim(Clock_CLID_sPlaceBall(id__,0))
						[| { terminate } |] (
						dbisim(Clock_CLID_sGoToBehindBall(id__,0))
						[| { terminate } |] (
						dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
						)
						)
						)
						)
						
						stateClockSync = {|get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
						 [] dbisim((true)&(startCarryBallOnBallPlacement__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
						 [] dbisim((true)&(stopCarryBallOnBallPlacement__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP)));true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startCarryBallOnBallPlacement__.NID_sWaitStart.in,stopCarryBallOnBallPlacement__.NID_sRun.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__)
								   [| { share__, terminate } |] (
								   sWaitStart::D__(id__)
								   [| { share__, terminate } |] (
								   sRun::D__(id__)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBallOnBallPlacement__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,stopCarryBallOnBallPlacement__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
							[[
								startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
								stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
								startGoToBehindBall__.x____ <- startGoToBehindBall,
								stopGoToBehindBall__.x____ <- stopGoToBehindBall,
								startApproachBall__.x____ <- startApproachBall,
								stopApproachBall__.x____ <- stopApproachBall,
								startCarryBall__.x____ <- startCarryBall,
								stopCarryBall__.x____ <- stopCarryBall,
								startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
								stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
					)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody(id__)
										[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
										dbisim(Clock_CLID_sWaitStart(id__,0))
									)\{|get_CLID_sWaitStart|}
								)
								[| {|get_CLID_sRun,sRun::entered,terminate|} |]
								dbisim(Clock_CLID_sRun(id__,0))
							)\{|get_CLID_sRun|}
						)
						) \ union(stateClockSync,enteredSS)
					)
					)
				
				Stateful(id__) = 
					((let
						getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,
						get_runningStm,set_runningStm|}
						clockSync = {||}
					within
						(Behaviour(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									IteratedBehaviour(id__)
									[| {|get_runningStm,set_runningStm,terminate|} |]
									Memory_runningStm("")
								)\{|get_runningStm,set_runningStm|}
							)
							[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
							Memory_robotHasMovedAwayFromBall(true)
						)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startCarryBallOnBallPlacement__.NID_sWaitStart.in,stopCarryBallOnBallPlacement__.NID_sRun.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sWaitStart::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sRun::VS_O__(id__)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBallOnBallPlacement__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,stopCarryBallOnBallPlacement__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
							[[
								startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
								stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
								startGoToBehindBall__.x____ <- startGoToBehindBall,
								stopGoToBehindBall__.x____ <- stopGoToBehindBall,
								startApproachBall__.x____ <- startApproachBall,
								stopApproachBall__.x____ <- stopApproachBall,
								startCarryBall__.x____ <- startCarryBall,
								stopCarryBall__.x____ <- stopCarryBall,
								startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
								stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody_VS_O(id__)
										[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
										dbisim(Clock_CLID_sWaitStart(id__,0))
									)\{|get_CLID_sWaitStart|}
								)
								[| {|get_CLID_sRun,sRun::entered,terminate|} |]
								dbisim(Clock_CLID_sRun(id__,0))
							)\{|get_CLID_sRun|}
						)
						) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				Stateful_VS_O(id__) = 
					dbisim((let
						getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,
						get_runningStm,set_runningStm|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									IteratedBehaviour_VS_O(id__)
									[| {|get_runningStm,set_runningStm,terminate|} |]
									Memory_runningStm("")
								)\{|get_runningStm,set_runningStm|}
							)
							[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
							Memory_robotHasMovedAwayFromBall(true)
						)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall) =
					get_robotHasMovedAwayFromBall!robotHasMovedAwayFromBall -> Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall)
					[]
					set_robotHasMovedAwayFromBall?x__ -> Memory_robotHasMovedAwayFromBall(x__)
					[]
					terminate -> SKIP
				Memory_runningStm(runningStm) =
					get_runningStm!runningStm -> Memory_runningStm(runningStm)
					[]
					set_runningStm?x__ -> Memory_runningStm(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_robotHasMovedAwayFromBall(true)
				[| { terminate } |] (
				Memory_runningStm("")
				)
				
				getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,get_runningStm,set_runningStm|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__) \ localClockResets
				D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
				O__(id__) = dbisim(D__(id__))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = dbisim(FVS__(id__))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
				HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sRun(id__,x__) = 
					TimeOut_1(
						sRun::entered -> Clock_CLID_sRun(id__,0)
						[]
						get_CLID_sRun!x__ -> Clock_CLID_sRun(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sRun(id__,clock_type_plus(x__,1,CLID_sRun_clock_type(id__))))
				Clock_CLID_sWaitStart(id__,x__) = 
					TimeOut_1(
						sWaitStart::entered -> Clock_CLID_sWaitStart(id__,0)
						[]
						get_CLID_sWaitStart!x__ -> Clock_CLID_sWaitStart(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sWaitStart(id__,clock_type_plus(x__,1,CLID_sWaitStart_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sRun(id__,0))
				[| { terminate } |] (
				dbisim(Clock_CLID_sWaitStart(id__,0))
				)
				
				stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
				
				-- Shared memory
				-- Shared memory variables
				Memory_nodeStatus(nodeStatus) =
					get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
					[]
					set_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					terminate -> SKIP
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
				
				sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
				
				sharedVarHide = {|get_nodeStatus|}
				}
		endmodule
		module stm_go_to_behind_ball_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyIsBehindBall, set_allyIsBehindBall, setL_allyIsBehindBall, setR_allyIsBehindBall: core_boolean
			channel get_allyIsCloseToBall, set_allyIsCloseToBall, setL_allyIsCloseToBall, setR_allyIsCloseToBall: core_boolean
			channel get_allyIsPushingBallWithHisBack, set_allyIsPushingBallWithHisBack, setL_allyIsPushingBallWithHisBack, setR_allyIsPushingBallWithHisBack: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startGoToBehindBall__: NIDS.InOut
			channel startGoToBehindBall: InOut
			channel stopGoToBehindBall__: NIDS.InOut
			channel stopGoToBehindBall: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startGoToBehindBall,
				stopGoToBehindBall
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sFinal : core_clock_type 
			channel get_CLID_sWaitStart : core_clock_type 
			channel get_CLID_sRun : core_clock_type 
			--channel increment__
			
			CLID_sFinal_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sWaitStart_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sRun_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
		
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sWaitStart
				module sWaitStart
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sRun
				module sRun
				
				enterSS = 
						{|			sInitial::enter,
							sFinal::enter,
							sGoToBehindBall::enter
						|}
				enteredSS = 
						{|			sFinal::entered,
							sGoToBehindBall::entered
						|}
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					-- declaring identifiers of transitions
					datatype NIDS = 
					              NID_sInitial|
					              NID_sFinal|
					              NID_sGoToBehindBall
					
					channel internal__ : NIDS
					channel startGoToBehindBall__: NIDS.InOut
					channel stopGoToBehindBall__: NIDS.InOut
					
					channel get_CLID_sGoToBehindBall : core_clock_type 
					--channel increment__
					
					CLID_sGoToBehindBall_clock_type(id__) = 
						let
							max = (clock_type_max(Union({
					{}
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: sInitial
					module sInitial
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: sFinal
					module sFinal
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sGoToBehindBall
					module sGoToBehindBall
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		(let
								 			-- IMPLEMENTATION NOTE:
								 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 			-- modules for defining the semantics of each node.
								 			enterSS = {|
								 			sInitial::enter,
								 			sFinal::enter,
								 			sGoToBehindBall::enter
								 			|}
								 			hideSet = union(enterSS,{|exit,exited,internal__|})
								 		within 
								 			((let
								 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 				-- because CSPM modules are used for the semantics of Node.
								 				flowevts = union(enterSS,{|exit,exited,interrupt|})
								 				transSync = {|internal__.NID_sInitial,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}
								 			within
								 				((
								 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 				   sInitial::D__(id__)
								 				   [| { share__, terminate } |] (
								 				   sFinal::D__(id__)
								 				   [| { share__, terminate } |] (
								 				   sGoToBehindBall::D__(id__)
								 				   )
								 				   )
								 				 )
								 				 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 				 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
								 				 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 				 )
								 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 				  [[set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack]]
								 				 )
								 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 				 			,setL_allyIsBehindBall
								 				 			,setL_allyIsCloseToBall
								 				 			,setL_allyIsPushingBallWithHisBack
								 				|}) |]
								 				 ((sInitial::enter -> Transitions(id__))
								 				  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsBehindBall,setL_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack |} ]]
								 				 )
								 				)[[setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
								 				)
								 			)
								 			 \ hideSet)
								 			[[
								 				startGoToBehindBall__.x____ <- startGoToBehindBall,
								 				stopGoToBehindBall__.x____ <- stopGoToBehindBall
								 				| x____ <- NIDS
								 			]]
								 		)
								 		[| {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered,terminate|} |]
								 		dbisim(Clock_CLID_sGoToBehindBall(id__,0))
								 	)\{|get_CLID_sGoToBehindBall|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_allyIsBehindBall,setR_allyIsCloseToBall,setR_allyIsPushingBallWithHisBack |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus,set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_nodeStatus
								 			,setL_allyIsBehindBall
								 			,setL_allyIsCloseToBall
								 			,setL_allyIsPushingBallWithHisBack
								 			,setR_nodeStatus
								 			 			,setR_allyIsBehindBall
								 			 			,setR_allyIsCloseToBall
								 			 			,setR_allyIsPushingBallWithHisBack
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_allyIsBehindBall,setL_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack |} ]]
								  [[set_nodeStatus <- setR_nodeStatus,set_allyIsBehindBall <- setR_allyIsBehindBall,set_allyIsCloseToBall <- setR_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setR_allyIsPushingBallWithHisBack]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus,setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
								 [[setR_nodeStatus <- set_nodeStatus,setR_allyIsBehindBall <- set_allyIsBehindBall,setR_allyIsCloseToBall <- set_allyIsCloseToBall,setR_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
								)\union(enteredSS,{terminate}) 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		(let
								 			-- IMPLEMENTATION NOTE:
								 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 			-- modules for defining the semantics of each node.
								 			enterSS = {|
								 			sInitial::enter,
								 			sFinal::enter,
								 			sGoToBehindBall::enter
								 			|}
								 			hideSet = union(enterSS,{|exit,exited,internal__|})
								 		within 
								 			((let
								 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 				-- because CSPM modules are used for the semantics of Node.
								 				flowevts = union(enterSS,{|exit,exited,interrupt|})
								 				transSync = {|internal__.NID_sInitial,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}
								 			within
								 				((
								 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 				   sInitial::VS_O__(id__)
								 				   [| { share__, terminate } |] (
								 				   sFinal::VS_O__(id__)
								 				   [| { share__, terminate } |] (
								 				   sGoToBehindBall::VS_O__(id__)
								 				   )
								 				   )
								 				 )
								 				 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 				 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
								 				 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 				 )
								 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 				  [[set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack]]
								 				 )
								 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 				 			,setL_allyIsBehindBall
								 				 			,setL_allyIsCloseToBall
								 				 			,setL_allyIsPushingBallWithHisBack
								 				|}) |]
								 				 ((sInitial::enter -> Transitions(id__))
								 				  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsBehindBall,setL_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack |} ]]
								 				 )
								 				)[[setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
								 				)
								 			)
								 			 \ hideSet)
								 			[[
								 				startGoToBehindBall__.x____ <- startGoToBehindBall,
								 				stopGoToBehindBall__.x____ <- stopGoToBehindBall
								 				| x____ <- NIDS
								 			]]
								 		)
								 		[| {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered,terminate|} |]
								 		dbisim(Clock_CLID_sGoToBehindBall(id__,0))
								 	)\{|get_CLID_sGoToBehindBall|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_allyIsBehindBall,setR_allyIsCloseToBall,setR_allyIsPushingBallWithHisBack |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus,set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_nodeStatus
								 			,setL_allyIsBehindBall
								 			,setL_allyIsCloseToBall
								 			,setL_allyIsPushingBallWithHisBack
								 			,setR_nodeStatus
								 			 			,setR_allyIsBehindBall
								 			 			,setR_allyIsCloseToBall
								 			 			,setR_allyIsPushingBallWithHisBack
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_allyIsBehindBall,setL_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack |} ]]
								  [[set_nodeStatus <- setR_nodeStatus,set_allyIsBehindBall <- setR_allyIsBehindBall,set_allyIsCloseToBall <- setR_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setR_allyIsPushingBallWithHisBack]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus,setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
								 [[setR_nodeStatus <- set_nodeStatus,setR_allyIsBehindBall <- set_allyIsBehindBall,setR_allyIsCloseToBall <- set_allyIsCloseToBall,setR_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
								)\{terminate} 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
						
						Transitions(id__) = ((let
							Trans = share__choice(get_allyIsBehindBall?allyIsBehindBall -> get_allyIsCloseToBall?allyIsCloseToBall -> get_allyIsPushingBallWithHisBack?allyIsPushingBallWithHisBack -> TimeOut_1(
								 (share__ -> SKIP
								 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sGoToBehindBall::enter -> SKIP))))
								 [] dbisim((((allyIsBehindBall and allyIsCloseToBall)))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
								 [] dbisim((((not (((allyIsBehindBall and allyIsCloseToBall)))) and (not (allyIsPushingBallWithHisBack))))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sGoToBehindBall::enter -> SKIP)))
								 [] dbisim((allyIsPushingBallWithHisBack)&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
								 []
								 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
								 []
								 terminate -> SKIP
								 )
							,SKIP);Trans
							)
						within
							Trans [|{terminate}|> SKIP
						)
						)
						
						
						-- Clocks
						Clock_CLID_sGoToBehindBall(id__,x__) = 
							TimeOut_1(
								sGoToBehindBall::entered -> Clock_CLID_sGoToBehindBall(id__,0)
								[]
								get_CLID_sGoToBehindBall!x__ -> Clock_CLID_sGoToBehindBall(id__,x__)
								[]
								terminate -> SKIP,Clock_CLID_sGoToBehindBall(id__,clock_type_plus(x__,1,CLID_sGoToBehindBall_clock_type(id__))))
						
						StateClocks(id__) = dbisim(Clock_CLID_sGoToBehindBall(id__,0))
						
						stateClockSync = {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered|}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = share__choice(get_nodeStatus?nodeStatus -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
						 [] dbisim((true)&(startGoToBehindBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
						 [] dbisim((true)&(stopGoToBehindBall__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim((true)&(stopGoToBehindBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startGoToBehindBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopGoToBehindBall__.NID_sRun.in,stopGoToBehindBall__.NID_sWaitStart.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__)
								   [| { share__, terminate } |] (
								   sWaitStart::D__(id__)
								   [| { share__, terminate } |] (
								   sRun::D__(id__)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startGoToBehindBall__.NID_sWaitStart.in,stopGoToBehindBall__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopGoToBehindBall__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_nodeStatus
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus]]
								)
							)
							 \ hideSet)
							[[
								startGoToBehindBall__.x____ <- startGoToBehindBall,
								stopGoToBehindBall__.x____ <- stopGoToBehindBall
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
					 within
						(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
					)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody(id__)
										[| {|get_CLID_sRun,sRun::entered,terminate|} |]
										dbisim(Clock_CLID_sRun(id__,0))
									)\{|get_CLID_sRun|}
								)
								[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
								dbisim(Clock_CLID_sWaitStart(id__,0))
							)\{|get_CLID_sWaitStart|}
						)
						) \ union(stateClockSync,enteredSS)
					)
					)
				
				Stateful(id__) = 
					((let
						getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,
						get_allyIsCloseToBall,set_allyIsCloseToBall,
						get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
						clockSync = {||}
					within
						(Behaviour(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											IteratedBehaviour(id__)
											[| {|get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack,terminate|} |]
											Memory_allyIsPushingBallWithHisBack(true)
										)\{|get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
									)
									[| {|get_allyIsCloseToBall,set_allyIsCloseToBall,terminate|} |]
									Memory_allyIsCloseToBall(true)
								)\{|get_allyIsCloseToBall,set_allyIsCloseToBall|}
							)
							[| {|get_allyIsBehindBall,set_allyIsBehindBall,terminate|} |]
							Memory_allyIsBehindBall(true)
						)\{|get_allyIsBehindBall,set_allyIsBehindBall|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startGoToBehindBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopGoToBehindBall__.NID_sRun.in,stopGoToBehindBall__.NID_sWaitStart.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sWaitStart::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sRun::VS_O__(id__)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startGoToBehindBall__.NID_sWaitStart.in,stopGoToBehindBall__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopGoToBehindBall__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_nodeStatus
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus]]
								)
							)
							 \ hideSet)
							[[
								startGoToBehindBall__.x____ <- startGoToBehindBall,
								stopGoToBehindBall__.x____ <- stopGoToBehindBall
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
					 within
						(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody_VS_O(id__)
										[| {|get_CLID_sRun,sRun::entered,terminate|} |]
										dbisim(Clock_CLID_sRun(id__,0))
									)\{|get_CLID_sRun|}
								)
								[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
								dbisim(Clock_CLID_sWaitStart(id__,0))
							)\{|get_CLID_sWaitStart|}
						)
						) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				Stateful_VS_O(id__) = 
					dbisim((let
						getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,
						get_allyIsCloseToBall,set_allyIsCloseToBall,
						get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											IteratedBehaviour_VS_O(id__)
											[| {|get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack,terminate|} |]
											Memory_allyIsPushingBallWithHisBack(true)
										)\{|get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
									)
									[| {|get_allyIsCloseToBall,set_allyIsCloseToBall,terminate|} |]
									Memory_allyIsCloseToBall(true)
								)\{|get_allyIsCloseToBall,set_allyIsCloseToBall|}
							)
							[| {|get_allyIsBehindBall,set_allyIsBehindBall,terminate|} |]
							Memory_allyIsBehindBall(true)
						)\{|get_allyIsBehindBall,set_allyIsBehindBall|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_allyIsBehindBall(allyIsBehindBall) =
					get_allyIsBehindBall!allyIsBehindBall -> Memory_allyIsBehindBall(allyIsBehindBall)
					[]
					set_allyIsBehindBall?x__ -> Memory_allyIsBehindBall(x__)
					[]
					terminate -> SKIP
				Memory_allyIsCloseToBall(allyIsCloseToBall) =
					get_allyIsCloseToBall!allyIsCloseToBall -> Memory_allyIsCloseToBall(allyIsCloseToBall)
					[]
					set_allyIsCloseToBall?x__ -> Memory_allyIsCloseToBall(x__)
					[]
					terminate -> SKIP
				Memory_allyIsPushingBallWithHisBack(allyIsPushingBallWithHisBack) =
					get_allyIsPushingBallWithHisBack!allyIsPushingBallWithHisBack -> Memory_allyIsPushingBallWithHisBack(allyIsPushingBallWithHisBack)
					[]
					set_allyIsPushingBallWithHisBack?x__ -> Memory_allyIsPushingBallWithHisBack(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_allyIsBehindBall(true)
				[| { terminate } |] (
				Memory_allyIsCloseToBall(true)
				[| { terminate } |] (
				Memory_allyIsPushingBallWithHisBack(true)
				)
				)
				
				getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,get_allyIsCloseToBall,set_allyIsCloseToBall,get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__) \ localClockResets
				D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
				O__(id__) = dbisim(D__(id__))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = dbisim(FVS__(id__))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
				HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sWaitStart(id__,x__) = 
					TimeOut_1(
						sWaitStart::entered -> Clock_CLID_sWaitStart(id__,0)
						[]
						get_CLID_sWaitStart!x__ -> Clock_CLID_sWaitStart(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sWaitStart(id__,clock_type_plus(x__,1,CLID_sWaitStart_clock_type(id__))))
				Clock_CLID_sRun(id__,x__) = 
					TimeOut_1(
						sRun::entered -> Clock_CLID_sRun(id__,0)
						[]
						get_CLID_sRun!x__ -> Clock_CLID_sRun(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sRun(id__,clock_type_plus(x__,1,CLID_sRun_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sWaitStart(id__,0))
				[| { terminate } |] (
				dbisim(Clock_CLID_sRun(id__,0))
				)
				
				stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
				
				-- Shared memory
				-- Shared memory variables
				Memory_nodeStatus(nodeStatus) =
					get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
					[]
					set_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					terminate -> SKIP
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
				
				sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
				
				sharedVarHide = {|get_nodeStatus|}
				}
		endmodule
		module stm_approach_ball_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyIsBehindBall, set_allyIsBehindBall, setL_allyIsBehindBall, setR_allyIsBehindBall: core_boolean
			channel get_allyIsCloseToBall, set_allyIsCloseToBall, setL_allyIsCloseToBall, setR_allyIsCloseToBall: core_boolean
			channel get_allyHasBall, set_allyHasBall, setL_allyHasBall, setR_allyHasBall: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startApproachBall__: NIDS.InOut
			channel startApproachBall: InOut
			channel stopApproachBall__: NIDS.InOut
			channel stopApproachBall: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startApproachBall,
				stopApproachBall
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sRun : core_clock_type 
			channel get_CLID_sWaitStart : core_clock_type 
			channel get_CLID_sFinal : core_clock_type 
			--channel increment__
			
			CLID_sRun_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sWaitStart_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sFinal_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
		
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sWaitStart
				module sWaitStart
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sRun
				module sRun
				
				enterSS = 
						{|			sInitial::enter,
							sFinal::enter,
							sApproach::enter
						|}
				enteredSS = 
						{|			sFinal::entered,
							sApproach::entered
						|}
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					-- declaring identifiers of transitions
					datatype NIDS = 
					              NID_sInitial|
					              NID_sFinal|
					              NID_sApproach
					
					channel internal__ : NIDS
					channel startApproachBall__: NIDS.InOut
					channel stopApproachBall__: NIDS.InOut
					
					channel get_CLID_sApproach : core_clock_type 
					--channel increment__
					
					CLID_sApproach_clock_type(id__) = 
						let
							max = (clock_type_max(Union({
					{}
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: sInitial
					module sInitial
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: sFinal
					module sFinal
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sApproach
					module sApproach
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		(let
								 			-- IMPLEMENTATION NOTE:
								 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 			-- modules for defining the semantics of each node.
								 			enterSS = {|
								 			sInitial::enter,
								 			sFinal::enter,
								 			sApproach::enter
								 			|}
								 			hideSet = union(enterSS,{|exit,exited,internal__|})
								 		within 
								 			((let
								 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 				-- because CSPM modules are used for the semantics of Node.
								 				flowevts = union(enterSS,{|exit,exited,interrupt|})
								 				transSync = {|internal__.NID_sInitial,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}
								 			within
								 				((
								 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 				   sInitial::D__(id__)
								 				   [| { share__, terminate } |] (
								 				   sFinal::D__(id__)
								 				   [| { share__, terminate } |] (
								 				   sApproach::D__(id__)
								 				   )
								 				   )
								 				 )
								 				 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 				 [[sApproach::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}]]
								 				 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 				 )
								 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 				  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
								 				 )
								 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 				 			,setL_allyIsCloseToBall
								 				 			,setL_allyHasBall
								 				 			,setL_allyIsBehindBall
								 				|}) |]
								 				 ((sInitial::enter -> Transitions(id__))
								 				  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_allyHasBall,setL_allyIsBehindBall |} ]]
								 				 )
								 				)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
								 				)
								 			)
								 			 \ hideSet)
								 			[[
								 				startApproachBall__.x____ <- startApproachBall,
								 				stopApproachBall__.x____ <- stopApproachBall
								 				| x____ <- NIDS
								 			]]
								 		)
								 		[| {|get_CLID_sApproach,sApproach::entered,terminate|} |]
								 		dbisim(Clock_CLID_sApproach(id__,0))
								 	)\{|get_CLID_sApproach|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_allyIsCloseToBall,setR_nodeStatus,setR_allyHasBall,setR_allyIsBehindBall |} ]] 
								  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_nodeStatus <- setL_nodeStatus,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_allyIsCloseToBall
								 			,setL_nodeStatus
								 			,setL_allyHasBall
								 			,setL_allyIsBehindBall
								 			,setR_allyIsCloseToBall
								 			 			,setR_nodeStatus
								 			 			,setR_allyHasBall
								 			 			,setR_allyIsBehindBall
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_nodeStatus,setL_allyHasBall,setL_allyIsBehindBall |} ]]
								  [[set_allyIsCloseToBall <- setR_allyIsCloseToBall,set_nodeStatus <- setR_nodeStatus,set_allyHasBall <- setR_allyHasBall,set_allyIsBehindBall <- setR_allyIsBehindBall]]
								 )
								)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_nodeStatus <- set_nodeStatus,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
								 [[setR_allyIsCloseToBall <- set_allyIsCloseToBall,setR_nodeStatus <- set_nodeStatus,setR_allyHasBall <- set_allyHasBall,setR_allyIsBehindBall <- set_allyIsBehindBall]]
								)\union(enteredSS,{terminate}) 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		(let
								 			-- IMPLEMENTATION NOTE:
								 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 			-- modules for defining the semantics of each node.
								 			enterSS = {|
								 			sInitial::enter,
								 			sFinal::enter,
								 			sApproach::enter
								 			|}
								 			hideSet = union(enterSS,{|exit,exited,internal__|})
								 		within 
								 			((let
								 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 				-- because CSPM modules are used for the semantics of Node.
								 				flowevts = union(enterSS,{|exit,exited,interrupt|})
								 				transSync = {|internal__.NID_sInitial,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}
								 			within
								 				((
								 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 				   sInitial::VS_O__(id__)
								 				   [| { share__, terminate } |] (
								 				   sFinal::VS_O__(id__)
								 				   [| { share__, terminate } |] (
								 				   sApproach::VS_O__(id__)
								 				   )
								 				   )
								 				 )
								 				 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 				 [[sApproach::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}]]
								 				 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 				 )
								 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 				  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
								 				 )
								 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 				 			,setL_allyIsCloseToBall
								 				 			,setL_allyHasBall
								 				 			,setL_allyIsBehindBall
								 				|}) |]
								 				 ((sInitial::enter -> Transitions(id__))
								 				  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_allyHasBall,setL_allyIsBehindBall |} ]]
								 				 )
								 				)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
								 				)
								 			)
								 			 \ hideSet)
								 			[[
								 				startApproachBall__.x____ <- startApproachBall,
								 				stopApproachBall__.x____ <- stopApproachBall
								 				| x____ <- NIDS
								 			]]
								 		)
								 		[| {|get_CLID_sApproach,sApproach::entered,terminate|} |]
								 		dbisim(Clock_CLID_sApproach(id__,0))
								 	)\{|get_CLID_sApproach|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_allyIsCloseToBall,setR_nodeStatus,setR_allyHasBall,setR_allyIsBehindBall |} ]] 
								  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_nodeStatus <- setL_nodeStatus,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_allyIsCloseToBall
								 			,setL_nodeStatus
								 			,setL_allyHasBall
								 			,setL_allyIsBehindBall
								 			,setR_allyIsCloseToBall
								 			 			,setR_nodeStatus
								 			 			,setR_allyHasBall
								 			 			,setR_allyIsBehindBall
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_nodeStatus,setL_allyHasBall,setL_allyIsBehindBall |} ]]
								  [[set_allyIsCloseToBall <- setR_allyIsCloseToBall,set_nodeStatus <- setR_nodeStatus,set_allyHasBall <- setR_allyHasBall,set_allyIsBehindBall <- setR_allyIsBehindBall]]
								 )
								)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_nodeStatus <- set_nodeStatus,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
								 [[setR_allyIsCloseToBall <- set_allyIsCloseToBall,setR_nodeStatus <- set_nodeStatus,setR_allyHasBall <- set_allyHasBall,setR_allyIsBehindBall <- set_allyIsBehindBall]]
								)\{terminate} 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
						
						Transitions(id__) = ((let
							Trans = share__choice(get_allyIsCloseToBall?allyIsCloseToBall -> get_allyHasBall?allyHasBall -> get_allyIsBehindBall?allyIsBehindBall -> TimeOut_1(
								 (share__ -> SKIP
								 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sApproach::enter -> SKIP))))
								 [] dbisim((allyHasBall)&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
								 [] dbisim(((((not (allyIsBehindBall)) or (not (allyIsCloseToBall)))))&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
								 [] dbisim(((((not (allyHasBall))) and (not ((((not (allyIsBehindBall)) or (not (allyIsCloseToBall))))))))&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sApproach::enter -> SKIP)))
								 []
								 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
								 []
								 terminate -> SKIP
								 )
							,SKIP);Trans
							)
						within
							Trans [|{terminate}|> SKIP
						)
						)
						
						
						-- Clocks
						Clock_CLID_sApproach(id__,x__) = 
							TimeOut_1(
								sApproach::entered -> Clock_CLID_sApproach(id__,0)
								[]
								get_CLID_sApproach!x__ -> Clock_CLID_sApproach(id__,x__)
								[]
								terminate -> SKIP,Clock_CLID_sApproach(id__,clock_type_plus(x__,1,CLID_sApproach_clock_type(id__))))
						
						StateClocks(id__) = dbisim(Clock_CLID_sApproach(id__,0))
						
						stateClockSync = {|get_CLID_sApproach,sApproach::entered|}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = share__choice(get_nodeStatus?nodeStatus -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
						 [] dbisim((true)&(startApproachBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
						 [] dbisim((true)&(stopApproachBall__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim((true)&(stopApproachBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startApproachBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopApproachBall__.NID_sRun.in,stopApproachBall__.NID_sWaitStart.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__)
								   [| { share__, terminate } |] (
								   sWaitStart::D__(id__)
								   [| { share__, terminate } |] (
								   sRun::D__(id__)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startApproachBall__.NID_sWaitStart.in,stopApproachBall__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopApproachBall__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_nodeStatus
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus]]
								)
							)
							 \ hideSet)
							[[
								startApproachBall__.x____ <- startApproachBall,
								stopApproachBall__.x____ <- stopApproachBall
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
					)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody(id__)
										[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
										dbisim(Clock_CLID_sWaitStart(id__,0))
									)\{|get_CLID_sWaitStart|}
								)
								[| {|get_CLID_sRun,sRun::entered,terminate|} |]
								dbisim(Clock_CLID_sRun(id__,0))
							)\{|get_CLID_sRun|}
						)
						) \ union(stateClockSync,enteredSS)
					)
					)
				
				Stateful(id__) = 
					((let
						getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,
						get_allyIsCloseToBall,set_allyIsCloseToBall,
						get_allyHasBall,set_allyHasBall|}
						clockSync = {||}
					within
						(Behaviour(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											IteratedBehaviour(id__)
											[| {|get_allyHasBall,set_allyHasBall,terminate|} |]
											Memory_allyHasBall(true)
										)\{|get_allyHasBall,set_allyHasBall|}
									)
									[| {|get_allyIsCloseToBall,set_allyIsCloseToBall,terminate|} |]
									Memory_allyIsCloseToBall(true)
								)\{|get_allyIsCloseToBall,set_allyIsCloseToBall|}
							)
							[| {|get_allyIsBehindBall,set_allyIsBehindBall,terminate|} |]
							Memory_allyIsBehindBall(true)
						)\{|get_allyIsBehindBall,set_allyIsBehindBall|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startApproachBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopApproachBall__.NID_sRun.in,stopApproachBall__.NID_sWaitStart.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sWaitStart::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sRun::VS_O__(id__)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startApproachBall__.NID_sWaitStart.in,stopApproachBall__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopApproachBall__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_nodeStatus
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus]]
								)
							)
							 \ hideSet)
							[[
								startApproachBall__.x____ <- startApproachBall,
								stopApproachBall__.x____ <- stopApproachBall
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody_VS_O(id__)
										[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
										dbisim(Clock_CLID_sWaitStart(id__,0))
									)\{|get_CLID_sWaitStart|}
								)
								[| {|get_CLID_sRun,sRun::entered,terminate|} |]
								dbisim(Clock_CLID_sRun(id__,0))
							)\{|get_CLID_sRun|}
						)
						) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				Stateful_VS_O(id__) = 
					dbisim((let
						getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,
						get_allyIsCloseToBall,set_allyIsCloseToBall,
						get_allyHasBall,set_allyHasBall|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											IteratedBehaviour_VS_O(id__)
											[| {|get_allyHasBall,set_allyHasBall,terminate|} |]
											Memory_allyHasBall(true)
										)\{|get_allyHasBall,set_allyHasBall|}
									)
									[| {|get_allyIsCloseToBall,set_allyIsCloseToBall,terminate|} |]
									Memory_allyIsCloseToBall(true)
								)\{|get_allyIsCloseToBall,set_allyIsCloseToBall|}
							)
							[| {|get_allyIsBehindBall,set_allyIsBehindBall,terminate|} |]
							Memory_allyIsBehindBall(true)
						)\{|get_allyIsBehindBall,set_allyIsBehindBall|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_allyIsBehindBall(allyIsBehindBall) =
					get_allyIsBehindBall!allyIsBehindBall -> Memory_allyIsBehindBall(allyIsBehindBall)
					[]
					set_allyIsBehindBall?x__ -> Memory_allyIsBehindBall(x__)
					[]
					terminate -> SKIP
				Memory_allyIsCloseToBall(allyIsCloseToBall) =
					get_allyIsCloseToBall!allyIsCloseToBall -> Memory_allyIsCloseToBall(allyIsCloseToBall)
					[]
					set_allyIsCloseToBall?x__ -> Memory_allyIsCloseToBall(x__)
					[]
					terminate -> SKIP
				Memory_allyHasBall(allyHasBall) =
					get_allyHasBall!allyHasBall -> Memory_allyHasBall(allyHasBall)
					[]
					set_allyHasBall?x__ -> Memory_allyHasBall(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_allyIsBehindBall(true)
				[| { terminate } |] (
				Memory_allyIsCloseToBall(true)
				[| { terminate } |] (
				Memory_allyHasBall(true)
				)
				)
				
				getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,get_allyIsCloseToBall,set_allyIsCloseToBall,get_allyHasBall,set_allyHasBall|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__) \ localClockResets
				D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
				O__(id__) = dbisim(D__(id__))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = dbisim(FVS__(id__))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
				HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sRun(id__,x__) = 
					TimeOut_1(
						sRun::entered -> Clock_CLID_sRun(id__,0)
						[]
						get_CLID_sRun!x__ -> Clock_CLID_sRun(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sRun(id__,clock_type_plus(x__,1,CLID_sRun_clock_type(id__))))
				Clock_CLID_sWaitStart(id__,x__) = 
					TimeOut_1(
						sWaitStart::entered -> Clock_CLID_sWaitStart(id__,0)
						[]
						get_CLID_sWaitStart!x__ -> Clock_CLID_sWaitStart(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sWaitStart(id__,clock_type_plus(x__,1,CLID_sWaitStart_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sRun(id__,0))
				[| { terminate } |] (
				dbisim(Clock_CLID_sWaitStart(id__,0))
				)
				
				stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
				
				-- Shared memory
				-- Shared memory variables
				Memory_nodeStatus(nodeStatus) =
					get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
					[]
					set_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					terminate -> SKIP
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
				
				sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
				
				sharedVarHide = {|get_nodeStatus|}
				}
		endmodule
		module stm_carry_ball_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyHasBall, set_allyHasBall, setL_allyHasBall, setR_allyHasBall: core_boolean
			channel get_ballIsPositioned, set_ballIsPositioned, setL_ballIsPositioned, setR_ballIsPositioned: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startCarryBall__: NIDS.InOut
			channel startCarryBall: InOut
			channel stopCarryBall__: NIDS.InOut
			channel stopCarryBall: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startCarryBall,
				stopCarryBall
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sFinal : core_clock_type 
			channel get_CLID_sRun : core_clock_type 
			channel get_CLID_sWaitStart : core_clock_type 
			--channel increment__
			
			CLID_sFinal_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sRun_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sWaitStart_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
		
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sWaitStart
				module sWaitStart
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sRun
				module sRun
				
				enterSS = 
						{|			sInitial::enter,
							sFinal::enter,
							sCarryBall::enter
						|}
				enteredSS = 
						{|			sFinal::entered,
							sCarryBall::entered
						|}
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					-- declaring identifiers of transitions
					datatype NIDS = 
					              NID_sInitial|
					              NID_sFinal|
					              NID_sCarryBall
					
					channel internal__ : NIDS
					channel startCarryBall__: NIDS.InOut
					channel stopCarryBall__: NIDS.InOut
					
					channel get_CLID_sCarryBall : core_clock_type 
					--channel increment__
					
					CLID_sCarryBall_clock_type(id__) = 
						let
							max = (clock_type_max(Union({
					{}
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: sInitial
					module sInitial
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: sFinal
					module sFinal
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sCarryBall
					module sCarryBall
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		(let
								 			-- IMPLEMENTATION NOTE:
								 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 			-- modules for defining the semantics of each node.
								 			enterSS = {|
								 			sInitial::enter,
								 			sFinal::enter,
								 			sCarryBall::enter
								 			|}
								 			hideSet = union(enterSS,{|exit,exited,internal__|})
								 		within 
								 			((let
								 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 				-- because CSPM modules are used for the semantics of Node.
								 				flowevts = union(enterSS,{|exit,exited,interrupt|})
								 				transSync = {|internal__.NID_sInitial,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}
								 			within
								 				((
								 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 				   sInitial::D__(id__)
								 				   [| { share__, terminate } |] (
								 				   sFinal::D__(id__)
								 				   [| { share__, terminate } |] (
								 				   sCarryBall::D__(id__)
								 				   )
								 				   )
								 				 )
								 				 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 				 [[sCarryBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}]]
								 				 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 				 )
								 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 				  [[set_ballIsPositioned <- setL_ballIsPositioned,set_allyHasBall <- setL_allyHasBall]]
								 				 )
								 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 				 			,setL_ballIsPositioned
								 				 			,setL_allyHasBall
								 				|}) |]
								 				 ((sInitial::enter -> Transitions(id__))
								 				  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned,setL_allyHasBall |} ]]
								 				 )
								 				)[[setL_ballIsPositioned <- set_ballIsPositioned,setL_allyHasBall <- set_allyHasBall]]
								 				)
								 			)
								 			 \ hideSet)
								 			[[
								 				startCarryBall__.x____ <- startCarryBall,
								 				stopCarryBall__.x____ <- stopCarryBall
								 				| x____ <- NIDS
								 			]]
								 		)
								 		[| {|get_CLID_sCarryBall,sCarryBall::entered,terminate|} |]
								 		dbisim(Clock_CLID_sCarryBall(id__,0))
								 	)\{|get_CLID_sCarryBall|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_ballIsPositioned,setR_nodeStatus,setR_allyHasBall |} ]] 
								  [[set_ballIsPositioned <- setL_ballIsPositioned,set_nodeStatus <- setL_nodeStatus,set_allyHasBall <- setL_allyHasBall]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_ballIsPositioned
								 			,setL_nodeStatus
								 			,setL_allyHasBall
								 			,setR_ballIsPositioned
								 			 			,setR_nodeStatus
								 			 			,setR_allyHasBall
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned,setL_nodeStatus,setL_allyHasBall |} ]]
								  [[set_ballIsPositioned <- setR_ballIsPositioned,set_nodeStatus <- setR_nodeStatus,set_allyHasBall <- setR_allyHasBall]]
								 )
								)[[setL_ballIsPositioned <- set_ballIsPositioned,setL_nodeStatus <- set_nodeStatus,setL_allyHasBall <- set_allyHasBall]]
								 [[setR_ballIsPositioned <- set_ballIsPositioned,setR_nodeStatus <- set_nodeStatus,setR_allyHasBall <- set_allyHasBall]]
								)\union(enteredSS,{terminate}) 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		(let
								 			-- IMPLEMENTATION NOTE:
								 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 			-- modules for defining the semantics of each node.
								 			enterSS = {|
								 			sInitial::enter,
								 			sFinal::enter,
								 			sCarryBall::enter
								 			|}
								 			hideSet = union(enterSS,{|exit,exited,internal__|})
								 		within 
								 			((let
								 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 				-- because CSPM modules are used for the semantics of Node.
								 				flowevts = union(enterSS,{|exit,exited,interrupt|})
								 				transSync = {|internal__.NID_sInitial,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}
								 			within
								 				((
								 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 				   sInitial::VS_O__(id__)
								 				   [| { share__, terminate } |] (
								 				   sFinal::VS_O__(id__)
								 				   [| { share__, terminate } |] (
								 				   sCarryBall::VS_O__(id__)
								 				   )
								 				   )
								 				 )
								 				 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 				 [[sCarryBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}]]
								 				 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 				 )
								 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 				  [[set_ballIsPositioned <- setL_ballIsPositioned,set_allyHasBall <- setL_allyHasBall]]
								 				 )
								 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 				 			,setL_ballIsPositioned
								 				 			,setL_allyHasBall
								 				|}) |]
								 				 ((sInitial::enter -> Transitions(id__))
								 				  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned,setL_allyHasBall |} ]]
								 				 )
								 				)[[setL_ballIsPositioned <- set_ballIsPositioned,setL_allyHasBall <- set_allyHasBall]]
								 				)
								 			)
								 			 \ hideSet)
								 			[[
								 				startCarryBall__.x____ <- startCarryBall,
								 				stopCarryBall__.x____ <- stopCarryBall
								 				| x____ <- NIDS
								 			]]
								 		)
								 		[| {|get_CLID_sCarryBall,sCarryBall::entered,terminate|} |]
								 		dbisim(Clock_CLID_sCarryBall(id__,0))
								 	)\{|get_CLID_sCarryBall|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_ballIsPositioned,setR_nodeStatus,setR_allyHasBall |} ]] 
								  [[set_ballIsPositioned <- setL_ballIsPositioned,set_nodeStatus <- setL_nodeStatus,set_allyHasBall <- setL_allyHasBall]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_ballIsPositioned
								 			,setL_nodeStatus
								 			,setL_allyHasBall
								 			,setR_ballIsPositioned
								 			 			,setR_nodeStatus
								 			 			,setR_allyHasBall
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned,setL_nodeStatus,setL_allyHasBall |} ]]
								  [[set_ballIsPositioned <- setR_ballIsPositioned,set_nodeStatus <- setR_nodeStatus,set_allyHasBall <- setR_allyHasBall]]
								 )
								)[[setL_ballIsPositioned <- set_ballIsPositioned,setL_nodeStatus <- set_nodeStatus,setL_allyHasBall <- set_allyHasBall]]
								 [[setR_ballIsPositioned <- set_ballIsPositioned,setR_nodeStatus <- set_nodeStatus,setR_allyHasBall <- set_allyHasBall]]
								)\{terminate} 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
						
						Transitions(id__) = ((let
							Trans = share__choice(get_ballIsPositioned?ballIsPositioned -> get_allyHasBall?allyHasBall -> TimeOut_1(
								 (share__ -> SKIP
								 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sCarryBall::enter -> SKIP))))
								 [] dbisim((ballIsPositioned)&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
								 [] dbisim(((((not (ballIsPositioned))) and allyHasBall))&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sCarryBall::enter -> SKIP)))
								 [] dbisim(((not (allyHasBall)))&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
								 []
								 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
								 []
								 terminate -> SKIP
								 )
							,SKIP);Trans
							)
						within
							Trans [|{terminate}|> SKIP
						)
						)
						
						
						-- Clocks
						Clock_CLID_sCarryBall(id__,x__) = 
							TimeOut_1(
								sCarryBall::entered -> Clock_CLID_sCarryBall(id__,0)
								[]
								get_CLID_sCarryBall!x__ -> Clock_CLID_sCarryBall(id__,x__)
								[]
								terminate -> SKIP,Clock_CLID_sCarryBall(id__,clock_type_plus(x__,1,CLID_sCarryBall_clock_type(id__))))
						
						StateClocks(id__) = dbisim(Clock_CLID_sCarryBall(id__,0))
						
						stateClockSync = {|get_CLID_sCarryBall,sCarryBall::entered|}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = share__choice(get_ballIsPositioned?ballIsPositioned -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
						 [] dbisim((true)&(startCarryBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
						 [] dbisim((ballIsPositioned)&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sWaitStart::enter -> SKIP)))
						 [] dbisim((true)&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sWaitStart::enter -> SKIP)))
						 [] dbisim((true)&(stopCarryBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim((true)&(stopCarryBall__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startCarryBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopCarryBall__.NID_sWaitStart.in,stopCarryBall__.NID_sRun.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__)
								   [| { share__, terminate } |] (
								   sWaitStart::D__(id__)
								   [| { share__, terminate } |] (
								   sRun::D__(id__)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBall__.NID_sWaitStart.in,stopCarryBall__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopCarryBall__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_ballIsPositioned <- setL_ballIsPositioned]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_ballIsPositioned
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned |} ]]
								 )
								)[[setL_ballIsPositioned <- set_ballIsPositioned]]
								)
							)
							 \ hideSet)
							[[
								startCarryBall__.x____ <- startCarryBall,
								stopCarryBall__.x____ <- stopCarryBall
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
					)
					)
				
				IteratedBehaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody(id__)
										[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
										dbisim(Clock_CLID_sWaitStart(id__,0))
									)\{|get_CLID_sWaitStart|}
								)
								[| {|get_CLID_sRun,sRun::entered,terminate|} |]
								dbisim(Clock_CLID_sRun(id__,0))
							)\{|get_CLID_sRun|}
						)
						) \ union(stateClockSync,enteredSS)
					)
					)
				
				Stateful(id__) = 
					((let
						getsetLocalChannels = {|get_allyHasBall,set_allyHasBall,
						get_ballIsPositioned,set_ballIsPositioned|}
						clockSync = {||}
					within
						(Behaviour(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									IteratedBehaviour(id__)
									[| {|get_ballIsPositioned,set_ballIsPositioned,terminate|} |]
									Memory_ballIsPositioned(true)
								)\{|get_ballIsPositioned,set_ballIsPositioned|}
							)
							[| {|get_allyHasBall,set_allyHasBall,terminate|} |]
							Memory_allyHasBall(true)
						)\{|get_allyHasBall,set_allyHasBall|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startCarryBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopCarryBall__.NID_sWaitStart.in,stopCarryBall__.NID_sRun.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sWaitStart::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sRun::VS_O__(id__)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBall__.NID_sWaitStart.in,stopCarryBall__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopCarryBall__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_ballIsPositioned <- setL_ballIsPositioned]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_ballIsPositioned
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned |} ]]
								 )
								)[[setL_ballIsPositioned <- set_ballIsPositioned]]
								)
							)
							 \ hideSet)
							[[
								startCarryBall__.x____ <- startCarryBall,
								stopCarryBall__.x____ <- stopCarryBall
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				IteratedBehaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody_VS_O(id__)
										[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
										dbisim(Clock_CLID_sWaitStart(id__,0))
									)\{|get_CLID_sWaitStart|}
								)
								[| {|get_CLID_sRun,sRun::entered,terminate|} |]
								dbisim(Clock_CLID_sRun(id__,0))
							)\{|get_CLID_sRun|}
						)
						) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				Stateful_VS_O(id__) = 
					dbisim((let
						getsetLocalChannels = {|get_allyHasBall,set_allyHasBall,
						get_ballIsPositioned,set_ballIsPositioned|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful_VS_O(id__) =
					(dbisim(
						sbisim(
							dbisim(
								sbisim(
									IteratedBehaviour_VS_O(id__)
									[| {|get_ballIsPositioned,set_ballIsPositioned,terminate|} |]
									Memory_ballIsPositioned(true)
								)\{|get_ballIsPositioned,set_ballIsPositioned|}
							)
							[| {|get_allyHasBall,set_allyHasBall,terminate|} |]
							Memory_allyHasBall(true)
						)\{|get_allyHasBall,set_allyHasBall|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_allyHasBall(allyHasBall) =
					get_allyHasBall!allyHasBall -> Memory_allyHasBall(allyHasBall)
					[]
					set_allyHasBall?x__ -> Memory_allyHasBall(x__)
					[]
					terminate -> SKIP
				Memory_ballIsPositioned(ballIsPositioned) =
					get_ballIsPositioned!ballIsPositioned -> Memory_ballIsPositioned(ballIsPositioned)
					[]
					set_ballIsPositioned?x__ -> Memory_ballIsPositioned(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_allyHasBall(true)
				[| { terminate } |] (
				Memory_ballIsPositioned(true)
				)
				
				getsetLocalChannels = {|get_allyHasBall,set_allyHasBall,get_ballIsPositioned,set_ballIsPositioned|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__) \ localClockResets
				D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
				O__(id__) = dbisim(D__(id__))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = dbisim(FVS__(id__))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
				HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sRun(id__,x__) = 
					TimeOut_1(
						sRun::entered -> Clock_CLID_sRun(id__,0)
						[]
						get_CLID_sRun!x__ -> Clock_CLID_sRun(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sRun(id__,clock_type_plus(x__,1,CLID_sRun_clock_type(id__))))
				Clock_CLID_sWaitStart(id__,x__) = 
					TimeOut_1(
						sWaitStart::entered -> Clock_CLID_sWaitStart(id__,0)
						[]
						get_CLID_sWaitStart!x__ -> Clock_CLID_sWaitStart(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sWaitStart(id__,clock_type_plus(x__,1,CLID_sWaitStart_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sRun(id__,0))
				[| { terminate } |] (
				dbisim(Clock_CLID_sWaitStart(id__,0))
				)
				
				stateClockSync = {|get_CLID_sRun,sRun::entered,get_CLID_sWaitStart,sWaitStart::entered|}
				
				-- Shared memory
				-- Shared memory variables
				Memory_nodeStatus(nodeStatus) =
					get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
					[]
					set_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					terminate -> SKIP
				
				-- sharedVarMemory process
				sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
				
				sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
				
				sharedVarHide = {|get_nodeStatus|}
				}
		endmodule
		module stm_move_away_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_robotIsFarEnoughFromPosition, set_robotIsFarEnoughFromPosition, setL_robotIsFarEnoughFromPosition, setR_robotIsFarEnoughFromPosition: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startMoveAwayFromPosition__: NIDS.InOut
			channel startMoveAwayFromPosition: InOut
			channel stopMoveAwayFromPosition__: NIDS.InOut
			channel stopMoveAwayFromPosition: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startMoveAwayFromPosition,
				stopMoveAwayFromPosition
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sWaitStart : core_clock_type 
			channel get_CLID_sFinal : core_clock_type 
			channel get_CLID_sRun : core_clock_type 
			--channel increment__
			
			CLID_sWaitStart_clock_type(id__,
					          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sFinal_clock_type(id__,
					          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sRun_clock_type(id__,
					          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
		
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = D__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = D__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sWaitStart
				module sWaitStart
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sRun
				module sRun
				
				enterSS = 
						{|			sInitial::enter,
							sFinal::enter,
							sMoveAway::enter
						|}
				enteredSS = 
						{|			sFinal::entered,
							sMoveAway::entered
						|}
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					-- declaring identifiers of transitions
					datatype NIDS = 
					              NID_sInitial|
					              NID_sFinal|
					              NID_sMoveAway
					
					channel internal__ : NIDS
					channel startMoveAwayFromPosition__: NIDS.InOut
					channel stopMoveAwayFromPosition__: NIDS.InOut
					
					channel get_CLID_sMoveAway : core_clock_type 
					--channel increment__
					
					CLID_sMoveAway_clock_type(id__,
							          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
						let
							max = (clock_type_max(Union({
					{},
					({const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE|TIME_LIMIT_TO_BEHAVE <- core_nat}),
					({const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE|TIME_LIMIT_TO_BEHAVE <- core_nat})
					}))+1)
						ctype = {0..max}
					within
						if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
					
					
					--	Nodes
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: sInitial
					module sInitial
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = D__(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Final state: sFinal
					module sFinal
					
					exports
					
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							D__(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
									
									Entering 	= entered -> SKIP ; Active
									Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
									Interrupted	= share__choice(exit -> exited -> Inactive)
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = D__(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: sMoveAway
					module sMoveAway
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		(let
								 			-- IMPLEMENTATION NOTE:
								 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 			-- modules for defining the semantics of each node.
								 			enterSS = {|
								 			sInitial::enter,
								 			sFinal::enter,
								 			sMoveAway::enter
								 			|}
								 			hideSet = union(enterSS,{|exit,exited,internal__|})
								 		within 
								 			((let
								 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 				-- because CSPM modules are used for the semantics of Node.
								 				flowevts = union(enterSS,{|exit,exited,interrupt|})
								 				transSync = {|internal__.NID_sInitial,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}
								 			within
								 				((
								 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 				   sInitial::D__(id__,
								 				   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								 				   [| { share__, terminate } |] (
								 				   sFinal::D__(id__,
								 				   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								 				   [| { share__, terminate } |] (
								 				   sMoveAway::D__(id__,
								 				   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								 				   )
								 				   )
								 				 )
								 				 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 				 [[sMoveAway::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}]]
								 				 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 				 )
								 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 				  [[set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition,sMoveAway::entered <- sMoveAway::enteredL]]
								 				 )
								 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 				 			,setL_robotIsFarEnoughFromPosition
								 				 			,sMoveAway::enteredL
								 				|}) |]
								 				 ((sInitial::enter -> Transitions(id__,
								 				 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
								 				  [[ share__ <- x__ | x__ <- {| share__,setL_robotIsFarEnoughFromPosition,sMoveAway::enteredL |} ]]
								 				 )
								 				)[[setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition,sMoveAway::enteredL <- sMoveAway::entered]]
								 				)
								 			)
								 			 \ hideSet)
								 			[[
								 				startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
								 				stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
								 				| x____ <- NIDS
								 			]]
								 		)
								 		[| {|get_CLID_sMoveAway,sMoveAway::entered,terminate|} |]
								 		dbisim(Clock_CLID_sMoveAway(id__,0,
								 				          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
								 	)\{|get_CLID_sMoveAway|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotIsFarEnoughFromPosition |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus,set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_nodeStatus
								 			,setL_robotIsFarEnoughFromPosition
								 			,setR_nodeStatus
								 			 			,setR_robotIsFarEnoughFromPosition
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotIsFarEnoughFromPosition |} ]]
								  [[set_nodeStatus <- setR_nodeStatus,set_robotIsFarEnoughFromPosition <- setR_robotIsFarEnoughFromPosition]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus,setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
								 [[setR_nodeStatus <- set_nodeStatus,setR_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
								)\union(enteredSS,{terminate}) 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= SKIP ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
						
							Behaviour 	= dbisim(
								((
								 (((dbisim(
								 	sbisim(
								 		(let
								 			-- IMPLEMENTATION NOTE:
								 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								 			-- modules for defining the semantics of each node.
								 			enterSS = {|
								 			sInitial::enter,
								 			sFinal::enter,
								 			sMoveAway::enter
								 			|}
								 			hideSet = union(enterSS,{|exit,exited,internal__|})
								 		within 
								 			((let
								 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								 				-- because CSPM modules are used for the semantics of Node.
								 				flowevts = union(enterSS,{|exit,exited,interrupt|})
								 				transSync = {|internal__.NID_sInitial,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}
								 			within
								 				((
								 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								 				   sInitial::VS_O__(id__,
								 				   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								 				   [| { share__, terminate } |] (
								 				   sFinal::VS_O__(id__,
								 				   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								 				   [| { share__, terminate } |] (
								 				   sMoveAway::VS_O__(id__,
								 				   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								 				   )
								 				   )
								 				 )
								 				 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 				 [[sMoveAway::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}]]
								 				 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 				 )
								 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 				  [[set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition,sMoveAway::entered <- sMoveAway::enteredL]]
								 				 )
								 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 				 			,setL_robotIsFarEnoughFromPosition
								 				 			,sMoveAway::enteredL
								 				|}) |]
								 				 ((sInitial::enter -> Transitions(id__,
								 				 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
								 				  [[ share__ <- x__ | x__ <- {| share__,setL_robotIsFarEnoughFromPosition,sMoveAway::enteredL |} ]]
								 				 )
								 				)[[setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition,sMoveAway::enteredL <- sMoveAway::entered]]
								 				)
								 			)
								 			 \ hideSet)
								 			[[
								 				startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
								 				stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
								 				| x____ <- NIDS
								 			]]
								 		)
								 		[| {|get_CLID_sMoveAway,sMoveAway::entered,terminate|} |]
								 		dbisim(Clock_CLID_sMoveAway(id__,0,
								 				          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
								 	)\{|get_CLID_sMoveAway|}
								 )
								 ))
								  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotIsFarEnoughFromPosition |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus,set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition]]
								 )
								 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
								 			,setL_nodeStatus
								 			,setL_robotIsFarEnoughFromPosition
								 			,setR_nodeStatus
								 			 			,setR_robotIsFarEnoughFromPosition
								 			|}) |]
								 ((During)
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotIsFarEnoughFromPosition |} ]]
								  [[set_nodeStatus <- setR_nodeStatus,set_robotIsFarEnoughFromPosition <- setR_robotIsFarEnoughFromPosition]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus,setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
								 [[setR_nodeStatus <- set_nodeStatus,setR_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
								)\{terminate} 
							)
							During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
									 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
						within
							Inactive [| {terminate} |> SKIP)
						
						Transitions(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = ((let
							Trans = share__choice(get_robotIsFarEnoughFromPosition?robotIsFarEnoughFromPosition -> get_CLID_sMoveAway?sMoveAway -> TimeOut_1(
								 (share__ -> SKIP
								 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sMoveAway::enter -> SKIP))))
								 [] dbisim((robotIsFarEnoughFromPosition)&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
								 [] dbisim(((((not (robotIsFarEnoughFromPosition))) and ((not ((((sMoveAway>const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) and ((not (robotIsFarEnoughFromPosition))))))))))&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sMoveAway::enter -> SKIP)))
								 [] dbisim((((sMoveAway>const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) and ((not (robotIsFarEnoughFromPosition)))))&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
								 []
								 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
								 []
								 terminate -> SKIP
								 )
							,SKIP);Trans
							)
						within
							Trans [|{terminate}|> SKIP
						)
						)
						
						
						-- Clocks
						Clock_CLID_sMoveAway(id__,x__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
							TimeOut_1(
								sMoveAway::entered -> Clock_CLID_sMoveAway(id__,0,
										          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								[]
								get_CLID_sMoveAway!x__ -> Clock_CLID_sMoveAway(id__,x__,
										          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								[]
								terminate -> SKIP,Clock_CLID_sMoveAway(id__,clock_type_plus(x__,1,CLID_sMoveAway_clock_type(id__,
										          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)),
										          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
						
						StateClocks(id__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = dbisim(Clock_CLID_sMoveAway(id__,0,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
						
						stateClockSync = {|get_CLID_sMoveAway,sMoveAway::entered|}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				STM_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				-- Transitions
				Transitions(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = ((let
					Trans = share__choice(get_nodeStatus?nodeStatus -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
						 [] dbisim((true)&(startMoveAwayFromPosition__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
						 [] dbisim((true)&(stopMoveAwayFromPosition__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim((true)&(stopMoveAwayFromPosition__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startMoveAwayFromPosition__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopMoveAwayFromPosition__.NID_sRun.in,stopMoveAwayFromPosition__.NID_sWaitStart.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__,
								   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__,
								   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sWaitStart::D__(id__,
								   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sRun::D__(id__,
								   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startMoveAwayFromPosition__.NID_sWaitStart.in,stopMoveAwayFromPosition__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopMoveAwayFromPosition__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_nodeStatus
								|}) |]
								 ((sInitial::enter -> Transitions(id__,
								 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus]]
								)
							)
							 \ hideSet)
							[[
								startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
								stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__,
						 		          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
					 within
						(MachineBody(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)) \ union(stateClockSync,enteredSS)
					)
					)
				
				IteratedBehaviour(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody(id__,
												    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
										[| {|get_CLID_sRun,sRun::entered,terminate|} |]
										dbisim(Clock_CLID_sRun(id__,0,
												          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
									)\{|get_CLID_sRun|}
								)
								[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
								dbisim(Clock_CLID_sWaitStart(id__,0,
										          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
							)\{|get_CLID_sWaitStart|}
						)
						) \ union(stateClockSync,enteredSS)
					)
					)
				
				Stateful(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					((let
						getsetLocalChannels = {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
						clockSync = {||}
					within
						(Behaviour(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__,
						 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [| {terminate} |] Clocks(id__,
						 		          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) =
					(dbisim(
						sbisim(
							IteratedBehaviour(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							[| {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition,terminate|} |]
							Memory_robotIsFarEnoughFromPosition(true)
						)\{|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sFinal::enter,
							sWaitStart::enter,
							sRun::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,startMoveAwayFromPosition__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopMoveAwayFromPosition__.NID_sRun.in,stopMoveAwayFromPosition__.NID_sWaitStart.in|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__,
								   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__,
								   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sWaitStart::VS_O__(id__,
								   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sRun::VS_O__(id__,
								   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
								   )
								   )
								   )
								 )
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startMoveAwayFromPosition__.NID_sWaitStart.in,stopMoveAwayFromPosition__.NID_sWaitStart.in|}]]
								 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopMoveAwayFromPosition__.NID_sRun.in|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_nodeStatus
								|}) |]
								 ((sInitial::enter -> Transitions(id__,
								 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus]]
								)
							)
							 \ hideSet)
							[[
								startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
								stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
								| x____ <- NIDS
							]]
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__,
						 		          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
					 within
						(MachineBody_VS_O(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
					 within
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										MachineBody_VS_O(id__,
												    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
										[| {|get_CLID_sRun,sRun::entered,terminate|} |]
										dbisim(Clock_CLID_sRun(id__,0,
												          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
									)\{|get_CLID_sRun|}
								)
								[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
								dbisim(Clock_CLID_sWaitStart(id__,0,
										          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
							)\{|get_CLID_sWaitStart|}
						)
						) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				Stateful_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						getsetLocalChannels = {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__,
						 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [| {terminate} |] Clocks(id__,
						 		          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) =
					(dbisim(
						sbisim(
							IteratedBehaviour_VS_O(id__,
									    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							[| {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition,terminate|} |]
							Memory_robotIsFarEnoughFromPosition(true)
						)\{|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_robotIsFarEnoughFromPosition(robotIsFarEnoughFromPosition) =
					get_robotIsFarEnoughFromPosition!robotIsFarEnoughFromPosition -> Memory_robotIsFarEnoughFromPosition(robotIsFarEnoughFromPosition)
					[]
					set_robotIsFarEnoughFromPosition?x__ -> Memory_robotIsFarEnoughFromPosition(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = Memory_robotIsFarEnoughFromPosition(true)
				
				getsetLocalChannels = {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = STM_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) \ localClockResets
				D__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = timed_priority(STM(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) \ union(internal_events,localClockResets))
				O__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = dbisim(D__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				VS__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = FVS__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
				VS_O__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = dbisim(FVS__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				HEXT__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = O__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [|shared_variable_events|] SKIP
				FVS_C__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = dbisim(timed_priority(STM(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) \ internal_events))
				HUP__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = timed_priority(O__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__,
						          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sWaitStart(id__,x__,
						          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					TimeOut_1(
						sWaitStart::entered -> Clock_CLID_sWaitStart(id__,0,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						[]
						get_CLID_sWaitStart!x__ -> Clock_CLID_sWaitStart(id__,x__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						[]
						terminate -> SKIP,Clock_CLID_sWaitStart(id__,clock_type_plus(x__,1,CLID_sWaitStart_clock_type(id__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)),
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				Clock_CLID_sRun(id__,x__,
						          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					TimeOut_1(
						sRun::entered -> Clock_CLID_sRun(id__,0,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						[]
						get_CLID_sRun!x__ -> Clock_CLID_sRun(id__,x__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						[]
						terminate -> SKIP,Clock_CLID_sRun(id__,clock_type_plus(x__,1,CLID_sRun_clock_type(id__,
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)),
								          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				
				StateClocks(id__,
						          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = dbisim(Clock_CLID_sWaitStart(id__,0,
						          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				[| { terminate } |] (
				dbisim(Clock_CLID_sRun(id__,0,
						          const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				)
				
				stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
				
				-- Shared memory
				-- Shared memory variables
				Memory_nodeStatus(nodeStatus) =
					get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
					[]
					set_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					terminate -> SKIP
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = Memory_nodeStatus(NODE_STATUS_RUNNING)
				
				sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
				
				sharedVarHide = {|get_nodeStatus|}
				}
		endmodule
		
		Timed(OneStep) {
				-- undefined operations
				
				-- declaring controller memory
				Memory(id__, nodeStatus) = (
					set_nodeStatus?x__ -> stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus!x__ -> stm_go_to_behind_ball_ref::set_EXT_nodeStatus!x__ -> stm_approach_ball_ref::set_EXT_nodeStatus!x__ -> stm_carry_ball_ref::set_EXT_nodeStatus!x__ -> stm_move_away_ref::set_EXT_nodeStatus!x__ -> 
					Memory(id__,x__)
				)
				
				D__(id__,
						    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = prioritise(	((
						(
							stm_behavior_ref::D__(id__)[[
								stm_behavior_ref::terminate <- terminate,
								stm_behavior_ref::receiveField <- receiveField,
								stm_behavior_ref::receiveFrame <- receiveFrame,
								stm_behavior_ref::receiveTactic <- receiveTactic,
								stm_behavior_ref::sendAction <- sendAction
							]]
							\ {|
								stm_behavior_ref::sendSkill,
								stm_behavior_ref::startHalt,
								stm_behavior_ref::stopHalt
							|}
						)
							[|{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|}|]
						(
							(
								stm_carry_ball_on_ball_placement_ref::D__(id__)[[
									stm_carry_ball_on_ball_placement_ref::terminate <- terminate,
									stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.in <- stm_behavior_ref::startCarryBallOnBallPlacement.out,
									stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.out <- stm_behavior_ref::startCarryBallOnBallPlacement.in,
									stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.in <- stm_behavior_ref::stopCarryBallOnBallPlacement.out,
									stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.out <- stm_behavior_ref::stopCarryBallOnBallPlacement.in,
									stm_carry_ball_on_ball_placement_ref::set_nodeStatus <- set_nodeStatus,
									stm_carry_ball_on_ball_placement_ref::get_nodeStatus <- get_nodeStatus
								]]
							)
								[|{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|}|]
							(
								(
									stm_go_to_behind_ball_ref::D__(id__)[[
										stm_go_to_behind_ball_ref::terminate <- terminate,
										stm_go_to_behind_ball_ref::startGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.out,
										stm_go_to_behind_ball_ref::startGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.in,
										stm_go_to_behind_ball_ref::stopGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.out,
										stm_go_to_behind_ball_ref::stopGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.in,
										stm_go_to_behind_ball_ref::set_nodeStatus <- set_nodeStatus,
										stm_go_to_behind_ball_ref::get_nodeStatus <- get_nodeStatus
									]]
								)
									[|{|terminate|}|]
								(
									(
										stm_approach_ball_ref::D__(id__)[[
											stm_approach_ball_ref::terminate <- terminate,
											stm_approach_ball_ref::startApproachBall.in <- stm_carry_ball_on_ball_placement_ref::startApproachBall.out,
											stm_approach_ball_ref::startApproachBall.out <- stm_carry_ball_on_ball_placement_ref::startApproachBall.in,
											stm_approach_ball_ref::stopApproachBall.in <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.out,
											stm_approach_ball_ref::stopApproachBall.out <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.in,
											stm_approach_ball_ref::set_nodeStatus <- set_nodeStatus,
											stm_approach_ball_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
										[|{|terminate|}|]
									(
										(
											stm_carry_ball_ref::D__(id__)[[
												stm_carry_ball_ref::terminate <- terminate,
												stm_carry_ball_ref::startCarryBall.in <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.out,
												stm_carry_ball_ref::startCarryBall.out <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.in,
												stm_carry_ball_ref::stopCarryBall.in <- stm_carry_ball_on_ball_placement_ref::startCarryBall.out,
												stm_carry_ball_ref::stopCarryBall.out <- stm_carry_ball_on_ball_placement_ref::startCarryBall.in,
												stm_carry_ball_ref::set_nodeStatus <- set_nodeStatus,
												stm_carry_ball_ref::get_nodeStatus <- get_nodeStatus
											]]
										)
											[|{|terminate|}|]
										(
											let
												const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE = 30
											within 
											stm_move_away_ref::D__(id__,
													    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)[[
												stm_move_away_ref::terminate <- terminate,
												stm_move_away_ref::startMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.out,
												stm_move_away_ref::startMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.in,
												stm_move_away_ref::stopMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.out,
												stm_move_away_ref::stopMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.in,
												stm_move_away_ref::set_nodeStatus <- set_nodeStatus,
												stm_move_away_ref::get_nodeStatus <- get_nodeStatus
											]]
										)
									)
									\diff(
										{|terminate|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|},
						{|terminate|}
					)
						[|
							union(
								{|
									set_nodeStatus
								|},
								{|
									stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
									stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
									stm_approach_ball_ref::set_EXT_nodeStatus,
									stm_carry_ball_ref::set_EXT_nodeStatus,
									stm_move_away_ref::set_EXT_nodeStatus
								|}
							)
						|]
					Memory(id__, NODE_STATUS_RUNNING)
				)
				\ union(
					{|
						set_nodeStatus, get_nodeStatus
					|},
					{|
						stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
						stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
						stm_approach_ball_ref::set_EXT_nodeStatus,
						stm_carry_ball_ref::set_EXT_nodeStatus,
						stm_move_away_ref::set_EXT_nodeStatus
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
				-- VS version
				VS__(id__,
						    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = prioritise(	((
						(
							stm_behavior_ref::VS__(id__)[[
								stm_behavior_ref::terminate <- terminate,
								stm_behavior_ref::receiveField <- receiveField,
								stm_behavior_ref::receiveFrame <- receiveFrame,
								stm_behavior_ref::receiveTactic <- receiveTactic,
								stm_behavior_ref::sendAction <- sendAction
							]]
							\ {|
								stm_behavior_ref::sendSkill,
								stm_behavior_ref::startHalt,
								stm_behavior_ref::stopHalt
							|}
						)
							[|{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|}|]
						(
							(
								stm_carry_ball_on_ball_placement_ref::VS__(id__)[[
									stm_carry_ball_on_ball_placement_ref::terminate <- terminate,
									stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.in <- stm_behavior_ref::startCarryBallOnBallPlacement.out,
									stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.out <- stm_behavior_ref::startCarryBallOnBallPlacement.in,
									stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.in <- stm_behavior_ref::stopCarryBallOnBallPlacement.out,
									stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.out <- stm_behavior_ref::stopCarryBallOnBallPlacement.in,
									stm_carry_ball_on_ball_placement_ref::set_nodeStatus <- set_nodeStatus,
									stm_carry_ball_on_ball_placement_ref::get_nodeStatus <- get_nodeStatus
								]]
							)
								[|{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|}|]
							(
								(
									stm_go_to_behind_ball_ref::VS__(id__)[[
										stm_go_to_behind_ball_ref::terminate <- terminate,
										stm_go_to_behind_ball_ref::startGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.out,
										stm_go_to_behind_ball_ref::startGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.in,
										stm_go_to_behind_ball_ref::stopGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.out,
										stm_go_to_behind_ball_ref::stopGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.in,
										stm_go_to_behind_ball_ref::set_nodeStatus <- set_nodeStatus,
										stm_go_to_behind_ball_ref::get_nodeStatus <- get_nodeStatus
									]]
								)
									[|{|terminate|}|]
								(
									(
										stm_approach_ball_ref::VS__(id__)[[
											stm_approach_ball_ref::terminate <- terminate,
											stm_approach_ball_ref::startApproachBall.in <- stm_carry_ball_on_ball_placement_ref::startApproachBall.out,
											stm_approach_ball_ref::startApproachBall.out <- stm_carry_ball_on_ball_placement_ref::startApproachBall.in,
											stm_approach_ball_ref::stopApproachBall.in <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.out,
											stm_approach_ball_ref::stopApproachBall.out <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.in,
											stm_approach_ball_ref::set_nodeStatus <- set_nodeStatus,
											stm_approach_ball_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
										[|{|terminate|}|]
									(
										(
											stm_carry_ball_ref::VS__(id__)[[
												stm_carry_ball_ref::terminate <- terminate,
												stm_carry_ball_ref::startCarryBall.in <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.out,
												stm_carry_ball_ref::startCarryBall.out <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.in,
												stm_carry_ball_ref::stopCarryBall.in <- stm_carry_ball_on_ball_placement_ref::startCarryBall.out,
												stm_carry_ball_ref::stopCarryBall.out <- stm_carry_ball_on_ball_placement_ref::startCarryBall.in,
												stm_carry_ball_ref::set_nodeStatus <- set_nodeStatus,
												stm_carry_ball_ref::get_nodeStatus <- get_nodeStatus
											]]
										)
											[|{|terminate|}|]
										(
											let
												const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE = 30
											within 
											stm_move_away_ref::VS__(id__,
													    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)[[
												stm_move_away_ref::terminate <- terminate,
												stm_move_away_ref::startMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.out,
												stm_move_away_ref::startMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.in,
												stm_move_away_ref::stopMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.out,
												stm_move_away_ref::stopMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.in,
												stm_move_away_ref::set_nodeStatus <- set_nodeStatus,
												stm_move_away_ref::get_nodeStatus <- get_nodeStatus
											]]
										)
									)
									\diff(
										{|terminate|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|},
						{|terminate|}
					)
						[|
							union(
								{|
									set_nodeStatus
								|},
								{|
									stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
									stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
									stm_approach_ball_ref::set_EXT_nodeStatus,
									stm_carry_ball_ref::set_EXT_nodeStatus,
									stm_move_away_ref::set_EXT_nodeStatus
								|}
							)
						|]
					Memory(id__, NODE_STATUS_RUNNING)
				)
				\ union(
					{|
						set_nodeStatus, get_nodeStatus
					|},
					{|
						stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
						stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
						stm_approach_ball_ref::set_EXT_nodeStatus,
						stm_carry_ball_ref::set_EXT_nodeStatus,
						stm_move_away_ref::set_EXT_nodeStatus
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>)
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__,
						    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = dbisim(prioritise(	((
						(
							stm_behavior_ref::O__(id__)[[
								stm_behavior_ref::terminate <- terminate,
								stm_behavior_ref::receiveField <- receiveField,
								stm_behavior_ref::receiveFrame <- receiveFrame,
								stm_behavior_ref::receiveTactic <- receiveTactic,
								stm_behavior_ref::sendAction <- sendAction
							]]
							\ {|
								stm_behavior_ref::sendSkill,
								stm_behavior_ref::startHalt,
								stm_behavior_ref::stopHalt
							|}
						)
							[|{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|}|]
						(
							(
								stm_carry_ball_on_ball_placement_ref::O__(id__)[[
									stm_carry_ball_on_ball_placement_ref::terminate <- terminate,
									stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.in <- stm_behavior_ref::startCarryBallOnBallPlacement.out,
									stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.out <- stm_behavior_ref::startCarryBallOnBallPlacement.in,
									stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.in <- stm_behavior_ref::stopCarryBallOnBallPlacement.out,
									stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.out <- stm_behavior_ref::stopCarryBallOnBallPlacement.in,
									stm_carry_ball_on_ball_placement_ref::set_nodeStatus <- set_nodeStatus,
									stm_carry_ball_on_ball_placement_ref::get_nodeStatus <- get_nodeStatus
								]]
							)
								[|{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|}|]
							(
								(
									stm_go_to_behind_ball_ref::O__(id__)[[
										stm_go_to_behind_ball_ref::terminate <- terminate,
										stm_go_to_behind_ball_ref::startGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.out,
										stm_go_to_behind_ball_ref::startGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.in,
										stm_go_to_behind_ball_ref::stopGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.out,
										stm_go_to_behind_ball_ref::stopGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.in,
										stm_go_to_behind_ball_ref::set_nodeStatus <- set_nodeStatus,
										stm_go_to_behind_ball_ref::get_nodeStatus <- get_nodeStatus
									]]
								)
									[|{|terminate|}|]
								(
									(
										stm_approach_ball_ref::O__(id__)[[
											stm_approach_ball_ref::terminate <- terminate,
											stm_approach_ball_ref::startApproachBall.in <- stm_carry_ball_on_ball_placement_ref::startApproachBall.out,
											stm_approach_ball_ref::startApproachBall.out <- stm_carry_ball_on_ball_placement_ref::startApproachBall.in,
											stm_approach_ball_ref::stopApproachBall.in <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.out,
											stm_approach_ball_ref::stopApproachBall.out <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.in,
											stm_approach_ball_ref::set_nodeStatus <- set_nodeStatus,
											stm_approach_ball_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
										[|{|terminate|}|]
									(
										(
											stm_carry_ball_ref::O__(id__)[[
												stm_carry_ball_ref::terminate <- terminate,
												stm_carry_ball_ref::startCarryBall.in <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.out,
												stm_carry_ball_ref::startCarryBall.out <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.in,
												stm_carry_ball_ref::stopCarryBall.in <- stm_carry_ball_on_ball_placement_ref::startCarryBall.out,
												stm_carry_ball_ref::stopCarryBall.out <- stm_carry_ball_on_ball_placement_ref::startCarryBall.in,
												stm_carry_ball_ref::set_nodeStatus <- set_nodeStatus,
												stm_carry_ball_ref::get_nodeStatus <- get_nodeStatus
											]]
										)
											[|{|terminate|}|]
										(
											let
												const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE = 30
											within 
											stm_move_away_ref::O__(id__,
													    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)[[
												stm_move_away_ref::terminate <- terminate,
												stm_move_away_ref::startMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.out,
												stm_move_away_ref::startMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.in,
												stm_move_away_ref::stopMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.out,
												stm_move_away_ref::stopMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.in,
												stm_move_away_ref::set_nodeStatus <- set_nodeStatus,
												stm_move_away_ref::get_nodeStatus <- get_nodeStatus
											]]
										)
									)
									\diff(
										{|terminate|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|},
						{|terminate|}
					)
						[|
							union(
								{|
									set_nodeStatus
								|},
								{|
									stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
									stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
									stm_approach_ball_ref::set_EXT_nodeStatus,
									stm_carry_ball_ref::set_EXT_nodeStatus,
									stm_move_away_ref::set_EXT_nodeStatus
								|}
							)
						|]
					dbisim(Memory(id__, NODE_STATUS_RUNNING))
				)
				\ union(
					{|
						set_nodeStatus, get_nodeStatus
					|},
					{|
						stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
						stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
						stm_approach_ball_ref::set_EXT_nodeStatus,
						stm_carry_ball_ref::set_EXT_nodeStatus,
						stm_move_away_ref::set_EXT_nodeStatus
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>))
								
				-- VS_O version
				VS_O__(id__,
						    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = dbisim(prioritise(	((
						(
							stm_behavior_ref::VS_O__(id__)[[
								stm_behavior_ref::terminate <- terminate,
								stm_behavior_ref::receiveField <- receiveField,
								stm_behavior_ref::receiveFrame <- receiveFrame,
								stm_behavior_ref::receiveTactic <- receiveTactic,
								stm_behavior_ref::sendAction <- sendAction
							]]
							\ {|
								stm_behavior_ref::sendSkill,
								stm_behavior_ref::startHalt,
								stm_behavior_ref::stopHalt
							|}
						)
							[|{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|}|]
						(
							(
								stm_carry_ball_on_ball_placement_ref::VS_O__(id__)[[
									stm_carry_ball_on_ball_placement_ref::terminate <- terminate,
									stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.in <- stm_behavior_ref::startCarryBallOnBallPlacement.out,
									stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.out <- stm_behavior_ref::startCarryBallOnBallPlacement.in,
									stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.in <- stm_behavior_ref::stopCarryBallOnBallPlacement.out,
									stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.out <- stm_behavior_ref::stopCarryBallOnBallPlacement.in,
									stm_carry_ball_on_ball_placement_ref::set_nodeStatus <- set_nodeStatus,
									stm_carry_ball_on_ball_placement_ref::get_nodeStatus <- get_nodeStatus
								]]
							)
								[|{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|}|]
							(
								(
									stm_go_to_behind_ball_ref::VS_O__(id__)[[
										stm_go_to_behind_ball_ref::terminate <- terminate,
										stm_go_to_behind_ball_ref::startGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.out,
										stm_go_to_behind_ball_ref::startGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.in,
										stm_go_to_behind_ball_ref::stopGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.out,
										stm_go_to_behind_ball_ref::stopGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.in,
										stm_go_to_behind_ball_ref::set_nodeStatus <- set_nodeStatus,
										stm_go_to_behind_ball_ref::get_nodeStatus <- get_nodeStatus
									]]
								)
									[|{|terminate|}|]
								(
									(
										stm_approach_ball_ref::VS_O__(id__)[[
											stm_approach_ball_ref::terminate <- terminate,
											stm_approach_ball_ref::startApproachBall.in <- stm_carry_ball_on_ball_placement_ref::startApproachBall.out,
											stm_approach_ball_ref::startApproachBall.out <- stm_carry_ball_on_ball_placement_ref::startApproachBall.in,
											stm_approach_ball_ref::stopApproachBall.in <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.out,
											stm_approach_ball_ref::stopApproachBall.out <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.in,
											stm_approach_ball_ref::set_nodeStatus <- set_nodeStatus,
											stm_approach_ball_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
										[|{|terminate|}|]
									(
										(
											stm_carry_ball_ref::VS_O__(id__)[[
												stm_carry_ball_ref::terminate <- terminate,
												stm_carry_ball_ref::startCarryBall.in <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.out,
												stm_carry_ball_ref::startCarryBall.out <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.in,
												stm_carry_ball_ref::stopCarryBall.in <- stm_carry_ball_on_ball_placement_ref::startCarryBall.out,
												stm_carry_ball_ref::stopCarryBall.out <- stm_carry_ball_on_ball_placement_ref::startCarryBall.in,
												stm_carry_ball_ref::set_nodeStatus <- set_nodeStatus,
												stm_carry_ball_ref::get_nodeStatus <- get_nodeStatus
											]]
										)
											[|{|terminate|}|]
										(
											let
												const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE = 30
											within 
											stm_move_away_ref::VS_O__(id__,
													    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)[[
												stm_move_away_ref::terminate <- terminate,
												stm_move_away_ref::startMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.out,
												stm_move_away_ref::startMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.in,
												stm_move_away_ref::stopMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.out,
												stm_move_away_ref::stopMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.in,
												stm_move_away_ref::set_nodeStatus <- set_nodeStatus,
												stm_move_away_ref::get_nodeStatus <- get_nodeStatus
											]]
										)
									)
									\diff(
										{|terminate|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|},
						{|terminate|}
					)
						[|
							union(
								{|
									set_nodeStatus
								|},
								{|
									stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
									stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
									stm_approach_ball_ref::set_EXT_nodeStatus,
									stm_carry_ball_ref::set_EXT_nodeStatus,
									stm_move_away_ref::set_EXT_nodeStatus
								|}
							)
						|]
					dbisim(Memory(id__, NODE_STATUS_RUNNING))
				)
				\ union(
					{|
						set_nodeStatus, get_nodeStatus
					|},
					{|
						stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
						stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
						stm_approach_ball_ref::set_EXT_nodeStatus,
						stm_carry_ball_ref::set_EXT_nodeStatus,
						stm_move_away_ref::set_EXT_nodeStatus
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>))
			
				HEXT(id__,
						    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = O__(id__,
						    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) [|shared_variable_events|] SKIP			
		}

	endmodule
