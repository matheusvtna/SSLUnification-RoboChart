
--
-- RoboChart generator version 3.0.0.202206212138
-- Automatically generated on 19-06-2023 14:57:58
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module carryBallOnBallPlacement
exports


	module BehaviorController
		shared_variable_events = {|
		|}
		
	exports
		transparent diamond
		transparent sbisim
		transparent dbisim
		transparent chase

		-- declaring controller events
		channel receiveFrame: InOut.core_string
		channel receiveField: InOut.core_string
		channel receiveTactic: InOut.core_string
		channel sendAction: InOut.core_string
		
		
		
		-- declaring call and ret events for undefined operations
		
		-- declaring controller termination channel
		channel terminate
		
		-- channel set with all visible events
		sem__events = {|
			terminate
		,	receiveFrame,
			receiveField,
			receiveTactic,
			sendAction
		|}
		
		-- set of visible memory events
		visibleMemoryEvents = {||}

		-- defined operations
		-- compileOperationDef
		module OP_carryBall
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
			
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sCarryBall|
			              NID_sFinal
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyHasBall, set_allyHasBall, setL_allyHasBall, setR_allyHasBall: core_boolean
			channel get_ballIsPositioned, set_ballIsPositioned, setL_ballIsPositioned, setR_ballIsPositioned: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sCarryBall::enter,
			sFinal::enter
			|}
			
			enteredSS = 	{|
			sCarryBall::entered,
			sFinal::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
				, share__
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sCarryBall : core_clock_type 
			channel get_CLID_sFinal : core_clock_type 
			--channel increment__
			
			CLID_sCarryBall_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sFinal_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sCarryBall
				module sCarryBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__) \ {terminate}
				
				STM_VS_O(id__) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__) \ {terminate}
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = share__choice(get_allyHasBall?allyHasBall -> get_ballIsPositioned?ballIsPositioned -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sCarryBall::enter -> SKIP))))
						 [] dbisim((ballIsPositioned)&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim(((((not (ballIsPositioned))) and allyHasBall))&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sCarryBall::enter -> SKIP)))
						 [] dbisim(((not (allyHasBall)))&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sCarryBall::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__)
								   [| { share__, terminate } |] (
								   sCarryBall::D__(id__)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__)
								   )
								   )
								 )
								 [[sCarryBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_allyHasBall <- setL_allyHasBall,set_ballIsPositioned <- setL_ballIsPositioned]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_allyHasBall
								 			,setL_ballIsPositioned
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_allyHasBall,setL_ballIsPositioned |} ]]
								 )
								)[[setL_allyHasBall <- set_allyHasBall,setL_ballIsPositioned <- set_ballIsPositioned]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sCarryBall,sCarryBall::entered|}
					 within
						(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
					)
					)
				
				
				Stateful(id__) = 
					((let
						getsetLocalChannels = {|get_allyHasBall,set_allyHasBall,
						get_ballIsPositioned,set_ballIsPositioned|}
						clockSync = {||}
					within
						(Behaviour(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sCarryBall::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sCarryBall::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__)
								   )
								   )
								 )
								 [[sCarryBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_allyHasBall <- setL_allyHasBall,set_ballIsPositioned <- setL_ballIsPositioned]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_allyHasBall
								 			,setL_ballIsPositioned
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_allyHasBall,setL_ballIsPositioned |} ]]
								 )
								)[[setL_allyHasBall <- set_allyHasBall,setL_ballIsPositioned <- set_ballIsPositioned]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sCarryBall,sCarryBall::entered|}
					 within
						(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				
				Stateful_VS_O(id__) = 
					dbisim((let
						getsetLocalChannels = {|get_allyHasBall,set_allyHasBall,
						get_ballIsPositioned,set_ballIsPositioned|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_allyHasBall(allyHasBall) =
					get_allyHasBall!allyHasBall -> Memory_allyHasBall(allyHasBall)
					[]
					set_allyHasBall?x__ -> Memory_allyHasBall(x__)
					[]
					terminate -> SKIP
				Memory_ballIsPositioned(ballIsPositioned) =
					get_ballIsPositioned!ballIsPositioned -> Memory_ballIsPositioned(ballIsPositioned)
					[]
					set_ballIsPositioned?x__ -> Memory_ballIsPositioned(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_allyHasBall(true)
				[| { terminate } |] (
				Memory_ballIsPositioned(true)
				)
				
				getsetLocalChannels = {|get_allyHasBall,set_allyHasBall,get_ballIsPositioned,set_ballIsPositioned|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__) \ localClockResets
				D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
				O__(id__) = dbisim(D__(id__))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = dbisim(FVS__(id__))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
				HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sCarryBall(id__,x__) = 
					TimeOut_1(
						sCarryBall::entered -> Clock_CLID_sCarryBall(id__,0)
						[]
						get_CLID_sCarryBall!x__ -> Clock_CLID_sCarryBall(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sCarryBall(id__,clock_type_plus(x__,1,CLID_sCarryBall_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sCarryBall(id__,0))
				
				stateClockSync = {|get_CLID_sCarryBall,sCarryBall::entered|}
				}
					endmodule
		-- compileOperationDef
		module OP_approachBall
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
			
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sApproach|
			              NID_sFinal
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyIsBehindBall, set_allyIsBehindBall, setL_allyIsBehindBall, setR_allyIsBehindBall: core_boolean
			channel get_allyIsCloseToBall, set_allyIsCloseToBall, setL_allyIsCloseToBall, setR_allyIsCloseToBall: core_boolean
			channel get_allyHasBall, set_allyHasBall, setL_allyHasBall, setR_allyHasBall: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sApproach::enter,
			sFinal::enter
			|}
			
			enteredSS = 	{|
			sApproach::entered,
			sFinal::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
				, share__
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sApproach : core_clock_type 
			channel get_CLID_sFinal : core_clock_type 
			--channel increment__
			
			CLID_sApproach_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sFinal_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sApproach
				module sApproach
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__) \ {terminate}
				
				STM_VS_O(id__) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__) \ {terminate}
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = share__choice(get_allyIsCloseToBall?allyIsCloseToBall -> get_allyHasBall?allyHasBall -> get_allyIsBehindBall?allyIsBehindBall -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sApproach::enter -> SKIP))))
						 [] dbisim((allyHasBall)&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim(((((not (allyHasBall))) and (not ((((not (allyIsBehindBall)) or (not (allyIsCloseToBall))))))))&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sApproach::enter -> SKIP)))
						 [] dbisim(((((not (allyIsBehindBall)) or (not (allyIsCloseToBall)))))&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sApproach::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__)
								   [| { share__, terminate } |] (
								   sApproach::D__(id__)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__)
								   )
								   )
								 )
								 [[sApproach::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_allyIsCloseToBall
								 			,setL_allyHasBall
								 			,setL_allyIsBehindBall
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_allyHasBall,setL_allyIsBehindBall |} ]]
								 )
								)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sApproach,sApproach::entered|}
					 within
						(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
					)
					)
				
				
				Stateful(id__) = 
					((let
						getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,
						get_allyIsCloseToBall,set_allyIsCloseToBall,
						get_allyHasBall,set_allyHasBall|}
						clockSync = {||}
					within
						(Behaviour(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sApproach::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sApproach::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__)
								   )
								   )
								 )
								 [[sApproach::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_allyIsCloseToBall
								 			,setL_allyHasBall
								 			,setL_allyIsBehindBall
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_allyHasBall,setL_allyIsBehindBall |} ]]
								 )
								)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sApproach,sApproach::entered|}
					 within
						(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				
				Stateful_VS_O(id__) = 
					dbisim((let
						getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,
						get_allyIsCloseToBall,set_allyIsCloseToBall,
						get_allyHasBall,set_allyHasBall|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_allyIsBehindBall(allyIsBehindBall) =
					get_allyIsBehindBall!allyIsBehindBall -> Memory_allyIsBehindBall(allyIsBehindBall)
					[]
					set_allyIsBehindBall?x__ -> Memory_allyIsBehindBall(x__)
					[]
					terminate -> SKIP
				Memory_allyIsCloseToBall(allyIsCloseToBall) =
					get_allyIsCloseToBall!allyIsCloseToBall -> Memory_allyIsCloseToBall(allyIsCloseToBall)
					[]
					set_allyIsCloseToBall?x__ -> Memory_allyIsCloseToBall(x__)
					[]
					terminate -> SKIP
				Memory_allyHasBall(allyHasBall) =
					get_allyHasBall!allyHasBall -> Memory_allyHasBall(allyHasBall)
					[]
					set_allyHasBall?x__ -> Memory_allyHasBall(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_allyIsBehindBall(true)
				[| { terminate } |] (
				Memory_allyIsCloseToBall(true)
				[| { terminate } |] (
				Memory_allyHasBall(true)
				)
				)
				
				getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,get_allyIsCloseToBall,set_allyIsCloseToBall,get_allyHasBall,set_allyHasBall|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__) \ localClockResets
				D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
				O__(id__) = dbisim(D__(id__))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = dbisim(FVS__(id__))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
				HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sApproach(id__,x__) = 
					TimeOut_1(
						sApproach::entered -> Clock_CLID_sApproach(id__,0)
						[]
						get_CLID_sApproach!x__ -> Clock_CLID_sApproach(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sApproach(id__,clock_type_plus(x__,1,CLID_sApproach_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sApproach(id__,0))
				
				stateClockSync = {|get_CLID_sApproach,sApproach::entered|}
				}
					endmodule
		-- compileOperationDef
		module OP_goToBehindBall
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
			
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sGoToBehindBall|
			              NID_sFinal
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyIsBehindBall, set_allyIsBehindBall, setL_allyIsBehindBall, setR_allyIsBehindBall: core_boolean
			channel get_allyIsCloseToBall, set_allyIsCloseToBall, setL_allyIsCloseToBall, setR_allyIsCloseToBall: core_boolean
			channel get_allyIsPushingBallWithHisBack, set_allyIsPushingBallWithHisBack, setL_allyIsPushingBallWithHisBack, setR_allyIsPushingBallWithHisBack: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sGoToBehindBall::enter,
			sFinal::enter
			|}
			
			enteredSS = 	{|
			sGoToBehindBall::entered,
			sFinal::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
				, share__
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sFinal : core_clock_type 
			channel get_CLID_sGoToBehindBall : core_clock_type 
			--channel increment__
			
			CLID_sFinal_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sGoToBehindBall_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sGoToBehindBall
				module sGoToBehindBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__) = D__(id__)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__) \ {terminate}
				
				STM_VS_O(id__) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__) \ {terminate}
				
				-- Transitions
				Transitions(id__) = ((let
					Trans = share__choice(get_allyIsBehindBall?allyIsBehindBall -> get_allyIsPushingBallWithHisBack?allyIsPushingBallWithHisBack -> get_allyIsCloseToBall?allyIsCloseToBall -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sGoToBehindBall::enter -> SKIP))))
						 [] dbisim((((allyIsBehindBall and allyIsCloseToBall)))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim((((not (((allyIsBehindBall and allyIsCloseToBall)))) and (not (allyIsPushingBallWithHisBack))))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim((allyIsPushingBallWithHisBack)&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sGoToBehindBall::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__)
								   [| { share__, terminate } |] (
								   sGoToBehindBall::D__(id__)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__)
								   )
								   )
								 )
								 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack,set_allyIsCloseToBall <- setL_allyIsCloseToBall]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_allyIsBehindBall
								 			,setL_allyIsPushingBallWithHisBack
								 			,setL_allyIsCloseToBall
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsBehindBall,setL_allyIsPushingBallWithHisBack,setL_allyIsCloseToBall |} ]]
								 )
								)[[setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack,setL_allyIsCloseToBall <- set_allyIsCloseToBall]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered|}
					 within
						(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
					)
					)
				
				
				Stateful(id__) = 
					((let
						getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,
						get_allyIsCloseToBall,set_allyIsCloseToBall,
						get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
						clockSync = {||}
					within
						(Behaviour(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- Visible counterparts
				MachineBody_VS_O(id__) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sGoToBehindBall::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sGoToBehindBall::VS_O__(id__)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__)
								   )
								   )
								 )
								 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack,set_allyIsCloseToBall <- setL_allyIsCloseToBall]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_allyIsBehindBall
								 			,setL_allyIsPushingBallWithHisBack
								 			,setL_allyIsCloseToBall
								|}) |]
								 ((sInitial::enter -> Transitions(id__))
								  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsBehindBall,setL_allyIsPushingBallWithHisBack,setL_allyIsCloseToBall |} ]]
								 )
								)[[setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack,setL_allyIsCloseToBall <- set_allyIsCloseToBall]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__) = 
					dbisim((let
						stateClockSync = {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered|}
					 within
						(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				
				Stateful_VS_O(id__) = 
					dbisim((let
						getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,
						get_allyIsCloseToBall,set_allyIsCloseToBall,
						get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__) [| {terminate} |] Clocks(id__))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_allyIsBehindBall(allyIsBehindBall) =
					get_allyIsBehindBall!allyIsBehindBall -> Memory_allyIsBehindBall(allyIsBehindBall)
					[]
					set_allyIsBehindBall?x__ -> Memory_allyIsBehindBall(x__)
					[]
					terminate -> SKIP
				Memory_allyIsCloseToBall(allyIsCloseToBall) =
					get_allyIsCloseToBall!allyIsCloseToBall -> Memory_allyIsCloseToBall(allyIsCloseToBall)
					[]
					set_allyIsCloseToBall?x__ -> Memory_allyIsCloseToBall(x__)
					[]
					terminate -> SKIP
				Memory_allyIsPushingBallWithHisBack(allyIsPushingBallWithHisBack) =
					get_allyIsPushingBallWithHisBack!allyIsPushingBallWithHisBack -> Memory_allyIsPushingBallWithHisBack(allyIsPushingBallWithHisBack)
					[]
					set_allyIsPushingBallWithHisBack?x__ -> Memory_allyIsPushingBallWithHisBack(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__) = Memory_allyIsBehindBall(true)
				[| { terminate } |] (
				Memory_allyIsCloseToBall(true)
				[| { terminate } |] (
				Memory_allyIsPushingBallWithHisBack(true)
				)
				)
				
				getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,get_allyIsCloseToBall,set_allyIsCloseToBall,get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__) = STM_VS_O(id__) \ localClockResets
				D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
				O__(id__) = dbisim(D__(id__))
				VS__(id__) = FVS__(id__)
				VS_O__(id__) = dbisim(FVS__(id__))
				HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
				FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
				HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sGoToBehindBall(id__,x__) = 
					TimeOut_1(
						sGoToBehindBall::entered -> Clock_CLID_sGoToBehindBall(id__,0)
						[]
						get_CLID_sGoToBehindBall!x__ -> Clock_CLID_sGoToBehindBall(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sGoToBehindBall(id__,clock_type_plus(x__,1,CLID_sGoToBehindBall_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sGoToBehindBall(id__,0))
				
				stateClockSync = {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered|}
				}
					endmodule
		-- compileOperationDef
		module OP_moveAwayFromPosition
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
			
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sMoveAway|
			              NID_sFinal
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_robotIsFarEnoughFromPosition, set_robotIsFarEnoughFromPosition, setL_robotIsFarEnoughFromPosition, setR_robotIsFarEnoughFromPosition: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sMoveAway::enter,
			sFinal::enter
			|}
			
			enteredSS = 	{|
			sMoveAway::entered,
			sFinal::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
				, share__
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sFinal : core_clock_type 
			channel get_CLID_sMoveAway : core_clock_type 
			--channel increment__
			
			CLID_sFinal_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sMoveAway_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{},
			({const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE|TIME_LIMIT_TO_BEHAVE <- core_nat}),
			({const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE|TIME_LIMIT_TO_BEHAVE <- core_nat})
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sMoveAway
				module sMoveAway
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				-- END of Operation calls --
			
				-- STM processes
				STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ {terminate}
				
				STM_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ {terminate}
				
				-- Transitions
				Transitions(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = ((let
					Trans = share__choice(get_robotIsFarEnoughFromPosition?robotIsFarEnoughFromPosition -> get_CLID_sMoveAway?sMoveAway:CLID_sMoveAway_clock_type(id__,
							          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sMoveAway::enter -> SKIP))))
						 [] dbisim((robotIsFarEnoughFromPosition)&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim(((((not (robotIsFarEnoughFromPosition))) and ((not ((((sMoveAway>const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) and ((not (robotIsFarEnoughFromPosition))))))))))&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sMoveAway::enter -> SKIP)))
						 [] dbisim((((sMoveAway>const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) and ((not (robotIsFarEnoughFromPosition)))))&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sMoveAway::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sMoveAway::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   )
								   )
								 )
								 [[sMoveAway::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition,sMoveAway::entered <- sMoveAway::enteredL]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_robotIsFarEnoughFromPosition
								 			,sMoveAway::enteredL
								|}) |]
								 ((sInitial::enter -> Transitions(id__,
								 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
								  [[ share__ <- x__ | x__ <- {| share__,setL_robotIsFarEnoughFromPosition,sMoveAway::enteredL |} ]]
								 )
								)[[setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition,sMoveAway::enteredL <- sMoveAway::entered]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {|get_CLID_sMoveAway,sMoveAway::entered|}
					 within
						(MachineBody(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)) \ union(stateClockSync,enteredSS)
					)
					)
				
				
				Stateful(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					((let
						getsetLocalChannels = {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
						clockSync = {||}
					within
						(Behaviour(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__,
						 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| {terminate} |] Clocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sMoveAway::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sMoveAway::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   )
								   )
								 )
								 [[sMoveAway::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition,sMoveAway::entered <- sMoveAway::enteredL]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_robotIsFarEnoughFromPosition
								 			,sMoveAway::enteredL
								|}) |]
								 ((sInitial::enter -> Transitions(id__,
								 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
								  [[ share__ <- x__ | x__ <- {| share__,setL_robotIsFarEnoughFromPosition,sMoveAway::enteredL |} ]]
								 )
								)[[setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition,sMoveAway::enteredL <- sMoveAway::entered]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {|get_CLID_sMoveAway,sMoveAway::entered|}
					 within
						(MachineBody_VS_O(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				
				Stateful_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						getsetLocalChannels = {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__,
						 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| {terminate} |] Clocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_robotIsFarEnoughFromPosition(robotIsFarEnoughFromPosition) =
					get_robotIsFarEnoughFromPosition!robotIsFarEnoughFromPosition -> Memory_robotIsFarEnoughFromPosition(robotIsFarEnoughFromPosition)
					[]
					set_robotIsFarEnoughFromPosition?x__ -> Memory_robotIsFarEnoughFromPosition(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = Memory_robotIsFarEnoughFromPosition(true)
				
				getsetLocalChannels = {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = STM_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ localClockResets
				D__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = timed_priority(STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ union(internal_events,localClockResets))
				O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(D__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				VS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
				VS_O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				HEXT__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [|shared_variable_events|] SKIP
				FVS_C__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(timed_priority(STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ internal_events))
				HUP__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = timed_priority(O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sMoveAway(id__,x__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					TimeOut_1(
						sMoveAway::entered -> Clock_CLID_sMoveAway(id__,0,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						get_CLID_sMoveAway!x__ -> Clock_CLID_sMoveAway(id__,x__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						terminate -> SKIP,Clock_CLID_sMoveAway(id__,clock_type_plus(x__,1,CLID_sMoveAway_clock_type(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)),
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				
				StateClocks(id__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(Clock_CLID_sMoveAway(id__,0,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				
				stateClockSync = {|get_CLID_sMoveAway,sMoveAway::entered|}
				}
					endmodule
		-- compileOperationDef
		module OP_carryBallOnBallPlacement
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
			
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sGoToBehindBall|
			              NID_sGiveSpaceToGetBall|
			              NID_sApproachBall|
			              NID_sPlaceBall|
			              NID_sMoveAwayFromBall|
			              NID_sFinal
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_robotHasMovedAwayFromBall, set_robotHasMovedAwayFromBall, setL_robotHasMovedAwayFromBall, setR_robotHasMovedAwayFromBall: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			channel get_goToBehindBall_allyIsBehindBall, set_goToBehindBall_allyIsBehindBall: core_boolean
			channel get_goToBehindBall_allyIsCloseToBall, set_goToBehindBall_allyIsCloseToBall: core_boolean
			channel get_goToBehindBall_allyIsPushingBallWithHisBack, set_goToBehindBall_allyIsPushingBallWithHisBack: core_boolean
			channel get_moveAwayFromPosition_robotIsFarEnoughFromPosition, set_moveAwayFromPosition_robotIsFarEnoughFromPosition: core_boolean
			channel get_carryBall_allyHasBall, set_carryBall_allyHasBall: core_boolean
			channel get_carryBall_ballIsPositioned, set_carryBall_ballIsPositioned: core_boolean
			channel get_approachBall_allyIsBehindBall, set_approachBall_allyIsBehindBall: core_boolean
			channel get_approachBall_allyIsCloseToBall, set_approachBall_allyIsCloseToBall: core_boolean
			channel get_approachBall_allyHasBall, set_approachBall_allyHasBall: core_boolean
			
			-- Declaring state machine events
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sGoToBehindBall::enter,
			sGiveSpaceToGetBall::enter,
			sApproachBall::enter,
			sPlaceBall::enter,
			sMoveAwayFromBall::enter,
			sFinal::enter
			|}
			
			enteredSS = 	{|
			sGoToBehindBall::entered,
			sGiveSpaceToGetBall::entered,
			sApproachBall::entered,
			sPlaceBall::entered,
			sMoveAwayFromBall::entered,
			sFinal::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
				, share__
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_sGiveSpaceToGetBall : core_clock_type 
			channel get_CLID_sFinal : core_clock_type 
			channel get_CLID_sPlaceBall : core_clock_type 
			channel get_CLID_sGoToBehindBall : core_clock_type 
			channel get_CLID_sApproachBall : core_clock_type 
			channel get_CLID_sMoveAwayFromBall : core_clock_type 
			--channel increment__
			
			CLID_sGiveSpaceToGetBall_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sFinal_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sPlaceBall_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sGoToBehindBall_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sApproachBall_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sMoveAwayFromBall_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
			
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sGoToBehindBall
				module sGoToBehindBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__goToBehindBall(
										id__,
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__goToBehindBall(
										id__,
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sGiveSpaceToGetBall
				module sGiveSpaceToGetBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__moveAwayFromPosition(
										id__, 
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__moveAwayFromPosition(
										id__, 
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sApproachBall
				module sApproachBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__approachBall(
										id__,
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__approachBall(
										id__,
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sPlaceBall
				module sPlaceBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__carryBall(
										id__,
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__carryBall(
										id__,
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sMoveAwayFromBall
				module sMoveAwayFromBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--channel increment__
					
					
					--	Nodes
					-- declaring all nodes
					
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						--  Note that FDR has problems with efficiently compiling the process below
						-- 	if using a different recursion pattern.
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							-- IMPLEMENTATION NOTE: 
							-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
							-- however FDR struggles with that form in certain cases. So we use the exception operator
							-- instead to 'terminate'.
							
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__moveAwayFromPosition(
										id__, 
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__moveAwayFromPosition(
										id__, 
										const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
									) ; 
									 	  Behaviour ; 
									 	  share__choice(exit -> SKIP) ; SKIP ; 
									 	  share__choice(exited -> SKIP) ; Inactive
						
							Behaviour 	= entered -> During
							During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
						within
							Inactive [| {terminate} |> SKIP)
						
						
						-- Clocks
						
						StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
						
						stateClockSync = {||}
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				CALL__goToBehindBall(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_goToBehindBall::O__(id__))
				[[
					OP_goToBehindBall::get_nodeStatus <- get_nodeStatus,
					OP_goToBehindBall::set_nodeStatus <- set_nodeStatus
				]]
				CALL__moveAwayFromPosition(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_moveAwayFromPosition::O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				[[
					OP_moveAwayFromPosition::get_nodeStatus <- get_nodeStatus,
					OP_moveAwayFromPosition::set_nodeStatus <- set_nodeStatus
				]]
				CALL__carryBall(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_carryBall::O__(id__))
				[[
					OP_carryBall::get_nodeStatus <- get_nodeStatus,
					OP_carryBall::set_nodeStatus <- set_nodeStatus
				]]
				CALL__approachBall(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_approachBall::O__(id__))
				[[
					OP_approachBall::get_nodeStatus <- get_nodeStatus,
					OP_approachBall::set_nodeStatus <- set_nodeStatus
				]]
				-- END of Operation calls --
			
				-- STM processes
				STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ {terminate}
				
				STM_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
				Stateful(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ {terminate}
				
				-- Transitions
				Transitions(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = ((let
					Trans = share__choice(get_nodeStatus?nodeStatus -> get_robotHasMovedAwayFromBall?robotHasMovedAwayFromBall -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sGoToBehindBall::enter -> SKIP))))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sApproachBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sPlaceBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sMoveAwayFromBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sFinal::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGiveSpaceToGetBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sFinal::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sFinal::enter -> SKIP)))
						 [] dbisim((robotHasMovedAwayFromBall)&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sApproachBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sPlaceBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sMoveAwayFromBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGiveSpaceToGetBall::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sGoToBehindBall::enter,
							sGiveSpaceToGetBall::enter,
							sApproachBall::enter,
							sPlaceBall::enter,
							sMoveAwayFromBall::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sGoToBehindBall::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sGiveSpaceToGetBall::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sApproachBall::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sPlaceBall::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sMoveAwayFromBall::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sFinal::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   )
								   )
								   )
								   )
								   )
								   )
								 )
								 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
								 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
								 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
								 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
								 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_nodeStatus
								 			,setL_robotHasMovedAwayFromBall
								|}) |]
								 ((sInitial::enter -> Transitions(id__,
								 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
					 within
						(MachineBody(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)) \ union(stateClockSync,enteredSS)
					)
					)
				
				
				Stateful(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					((let
						getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
						clockSync = {||}
					within
						(Behaviour(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__,
						 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| {terminate} |] Clocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((
					let
						finalNodesEntered = {|sFinal::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							sInitial::enter,
							sGoToBehindBall::enter,
							sGiveSpaceToGetBall::enter,
							sApproachBall::enter,
							sPlaceBall::enter,
							sMoveAwayFromBall::enter,
							sFinal::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   sInitial::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sGoToBehindBall::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sGiveSpaceToGetBall::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sApproachBall::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sPlaceBall::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sMoveAwayFromBall::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   sFinal::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   )
								   )
								   )
								   )
								   )
								   )
								 )
								 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
								 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
								 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
								 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
								 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
								 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								 			,setL_nodeStatus
								 			,setL_robotHasMovedAwayFromBall
								|}) |]
								 ((sInitial::enter -> Transitions(id__,
								 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
								  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
								 )
								)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
					 within
						(MachineBody_VS_O(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				
				Stateful_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__,
						 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| {terminate} |] Clocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall) =
					get_robotHasMovedAwayFromBall!robotHasMovedAwayFromBall -> Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall)
					[]
					set_robotHasMovedAwayFromBall?x__ -> Memory_robotHasMovedAwayFromBall(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = Memory_robotHasMovedAwayFromBall(true)
				
				getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = STM_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ localClockResets
				D__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = timed_priority(STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ union(internal_events,localClockResets))
				O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(D__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				VS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
				VS_O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				HEXT__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [|shared_variable_events|] SKIP
				FVS_C__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(timed_priority(STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ internal_events))
				HUP__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = timed_priority(O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
				
				clockSync = {||}
				
				Clock_CLID_sGiveSpaceToGetBall(id__,x__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					TimeOut_1(
						sGiveSpaceToGetBall::entered -> Clock_CLID_sGiveSpaceToGetBall(id__,0,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						get_CLID_sGiveSpaceToGetBall!x__ -> Clock_CLID_sGiveSpaceToGetBall(id__,x__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						terminate -> SKIP,Clock_CLID_sGiveSpaceToGetBall(id__,clock_type_plus(x__,1,CLID_sGiveSpaceToGetBall_clock_type(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)),
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				Clock_CLID_sPlaceBall(id__,x__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					TimeOut_1(
						sPlaceBall::entered -> Clock_CLID_sPlaceBall(id__,0,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						get_CLID_sPlaceBall!x__ -> Clock_CLID_sPlaceBall(id__,x__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						terminate -> SKIP,Clock_CLID_sPlaceBall(id__,clock_type_plus(x__,1,CLID_sPlaceBall_clock_type(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)),
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				Clock_CLID_sGoToBehindBall(id__,x__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					TimeOut_1(
						sGoToBehindBall::entered -> Clock_CLID_sGoToBehindBall(id__,0,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						get_CLID_sGoToBehindBall!x__ -> Clock_CLID_sGoToBehindBall(id__,x__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						terminate -> SKIP,Clock_CLID_sGoToBehindBall(id__,clock_type_plus(x__,1,CLID_sGoToBehindBall_clock_type(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)),
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				Clock_CLID_sApproachBall(id__,x__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					TimeOut_1(
						sApproachBall::entered -> Clock_CLID_sApproachBall(id__,0,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						get_CLID_sApproachBall!x__ -> Clock_CLID_sApproachBall(id__,x__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						terminate -> SKIP,Clock_CLID_sApproachBall(id__,clock_type_plus(x__,1,CLID_sApproachBall_clock_type(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)),
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				Clock_CLID_sMoveAwayFromBall(id__,x__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					TimeOut_1(
						sMoveAwayFromBall::entered -> Clock_CLID_sMoveAwayFromBall(id__,0,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						get_CLID_sMoveAwayFromBall!x__ -> Clock_CLID_sMoveAwayFromBall(id__,x__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						[]
						terminate -> SKIP,Clock_CLID_sMoveAwayFromBall(id__,clock_type_plus(x__,1,CLID_sMoveAwayFromBall_clock_type(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)),
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				
				StateClocks(id__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				[| { terminate } |] (
				dbisim(Clock_CLID_sPlaceBall(id__,0,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				[| { terminate } |] (
				dbisim(Clock_CLID_sGoToBehindBall(id__,0,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				[| { terminate } |] (
				dbisim(Clock_CLID_sApproachBall(id__,0,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				[| { terminate } |] (
				dbisim(Clock_CLID_sMoveAwayFromBall(id__,0,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				)
				)
				)
				)
				
				stateClockSync = {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
				}
					endmodule
	
		-- declaring machines
		module stm_ref0
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_i0|
			              NID_f0
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			
			-- Local variable channels for defined operations that are required by the state machine
			channel get_goToBehindBall_allyIsBehindBall, set_goToBehindBall_allyIsBehindBall: core_boolean
			channel get_goToBehindBall_allyIsCloseToBall, set_goToBehindBall_allyIsCloseToBall: core_boolean
			channel get_goToBehindBall_allyIsPushingBallWithHisBack, set_goToBehindBall_allyIsPushingBallWithHisBack: core_boolean
			channel get_carryBallOnBallPlacement_robotHasMovedAwayFromBall, set_carryBallOnBallPlacement_robotHasMovedAwayFromBall: core_boolean
			channel get_moveAwayFromPosition_robotIsFarEnoughFromPosition, set_moveAwayFromPosition_robotIsFarEnoughFromPosition: core_boolean
			channel get_carryBall_allyHasBall, set_carryBall_allyHasBall: core_boolean
			channel get_carryBall_ballIsPositioned, set_carryBall_ballIsPositioned: core_boolean
			channel get_approachBall_allyIsBehindBall, set_approachBall_allyIsBehindBall: core_boolean
			channel get_approachBall_allyIsCloseToBall, set_approachBall_allyIsCloseToBall: core_boolean
			channel get_approachBall_allyHasBall, set_approachBall_allyHasBall: core_boolean
			
			-- Declaring state machine events
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			i0::enter,
			f0::enter
			|}
			
			enteredSS = 	{|
			f0::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
				|}
			
			channel clockReset, clockResetL, clockResetR 
			
			localClockResets = {||}
			
			
			channel get_CLID_f0 : core_clock_type 
			--channel increment__
			
			CLID_f0_clock_type(id__,
					          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
				let
					max = (clock_type_max(Union({
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
		
				-- Nodes --
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: i0
				module i0
				exports
				
					channel enter, interrupt
					
					Timed(OneStep) {
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(interrupt -> SKIP) ; Inactive
							within
								Inactive [| {terminate} |> SKIP)
						
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: f0
				module f0
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					Timed(OneStep) {
						--	Rule: behaviours(Node)
						D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
								
								Entering 	= entered -> SKIP ; Active
								Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
								Interrupted	= share__choice(exit -> exited -> Inactive)
							within
								Inactive [| {terminate} |> SKIP)
							
						VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
					}
				
				endmodule
				----------------------------------------------------------------------
				
				-- END of Nodes --
				
				Timed(OneStep) {
				-- Operation calls --
				-- Only the undefined operations are declared here.
				-- If the state machine is in isolation, all required operations will be undefined.
				-- If it is in the context of a controller, the required operations not provided by the
				-- controller will be declared here, and the defined operations will be defined in the
				-- context of the Controller module, and therefore within scope of the state machine module.
				
				CALL__goToBehindBall(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_goToBehindBall::O__(id__))
				[[
					OP_goToBehindBall::get_nodeStatus <- get_nodeStatus,
					OP_goToBehindBall::set_nodeStatus <- set_nodeStatus
				]]
				CALL__carryBallOnBallPlacement(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_carryBallOnBallPlacement::O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				[[
					OP_carryBallOnBallPlacement::get_nodeStatus <- get_nodeStatus,
					OP_carryBallOnBallPlacement::set_nodeStatus <- set_nodeStatus
				]]
				CALL__moveAwayFromPosition(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_moveAwayFromPosition::O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				[[
					OP_moveAwayFromPosition::get_nodeStatus <- get_nodeStatus,
					OP_moveAwayFromPosition::set_nodeStatus <- set_nodeStatus
				]]
				CALL__carryBall(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_carryBall::O__(id__))
				[[
					OP_carryBall::get_nodeStatus <- get_nodeStatus,
					OP_carryBall::set_nodeStatus <- set_nodeStatus
				]]
				CALL__approachBall(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = (OP_approachBall::O__(id__))
				[[
					OP_approachBall::get_nodeStatus <- get_nodeStatus,
					OP_approachBall::set_nodeStatus <- set_nodeStatus
				]]
				-- END of Operation calls --
			
				-- STM processes
				STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful(id__,
									    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				STM_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
				( 
					(
						(
							(IteratedStateful_VS_O(id__,
									    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ {terminate} ; share__choice(terminate -> SKIP))
						 	[[ share__ <- x__ | x__ <- {||} ]]
						)
					[| {share__} |]
					SKIP
					)
					[| union(sharedVarSync,{terminate}) |]
					dbisim(sharedVarMemory(id__,
							    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				)\sharedVarHide
				,<{terminate},{tock}>)
				
				-- Transitions
				Transitions(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = ((let
					Trans = TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((true&CALL__carryBallOnBallPlacement(
						 			id__,
						 			const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE
						 		) ; f0::enter -> SKIP))))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				-- Stateful
				-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
				
				-- Named process definitions
				MachineBody(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((
					let
						finalNodesEntered = {|f0::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							f0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   f0::D__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   )
								 )
								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {||}
					 within
						(MachineBody(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)) \ union(stateClockSync,enteredSS)
					)
					)
				
				IteratedBehaviour(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {||}
					 within
						(MachineBody(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)) \ union(stateClockSync,enteredSS)
					)
					)
				
				Stateful(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					((let
						getsetLocalChannels = {|get_nodeStatus,set_nodeStatus|}
						clockSync = {||}
					within
						(Behaviour(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__,
						 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| {terminate} |] Clocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) =
					(dbisim(
						sbisim(
							IteratedBehaviour(id__,
									    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
							[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
							Memory_nodeStatus(NODE_STATUS_RUNNING)
						)\{|get_nodeStatus,set_nodeStatus|}
					)
					)
				
				-- Visible counterparts
				MachineBody_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((
					let
						finalNodesEntered = {|f0::entered|}
					within
						(dbisim((dbisim((let
							-- IMPLEMENTATION NOTE:
							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
							-- modules for defining the semantics of each node.
							enterSS = {|
							i0::enter,
							f0::enter
							|}
							hideSet = union(enterSS,{|exit,exited,internal__|})
						within 
							((let
								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
								-- because CSPM modules are used for the semantics of Node.
								flowevts = union(enterSS,{|exit,exited,interrupt|})
								transSync = {|internal__.NID_i0|}
							within
								((
								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
								   i0::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   [| { share__, terminate } |] (
								   f0::VS_O__(id__,
								   		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
								   )
								 )
								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
								 )
								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
								 )
								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
								|}) |]
								 ((i0::enter -> Transitions(id__,
								 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
								  [[ share__ <- x__ | x__ <- {| share__ |} ]]
								 )
								)
								)
							)
							 \ hideSet)
						)
						)
						 [| union(stateClockSync,{terminate}) |]
						 StateClocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
						)\diff(stateClockSync,enteredSS))
						 [| {| interrupt |} |] SKIP)
					)
					)
				
				Behaviour_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {||}
					 within
						(MachineBody_VS_O(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
								          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				IteratedBehaviour_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						stateClockSync = {||}
					 within
						(MachineBody_VS_O(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)) \ diff(union(stateClockSync,enteredSS),enteredSS)
					)
					)
				
				Stateful_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = 
					dbisim((let
						getsetLocalChannels = {|get_nodeStatus,set_nodeStatus|}
						clockSync = {||}
					within
						(Behaviour_VS_O(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) 
						 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
						 (varMemory(id__,
						 		    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [| {terminate} |] Clocks(id__,
						 		          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
					 	)\union(getsetLocalChannels,clockSync)
					)
					)
				
				IteratedStateful_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) =
					(dbisim(
						sbisim(
							IteratedBehaviour_VS_O(id__,
									    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
							[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
							Memory_nodeStatus(NODE_STATUS_RUNNING)
						)\{|get_nodeStatus,set_nodeStatus|}
					)
					)
				
				-- END
				
				-- Memory
				-- Memory variables
				Memory_nodeStatus(nodeStatus) =
					get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
					[]
					set_nodeStatus?x__ -> Memory_nodeStatus(x__)
					[]
					terminate -> SKIP
				
				-- varMemory process
				varMemory(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = Memory_nodeStatus(NODE_STATUS_RUNNING)
				
				getsetLocalChannels = {|get_nodeStatus,set_nodeStatus|}
				
				-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
				FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = STM_VS_O(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ localClockResets
				D__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = timed_priority(STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ union(internal_events,localClockResets))
				O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(D__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				VS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)
				VS_O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(FVS__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE))
				HEXT__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [|shared_variable_events|] SKIP
				FVS_C__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = dbisim(timed_priority(STM(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) \ internal_events))
				HUP__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = timed_priority(O__(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) [|{share__}|] SKIP)
				
				-- Clocks
				
				Clocks(id__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
				
				clockSync = {||}
				
				
				StateClocks(id__,
						          const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
				
				stateClockSync = {||}
				
				-- Shared memory
				-- Shared memory variables
				
				-- sharedVarMemory process
				sharedVarMemory(id__,
						    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE) = terminate -> SKIP
				
				sharedVarSync = {||}
				
				sharedVarHide = {||}
				}
		endmodule
		
		Timed(OneStep) {
				-- undefined operations
				
				-- declaring controller memory
				Memory(id__) = SKIP
				
				D__(id__,
						   	const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE) = prioritise(	((
						let
							const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE = const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE
						within 
						stm_ref0::D__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)[[
							stm_ref0::terminate <- terminate
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>)
				
				-- VS version
				VS__(id__,
						   	const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE) = prioritise(	((
						let
							const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE = const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE
						within 
						stm_ref0::VS__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)[[
							stm_ref0::terminate <- terminate
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					Memory(id__)
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>)
			
				-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
				O__(id__,
						   	const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE) = dbisim(prioritise(	((
						let
							const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE = const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE
						within 
						stm_ref0::O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)[[
							stm_ref0::terminate <- terminate
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>))
								
				-- VS_O version
				VS_O__(id__,
						   	const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE) = dbisim(prioritise(	((
						let
							const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE = const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE
						within 
						stm_ref0::VS_O__(id__,
								    const_moveAwayFromPosition_TIME_LIMIT_TO_BEHAVE)[[
							stm_ref0::terminate <- terminate
						]]
					)
						[|
							union(
								{|
								|},
								{|
								|}
							)
						|]
					dbisim(Memory(id__))
				)
				\ union(
					{|
					|},
					{|
					|}
				)
				[|{|terminate|}|>SKIP
				,<union(visibleMemoryEvents,{terminate}),{tock}>))
			
				HEXT(id__,
						   	const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE) = O__(id__,
						   	const_carryBallOnBallPlacement_BehaviorController_moveAwayOp_TIME_LIMIT_TO_BEHAVE) [|shared_variable_events|] SKIP			
		}

	endmodule

module BehaviorSTM
exports
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase

	-- Transition identifiers
	-- declaring identifiers of transitions
	datatype NIDS = 
	              NID_i0|
	              NID_f0
	
	channel internal__ : NIDS
	
	-- Flow channels		
	channel interrupt
	channel exited
	channel exit
	channel terminate
	
	-- Variable channels
	channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
	
	-- Shared variable channels
	
	-- Local variable channels for defined operations that are required by the state machine
	
	-- Declaring state machine events
	
	-- Declaring call and ret events for undefined operations
	channel carryBallOnBallPlacementCall
	
	enterSS = {|
	i0::enter,
	f0::enter
	|}
	
	enteredSS = 	{|
	f0::entered
	|}
	
	internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
	
	shared_variable_events = {|
	|}
	
	-- channel set with all visible events
	sem__events = {|
		terminate
	,	carryBallOnBallPlacementCall
		|}
	
	channel clockReset, clockResetL, clockResetR 
	
	localClockResets = {||}
	
	
	channel get_CLID_f0 : core_clock_type 
	--channel increment__
	
	CLID_f0_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	

		-- Nodes --
		-- declaring all nodes
		
		----------------------------------------------------------------------
		-- Initial: i0
		module i0
		exports
		
			channel enter, interrupt
			
			Timed(OneStep) {
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__) = D__(id__)
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- Final state: f0
		module f0
		
		exports
		
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
						
						Entering 	= entered -> SKIP ; Active
						Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
						Interrupted	= share__choice(exit -> exited -> Inactive)
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			}
		
		endmodule
		----------------------------------------------------------------------
		
		-- END of Nodes --
		
		Timed(OneStep) {
		-- Operation calls --
		-- Only the undefined operations are declared here.
		-- If the state machine is in isolation, all required operations will be undefined.
		-- If it is in the context of a controller, the required operations not provided by the
		-- controller will be declared here, and the defined operations will be defined in the
		-- context of the Controller module, and therefore within scope of the state machine module.
		CALL__carryBallOnBallPlacement(id__) = EDeadline(carryBallOnBallPlacementCall,0)
		
		-- END of Operation calls --
	
		-- STM processes
		STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
		( 
			(
				(
					(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
				 	[[ share__ <- x__ | x__ <- {||} ]]
				)
			[| {share__} |]
			SKIP
			)
			[| union(sharedVarSync,{terminate}) |]
			dbisim(sharedVarMemory(id__))
		)\sharedVarHide
		,<{terminate},{tock}>)
		
		STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
		( 
			(
				(
					(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
				 	[[ share__ <- x__ | x__ <- {||} ]]
				)
			[| {share__} |]
			SKIP
			)
			[| union(sharedVarSync,{terminate}) |]
			dbisim(sharedVarMemory(id__))
		)\sharedVarHide
		,<{terminate},{tock}>)
		
		-- Transitions
		Transitions(id__) = ((let
			Trans = TimeOut_1(
				 (share__ -> SKIP
				 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((true&CALL__carryBallOnBallPlacement(
				 			id__
				 		) ; f0::enter -> SKIP))))
				 []
				 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
				 []
				 terminate -> SKIP
				 )
			,SKIP);Trans
		within
			Trans [|{terminate}|> SKIP
		)
		)
		
		-- Stateful
		-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
		
		-- Named process definitions
		MachineBody(id__) = 
			dbisim((
			let
				finalNodesEntered = {|f0::entered|}
			within
				(dbisim((dbisim((let
					-- IMPLEMENTATION NOTE:
					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
					-- modules for defining the semantics of each node.
					enterSS = {|
					i0::enter,
					f0::enter
					|}
					hideSet = union(enterSS,{|exit,exited,internal__|})
				within 
					((let
						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						-- because CSPM modules are used for the semantics of Node.
						flowevts = union(enterSS,{|exit,exited,interrupt|})
						transSync = {|internal__.NID_i0|}
					within
						((
						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						   i0::D__(id__)
						   [| { share__, terminate } |] (
						   f0::D__(id__)
						   )
						 )
						 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
						 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
						 )
						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 )
						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						|}) |]
						 ((i0::enter -> Transitions(id__))
						  [[ share__ <- x__ | x__ <- {| share__ |} ]]
						 )
						)
						)
					)
					 \ hideSet)
				)
				)
				 [| union(stateClockSync,{terminate}) |]
				 StateClocks(id__)
				)\diff(stateClockSync,enteredSS))
				 [| {| interrupt |} |] SKIP)
			)
			)
		
		Behaviour(id__) = 
			dbisim((let
				stateClockSync = {||}
			 within
				(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
			)
			)
		
		IteratedBehaviour(id__) = 
			dbisim((let
				stateClockSync = {||}
			 within
				(MachineBody(id__)) \ union(stateClockSync,enteredSS)
			)
			)
		
		Stateful(id__) = 
			((let
				getsetLocalChannels = {|get_nodeStatus,set_nodeStatus|}
				clockSync = {||}
			within
				(Behaviour(id__) 
				 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
				 (varMemory(id__) [| {terminate} |] Clocks(id__))
			 	)\union(getsetLocalChannels,clockSync)
			)
			)
		
		IteratedStateful(id__) =
			(dbisim(
				sbisim(
					IteratedBehaviour(id__)
					[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
					Memory_nodeStatus(NODE_STATUS_RUNNING)
				)\{|get_nodeStatus,set_nodeStatus|}
			)
			)
		
		-- Visible counterparts
		MachineBody_VS_O(id__) = 
			dbisim((
			let
				finalNodesEntered = {|f0::entered|}
			within
				(dbisim((dbisim((let
					-- IMPLEMENTATION NOTE:
					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
					-- modules for defining the semantics of each node.
					enterSS = {|
					i0::enter,
					f0::enter
					|}
					hideSet = union(enterSS,{|exit,exited,internal__|})
				within 
					((let
						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						-- because CSPM modules are used for the semantics of Node.
						flowevts = union(enterSS,{|exit,exited,interrupt|})
						transSync = {|internal__.NID_i0|}
					within
						((
						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						   i0::VS_O__(id__)
						   [| { share__, terminate } |] (
						   f0::VS_O__(id__)
						   )
						 )
						 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
						 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
						 )
						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 )
						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						|}) |]
						 ((i0::enter -> Transitions(id__))
						  [[ share__ <- x__ | x__ <- {| share__ |} ]]
						 )
						)
						)
					)
					 \ hideSet)
				)
				)
				 [| union(stateClockSync,{terminate}) |]
				 StateClocks(id__)
				)\diff(stateClockSync,enteredSS))
				 [| {| interrupt |} |] SKIP)
			)
			)
		
		Behaviour_VS_O(id__) = 
			dbisim((let
				stateClockSync = {||}
			 within
				(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
			)
			)
		
		IteratedBehaviour_VS_O(id__) = 
			dbisim((let
				stateClockSync = {||}
			 within
				(MachineBody_VS_O(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
			)
			)
		
		Stateful_VS_O(id__) = 
			dbisim((let
				getsetLocalChannels = {|get_nodeStatus,set_nodeStatus|}
				clockSync = {||}
			within
				(Behaviour_VS_O(id__) 
				 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
				 (varMemory(id__) [| {terminate} |] Clocks(id__))
			 	)\union(getsetLocalChannels,clockSync)
			)
			)
		
		IteratedStateful_VS_O(id__) =
			(dbisim(
				sbisim(
					IteratedBehaviour_VS_O(id__)
					[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
					Memory_nodeStatus(NODE_STATUS_RUNNING)
				)\{|get_nodeStatus,set_nodeStatus|}
			)
			)
		
		-- END
		
		-- Memory
		-- Memory variables
		Memory_nodeStatus(nodeStatus) =
			get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
			[]
			set_nodeStatus?x__ -> Memory_nodeStatus(x__)
			[]
			terminate -> SKIP
		
		-- varMemory process
		varMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
		
		getsetLocalChannels = {|get_nodeStatus,set_nodeStatus|}
		
		-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
		FVS__(id__) = STM_VS_O(id__) \ localClockResets
		D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
		O__(id__) = dbisim(D__(id__))
		VS__(id__) = FVS__(id__)
		VS_O__(id__) = dbisim(FVS__(id__))
		HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
		FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
		HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
		
		-- Clocks
		
		Clocks(id__) = terminate -> SKIP
		
		clockSync = {||}
		
		
		StateClocks(id__) = terminate -> SKIP
		
		stateClockSync = {||}
		
		-- Shared memory
		-- Shared memory variables
		
		-- sharedVarMemory process
		sharedVarMemory(id__) = terminate -> SKIP
		
		sharedVarSync = {||}
		
		sharedVarHide = {||}
		}
endmodule

-- compileSelfContainedOperation
module OP_carryBallOnBallPlacement
exports
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase

	-- Transition identifiers
	-- declaring identifiers of transitions
	datatype NIDS = 
	              NID_sInitial|
	              NID_sGoToBehindBall|
	              NID_sGiveSpaceToGetBall|
	              NID_sApproachBall|
	              NID_sPlaceBall|
	              NID_sMoveAwayFromBall|
	              NID_sFinal
	
	channel internal__ : NIDS
	
	-- Flow channels		
	channel interrupt
	channel exited
	channel exit
	channel terminate
	
	-- Variable channels
	channel get_robotHasMovedAwayFromBall, set_robotHasMovedAwayFromBall, setL_robotHasMovedAwayFromBall, setR_robotHasMovedAwayFromBall: core_boolean
	channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
	
	-- Shared variable channels
	channel set_EXT_nodeStatus: NODE_STATUS
	
	-- Local variable channels for defined operations that are required by the state machine
	
	-- Declaring state machine events
	
	-- Declaring call and ret events for undefined operations
	channel goToBehindBallCall
	channel approachBallCall
	channel carryBallCall
	channel moveAwayFromPositionCall
	
	enterSS = {|
	sInitial::enter,
	sGoToBehindBall::enter,
	sGiveSpaceToGetBall::enter,
	sApproachBall::enter,
	sPlaceBall::enter,
	sMoveAwayFromBall::enter,
	sFinal::enter
	|}
	
	enteredSS = 	{|
	sGoToBehindBall::entered,
	sGiveSpaceToGetBall::entered,
	sApproachBall::entered,
	sPlaceBall::entered,
	sMoveAwayFromBall::entered,
	sFinal::entered
	|}
	
	internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
	
	shared_variable_events = {|
		set_EXT_nodeStatus
	|}
	
	-- channel set with all visible events
	sem__events = {|
		terminate
	,	set_EXT_nodeStatus, set_nodeStatus
	,	goToBehindBallCall,
		approachBallCall,
		carryBallCall,
		moveAwayFromPositionCall
		, share__
		|}
	
	channel clockReset, clockResetL, clockResetR 
	
	localClockResets = {||}
	
	
	channel get_CLID_sGiveSpaceToGetBall : core_clock_type 
	channel get_CLID_sFinal : core_clock_type 
	channel get_CLID_sPlaceBall : core_clock_type 
	channel get_CLID_sGoToBehindBall : core_clock_type 
	channel get_CLID_sApproachBall : core_clock_type 
	channel get_CLID_sMoveAwayFromBall : core_clock_type 
	--channel increment__
	
	CLID_sGiveSpaceToGetBall_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_sFinal_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_sPlaceBall_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_sGoToBehindBall_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_sApproachBall_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_sMoveAwayFromBall_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	
	
		-- Nodes --
		-- declaring all nodes
		
		----------------------------------------------------------------------
		-- Initial: sInitial
		module sInitial
		exports
		
			channel enter, interrupt
			
			Timed(OneStep) {
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__) = D__(id__)
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sGoToBehindBall
		module sGoToBehindBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__goToBehindBall(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__goToBehindBall(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sGiveSpaceToGetBall
		module sGiveSpaceToGetBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__moveAwayFromPosition(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__moveAwayFromPosition(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sApproachBall
		module sApproachBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__approachBall(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__approachBall(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sPlaceBall
		module sPlaceBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__carryBall(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__carryBall(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sMoveAwayFromBall
		module sMoveAwayFromBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__moveAwayFromPosition(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP)));true&CALL__moveAwayFromPosition(
								id__
							) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- Final state: sFinal
		module sFinal
		
		exports
		
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
						
						Entering 	= entered -> SKIP ; Active
						Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
						Interrupted	= share__choice(exit -> exited -> Inactive)
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			}
		
		endmodule
		----------------------------------------------------------------------
		
		-- END of Nodes --
		
		Timed(OneStep) {
		-- Operation calls --
		-- Only the undefined operations are declared here.
		-- If the state machine is in isolation, all required operations will be undefined.
		-- If it is in the context of a controller, the required operations not provided by the
		-- controller will be declared here, and the defined operations will be defined in the
		-- context of the Controller module, and therefore within scope of the state machine module.
		CALL__goToBehindBall(id__) = EDeadline(goToBehindBallCall,0)
		CALL__approachBall(id__) = EDeadline(approachBallCall,0)
		CALL__carryBall(id__) = EDeadline(carryBallCall,0)
		CALL__moveAwayFromPosition(id__) = EDeadline(moveAwayFromPositionCall,0)
		
		-- END of Operation calls --
	
		-- STM processes
		STM(id__) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
		Stateful(id__) \ {terminate}
		
		STM_VS_O(id__) = -- RULE: [[stm:OperationDef]]_STM^nops : CSPProcess
		Stateful(id__) \ {terminate}
		
		-- Transitions
		Transitions(id__) = ((let
			Trans = share__choice(get_nodeStatus?nodeStatus -> get_robotHasMovedAwayFromBall?robotHasMovedAwayFromBall -> TimeOut_1(
				 (share__ -> SKIP
				 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sGoToBehindBall::enter -> SKIP))))
				 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sApproachBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sPlaceBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sMoveAwayFromBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sFinal::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGiveSpaceToGetBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sFinal::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sFinal::enter -> SKIP)))
				 [] dbisim((robotHasMovedAwayFromBall)&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sApproachBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sPlaceBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sMoveAwayFromBall::enter -> SKIP)))
				 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGiveSpaceToGetBall::enter -> SKIP)))
				 []
				 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
				 []
				 terminate -> SKIP
				 )
			,SKIP);Trans
			)
		within
			Trans [|{terminate}|> SKIP
		)
		)
		
		-- Stateful
		-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
		
		-- Named process definitions
		MachineBody(id__) = 
			dbisim((
			let
				finalNodesEntered = {|sFinal::entered|}
			within
				(dbisim((dbisim((let
					-- IMPLEMENTATION NOTE:
					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
					-- modules for defining the semantics of each node.
					enterSS = {|
					sInitial::enter,
					sGoToBehindBall::enter,
					sGiveSpaceToGetBall::enter,
					sApproachBall::enter,
					sPlaceBall::enter,
					sMoveAwayFromBall::enter,
					sFinal::enter
					|}
					hideSet = union(enterSS,{|exit,exited,internal__|})
				within 
					((let
						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						-- because CSPM modules are used for the semantics of Node.
						flowevts = union(enterSS,{|exit,exited,interrupt|})
						transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
					within
						((
						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						   sInitial::D__(id__)
						   [| { share__, terminate } |] (
						   sGoToBehindBall::D__(id__)
						   [| { share__, terminate } |] (
						   sGiveSpaceToGetBall::D__(id__)
						   [| { share__, terminate } |] (
						   sApproachBall::D__(id__)
						   [| { share__, terminate } |] (
						   sPlaceBall::D__(id__)
						   [| { share__, terminate } |] (
						   sMoveAwayFromBall::D__(id__)
						   [| { share__, terminate } |] (
						   sFinal::D__(id__)
						   )
						   )
						   )
						   )
						   )
						   )
						 )
						 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
						 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
						 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
						 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
						 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
						 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 )
						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
						 )
						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 			,setL_nodeStatus
						 			,setL_robotHasMovedAwayFromBall
						|}) |]
						 ((sInitial::enter -> Transitions(id__))
						  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
						 )
						)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
						)
					)
					 \ hideSet)
				)
				)
				 [| union(stateClockSync,{terminate}) |]
				 StateClocks(id__)
				)\diff(stateClockSync,enteredSS))
				 [| {| interrupt |} |] SKIP)
			)
			)
		
		Behaviour(id__) = 
			dbisim((let
				stateClockSync = {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
			 within
				(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
			)
			)
		
		IteratedBehaviour(id__) = 
			dbisim((let
				stateClockSync = {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
			 within
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														MachineBody(id__)
														[| {|get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered,terminate|} |]
														dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
													)\{|get_CLID_sMoveAwayFromBall|}
												)
												[| {|get_CLID_sApproachBall,sApproachBall::entered,terminate|} |]
												dbisim(Clock_CLID_sApproachBall(id__,0))
											)\{|get_CLID_sApproachBall|}
										)
										[| {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered,terminate|} |]
										dbisim(Clock_CLID_sGoToBehindBall(id__,0))
									)\{|get_CLID_sGoToBehindBall|}
								)
								[| {|get_CLID_sPlaceBall,sPlaceBall::entered,terminate|} |]
								dbisim(Clock_CLID_sPlaceBall(id__,0))
							)\{|get_CLID_sPlaceBall|}
						)
						[| {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,terminate|} |]
						dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
					)\{|get_CLID_sGiveSpaceToGetBall|}
				)
				) \ union(stateClockSync,enteredSS)
			)
			)
		
		Stateful(id__) = 
			((let
				getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
				clockSync = {||}
			within
				(Behaviour(id__) 
				 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
				 (varMemory(id__) [| {terminate} |] Clocks(id__))
			 	)\union(getsetLocalChannels,clockSync)
			)
			)
		
		IteratedStateful(id__) =
			(dbisim(
				sbisim(
					IteratedBehaviour(id__)
					[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
					Memory_robotHasMovedAwayFromBall(true)
				)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
			)
			)
		
		-- Visible counterparts
		MachineBody_VS_O(id__) = 
			dbisim((
			let
				finalNodesEntered = {|sFinal::entered|}
			within
				(dbisim((dbisim((let
					-- IMPLEMENTATION NOTE:
					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
					-- modules for defining the semantics of each node.
					enterSS = {|
					sInitial::enter,
					sGoToBehindBall::enter,
					sGiveSpaceToGetBall::enter,
					sApproachBall::enter,
					sPlaceBall::enter,
					sMoveAwayFromBall::enter,
					sFinal::enter
					|}
					hideSet = union(enterSS,{|exit,exited,internal__|})
				within 
					((let
						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						-- because CSPM modules are used for the semantics of Node.
						flowevts = union(enterSS,{|exit,exited,interrupt|})
						transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
					within
						((
						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						   sInitial::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sGoToBehindBall::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sGiveSpaceToGetBall::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sApproachBall::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sPlaceBall::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sMoveAwayFromBall::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sFinal::VS_O__(id__)
						   )
						   )
						   )
						   )
						   )
						   )
						 )
						 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
						 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
						 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
						 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
						 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
						 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 )
						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
						 )
						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 			,setL_nodeStatus
						 			,setL_robotHasMovedAwayFromBall
						|}) |]
						 ((sInitial::enter -> Transitions(id__))
						  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
						 )
						)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
						)
					)
					 \ hideSet)
				)
				)
				 [| union(stateClockSync,{terminate}) |]
				 StateClocks(id__)
				)\diff(stateClockSync,enteredSS))
				 [| {| interrupt |} |] SKIP)
			)
			)
		
		Behaviour_VS_O(id__) = 
			dbisim((let
				stateClockSync = {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
			 within
				(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
			)
			)
		
		IteratedBehaviour_VS_O(id__) = 
			dbisim((let
				stateClockSync = {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
			 within
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														MachineBody_VS_O(id__)
														[| {|get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered,terminate|} |]
														dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
													)\{|get_CLID_sMoveAwayFromBall|}
												)
												[| {|get_CLID_sApproachBall,sApproachBall::entered,terminate|} |]
												dbisim(Clock_CLID_sApproachBall(id__,0))
											)\{|get_CLID_sApproachBall|}
										)
										[| {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered,terminate|} |]
										dbisim(Clock_CLID_sGoToBehindBall(id__,0))
									)\{|get_CLID_sGoToBehindBall|}
								)
								[| {|get_CLID_sPlaceBall,sPlaceBall::entered,terminate|} |]
								dbisim(Clock_CLID_sPlaceBall(id__,0))
							)\{|get_CLID_sPlaceBall|}
						)
						[| {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,terminate|} |]
						dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
					)\{|get_CLID_sGiveSpaceToGetBall|}
				)
				) \ diff(union(stateClockSync,enteredSS),enteredSS)
			)
			)
		
		Stateful_VS_O(id__) = 
			dbisim((let
				getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
				clockSync = {||}
			within
				(Behaviour_VS_O(id__) 
				 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
				 (varMemory(id__) [| {terminate} |] Clocks(id__))
			 	)\union(getsetLocalChannels,clockSync)
			)
			)
		
		IteratedStateful_VS_O(id__) =
			(dbisim(
				sbisim(
					IteratedBehaviour_VS_O(id__)
					[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
					Memory_robotHasMovedAwayFromBall(true)
				)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
			)
			)
		
		-- END
		
		-- Memory
		-- Memory variables
		Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall) =
			get_robotHasMovedAwayFromBall!robotHasMovedAwayFromBall -> Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall)
			[]
			set_robotHasMovedAwayFromBall?x__ -> Memory_robotHasMovedAwayFromBall(x__)
			[]
			terminate -> SKIP
		
		-- varMemory process
		varMemory(id__) = Memory_robotHasMovedAwayFromBall(true)
		
		getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
		
		-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
		FVS__(id__) = STM_VS_O(id__) \ localClockResets
		D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
		O__(id__) = dbisim(D__(id__))
		VS__(id__) = FVS__(id__)
		VS_O__(id__) = dbisim(FVS__(id__))
		HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
		FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
		HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
		
		-- Clocks
		
		Clocks(id__) = terminate -> SKIP
		
		clockSync = {||}
		
		Clock_CLID_sGiveSpaceToGetBall(id__,x__) = 
			TimeOut_1(
				sGiveSpaceToGetBall::entered -> Clock_CLID_sGiveSpaceToGetBall(id__,0)
				[]
				get_CLID_sGiveSpaceToGetBall!x__ -> Clock_CLID_sGiveSpaceToGetBall(id__,x__)
				[]
				terminate -> SKIP,Clock_CLID_sGiveSpaceToGetBall(id__,clock_type_plus(x__,1,CLID_sGiveSpaceToGetBall_clock_type(id__))))
		Clock_CLID_sPlaceBall(id__,x__) = 
			TimeOut_1(
				sPlaceBall::entered -> Clock_CLID_sPlaceBall(id__,0)
				[]
				get_CLID_sPlaceBall!x__ -> Clock_CLID_sPlaceBall(id__,x__)
				[]
				terminate -> SKIP,Clock_CLID_sPlaceBall(id__,clock_type_plus(x__,1,CLID_sPlaceBall_clock_type(id__))))
		Clock_CLID_sGoToBehindBall(id__,x__) = 
			TimeOut_1(
				sGoToBehindBall::entered -> Clock_CLID_sGoToBehindBall(id__,0)
				[]
				get_CLID_sGoToBehindBall!x__ -> Clock_CLID_sGoToBehindBall(id__,x__)
				[]
				terminate -> SKIP,Clock_CLID_sGoToBehindBall(id__,clock_type_plus(x__,1,CLID_sGoToBehindBall_clock_type(id__))))
		Clock_CLID_sApproachBall(id__,x__) = 
			TimeOut_1(
				sApproachBall::entered -> Clock_CLID_sApproachBall(id__,0)
				[]
				get_CLID_sApproachBall!x__ -> Clock_CLID_sApproachBall(id__,x__)
				[]
				terminate -> SKIP,Clock_CLID_sApproachBall(id__,clock_type_plus(x__,1,CLID_sApproachBall_clock_type(id__))))
		Clock_CLID_sMoveAwayFromBall(id__,x__) = 
			TimeOut_1(
				sMoveAwayFromBall::entered -> Clock_CLID_sMoveAwayFromBall(id__,0)
				[]
				get_CLID_sMoveAwayFromBall!x__ -> Clock_CLID_sMoveAwayFromBall(id__,x__)
				[]
				terminate -> SKIP,Clock_CLID_sMoveAwayFromBall(id__,clock_type_plus(x__,1,CLID_sMoveAwayFromBall_clock_type(id__))))
		
		StateClocks(id__) = dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
		[| { terminate } |] (
		dbisim(Clock_CLID_sPlaceBall(id__,0))
		[| { terminate } |] (
		dbisim(Clock_CLID_sGoToBehindBall(id__,0))
		[| { terminate } |] (
		dbisim(Clock_CLID_sApproachBall(id__,0))
		[| { terminate } |] (
		dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
		)
		)
		)
		)
		
		stateClockSync = {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sApproachBall,sApproachBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered|}
		}
			endmodule

endmodule
