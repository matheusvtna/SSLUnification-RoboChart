
--
-- RoboChart generator version 3.0.0.202206212138
-- Automatically generated on 21-11-2023 22:22:01
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module behavior_CarryBallOnBallPlacementSTM
exports
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase

	-- Transition identifiers
	-- declaring identifiers of transitions
	datatype NIDS = 
	              NID_sInitial|
	              NID_sFinal|
	              NID_sWaitStart|
	              NID_sRun
	
	channel internal__ : NIDS
	
	-- Flow channels		
	channel interrupt
	channel exited
	channel exit
	channel terminate
	
	-- Variable channels
	channel get_robotHasMovedAwayFromBall, set_robotHasMovedAwayFromBall, setL_robotHasMovedAwayFromBall, setR_robotHasMovedAwayFromBall: core_boolean
	channel get_runningStm, set_runningStm, setL_runningStm, setR_runningStm: core_string
	channel get_skill, set_skill, setL_skill, setR_skill: behavior_Skill
	channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
	
	-- Shared variable channels
	channel set_EXT_nodeStatus: NODE_STATUS
	
	-- Local variable channels for defined operations that are required by the state machine
	
	-- Declaring state machine events
	channel startCarryBallOnBallPlacement__: NIDS.InOut
	channel startCarryBallOnBallPlacement: InOut
	channel stopCarryBallOnBallPlacement__: NIDS.InOut
	channel stopCarryBallOnBallPlacement: InOut
	channel carryBallOnBallPlacementSkill__: NIDS.InOut
	channel carryBallOnBallPlacementSkill: InOut
	
	-- Declaring call and ret events for undefined operations
	
	enterSS = {|
	sInitial::enter,
	sFinal::enter,
	sWaitStart::enter,
	sRun::enter
	|}
	
	enteredSS = 	{|
	sFinal::entered,
	sWaitStart::entered,
	sRun::entered
	|}
	
	internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
	
	shared_variable_events = {|
		set_EXT_nodeStatus
	|}
	
	-- channel set with all visible events
	sem__events = {|
		terminate
	,	set_EXT_nodeStatus, set_nodeStatus
	,	startCarryBallOnBallPlacement,
		stopCarryBallOnBallPlacement,
		carryBallOnBallPlacementSkill
		|}
	
	channel clockReset, clockResetL, clockResetR 
	
	localClockResets = {||}
	
	
	channel get_CLID_sWaitStart : core_clock_type 
	channel get_CLID_sRun : core_clock_type 
	channel get_CLID_sFinal : core_clock_type 
	--channel increment__
	
	CLID_sWaitStart_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_sRun_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_sFinal_clock_type(id__) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	

		-- Nodes --
		-- declaring all nodes
		
		----------------------------------------------------------------------
		-- Initial: sInitial
		module sInitial
		exports
		
			channel enter, interrupt
			
			Timed(OneStep) {
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__) = D__(id__)
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- Final state: sFinal
		module sFinal
		
		exports
		
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
						
						Entering 	= entered -> SKIP ; Active
						Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
						Interrupted	= share__choice(exit -> exited -> Inactive)
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sWaitStart
		module sWaitStart
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sRun
		module sRun
		
		enterSS = 
				{|			sInitial::enter,
					sGoToBehindBall::enter,
					sGiveSpaceToGetBall::enter,
					sApproachBall::enter,
					sPlaceBall::enter,
					sMoveAwayFromBall::enter,
					sFinal::enter
				|}
		enteredSS = 
				{|			sGoToBehindBall::entered,
					sGiveSpaceToGetBall::entered,
					sApproachBall::entered,
					sPlaceBall::entered,
					sMoveAwayFromBall::entered,
					sFinal::entered
				|}
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sGoToBehindBall|
			              NID_sGiveSpaceToGetBall|
			              NID_sApproachBall|
			              NID_sPlaceBall|
			              NID_sMoveAwayFromBall|
			              NID_sFinal
			
			channel internal__ : NIDS
			channel startCarryBallOnBallPlacement__: NIDS.InOut
			channel stopCarryBallOnBallPlacement__: NIDS.InOut
			channel carryBallOnBallPlacementSkill__: NIDS.InOut
			
			channel get_CLID_sPlaceBall : core_clock_type 
			channel get_CLID_sMoveAwayFromBall : core_clock_type 
			channel get_CLID_sGoToBehindBall : core_clock_type 
			channel get_CLID_sGiveSpaceToGetBall : core_clock_type 
			channel get_CLID_sApproachBall : core_clock_type 
			--channel increment__
			
			CLID_sPlaceBall_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sMoveAwayFromBall_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sGoToBehindBall_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sGiveSpaceToGetBall_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_sApproachBall_clock_type(id__) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
			--	Nodes
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: sInitial
			module sInitial
			exports
			
				channel enter, interrupt
				
				Timed(OneStep) {
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sGoToBehindBall
			module sGoToBehindBall
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sGiveSpaceToGetBall
			module sGiveSpaceToGetBall
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sApproachBall
			module sApproachBall
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sPlaceBall
			module sPlaceBall
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sMoveAwayFromBall
			module sMoveAwayFromBall
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Final state: sFinal
			module sFinal
			
			exports
			
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = D__(id__)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((dbisim(
						 	sbisim(
						 		dbisim(
						 			sbisim(
						 				dbisim(
						 					sbisim(
						 						dbisim(
						 							sbisim(
						 								dbisim(
						 									sbisim(
						 										(let
						 											-- IMPLEMENTATION NOTE:
						 											-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 											-- modules for defining the semantics of each node.
						 											enterSS = {|
						 											sInitial::enter,
						 											sGoToBehindBall::enter,
						 											sGiveSpaceToGetBall::enter,
						 											sApproachBall::enter,
						 											sPlaceBall::enter,
						 											sMoveAwayFromBall::enter,
						 											sFinal::enter
						 											|}
						 											hideSet = union(enterSS,{|exit,exited,internal__|})
						 										within 
						 											((let
						 												-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 												-- because CSPM modules are used for the semantics of Node.
						 												flowevts = union(enterSS,{|exit,exited,interrupt|})
						 												transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
						 											within
						 												((
						 												 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 												   sInitial::D__(id__)
						 												   [| { share__, terminate } |] (
						 												   sGoToBehindBall::D__(id__)
						 												   [| { share__, terminate } |] (
						 												   sGiveSpaceToGetBall::D__(id__)
						 												   [| { share__, terminate } |] (
						 												   sApproachBall::D__(id__)
						 												   [| { share__, terminate } |] (
						 												   sPlaceBall::D__(id__)
						 												   [| { share__, terminate } |] (
						 												   sMoveAwayFromBall::D__(id__)
						 												   [| { share__, terminate } |] (
						 												   sFinal::D__(id__)
						 												   )
						 												   )
						 												   )
						 												   )
						 												   )
						 												   )
						 												 )
						 												 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
						 												 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
						 												 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
						 												 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
						 												 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
						 												 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 												 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 												 )
						 												  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 												  [[set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_nodeStatus <- setL_nodeStatus]]
						 												 )
						 												 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 												 			,setL_robotHasMovedAwayFromBall
						 												 			,setL_nodeStatus
						 												|}) |]
						 												 ((sInitial::enter -> Transitions(id__))
						 												  [[ share__ <- x__ | x__ <- {| share__,setL_robotHasMovedAwayFromBall,setL_nodeStatus |} ]]
						 												 )
						 												)[[setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_nodeStatus <- set_nodeStatus]]
						 												)
						 											)
						 											 \ hideSet)
						 											[[
						 												startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
						 												stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
						 												carryBallOnBallPlacementSkill__.x____ <- carryBallOnBallPlacementSkill
						 												| x____ <- NIDS
						 											]]
						 										)
						 										[| {|get_CLID_sApproachBall,sApproachBall::entered,terminate|} |]
						 										dbisim(Clock_CLID_sApproachBall(id__,0))
						 									)\{|get_CLID_sApproachBall|}
						 								)
						 								[| {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,terminate|} |]
						 								dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
						 							)\{|get_CLID_sGiveSpaceToGetBall|}
						 						)
						 						[| {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered,terminate|} |]
						 						dbisim(Clock_CLID_sGoToBehindBall(id__,0))
						 					)\{|get_CLID_sGoToBehindBall|}
						 				)
						 				[| {|get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered,terminate|} |]
						 				dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
						 			)\{|get_CLID_sMoveAwayFromBall|}
						 		)
						 		[| {|get_CLID_sPlaceBall,sPlaceBall::entered,terminate|} |]
						 		dbisim(Clock_CLID_sPlaceBall(id__,0))
						 	)\{|get_CLID_sPlaceBall|}
						 )
						 ))
						  [[ share__ <- x__ | x__ <- {| share__,setR_robotHasMovedAwayFromBall,setR_nodeStatus,setR_skill,setR_runningStm |} ]] 
						  [[set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_nodeStatus <- setL_nodeStatus,set_skill <- setL_skill,set_runningStm <- setL_runningStm]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_robotHasMovedAwayFromBall
						 			,setL_nodeStatus
						 			,setL_skill
						 			,setL_runningStm
						 			,setR_robotHasMovedAwayFromBall
						 			 			,setR_nodeStatus
						 			 			,setR_skill
						 			 			,setR_runningStm
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_robotHasMovedAwayFromBall,setL_nodeStatus,setL_skill,setL_runningStm |} ]]
						  [[set_robotHasMovedAwayFromBall <- setR_robotHasMovedAwayFromBall,set_nodeStatus <- setR_nodeStatus,set_skill <- setR_skill,set_runningStm <- setR_runningStm]]
						 )
						)[[setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_nodeStatus <- set_nodeStatus,setL_skill <- set_skill,setL_runningStm <- set_runningStm]]
						 [[setR_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setR_nodeStatus <- set_nodeStatus,setR_skill <- set_skill,setR_runningStm <- set_runningStm]]
						)\union(enteredSS,{terminate}) 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((dbisim(
						 	sbisim(
						 		dbisim(
						 			sbisim(
						 				dbisim(
						 					sbisim(
						 						dbisim(
						 							sbisim(
						 								dbisim(
						 									sbisim(
						 										(let
						 											-- IMPLEMENTATION NOTE:
						 											-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 											-- modules for defining the semantics of each node.
						 											enterSS = {|
						 											sInitial::enter,
						 											sGoToBehindBall::enter,
						 											sGiveSpaceToGetBall::enter,
						 											sApproachBall::enter,
						 											sPlaceBall::enter,
						 											sMoveAwayFromBall::enter,
						 											sFinal::enter
						 											|}
						 											hideSet = union(enterSS,{|exit,exited,internal__|})
						 										within 
						 											((let
						 												-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 												-- because CSPM modules are used for the semantics of Node.
						 												flowevts = union(enterSS,{|exit,exited,interrupt|})
						 												transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
						 											within
						 												((
						 												 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 												   sInitial::VS_O__(id__)
						 												   [| { share__, terminate } |] (
						 												   sGoToBehindBall::VS_O__(id__)
						 												   [| { share__, terminate } |] (
						 												   sGiveSpaceToGetBall::VS_O__(id__)
						 												   [| { share__, terminate } |] (
						 												   sApproachBall::VS_O__(id__)
						 												   [| { share__, terminate } |] (
						 												   sPlaceBall::VS_O__(id__)
						 												   [| { share__, terminate } |] (
						 												   sMoveAwayFromBall::VS_O__(id__)
						 												   [| { share__, terminate } |] (
						 												   sFinal::VS_O__(id__)
						 												   )
						 												   )
						 												   )
						 												   )
						 												   )
						 												   )
						 												 )
						 												 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
						 												 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
						 												 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
						 												 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
						 												 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
						 												 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 												 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 												 )
						 												  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 												  [[set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_nodeStatus <- setL_nodeStatus]]
						 												 )
						 												 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 												 			,setL_robotHasMovedAwayFromBall
						 												 			,setL_nodeStatus
						 												|}) |]
						 												 ((sInitial::enter -> Transitions(id__))
						 												  [[ share__ <- x__ | x__ <- {| share__,setL_robotHasMovedAwayFromBall,setL_nodeStatus |} ]]
						 												 )
						 												)[[setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_nodeStatus <- set_nodeStatus]]
						 												)
						 											)
						 											 \ hideSet)
						 											[[
						 												startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
						 												stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
						 												carryBallOnBallPlacementSkill__.x____ <- carryBallOnBallPlacementSkill
						 												| x____ <- NIDS
						 											]]
						 										)
						 										[| {|get_CLID_sApproachBall,sApproachBall::entered,terminate|} |]
						 										dbisim(Clock_CLID_sApproachBall(id__,0))
						 									)\{|get_CLID_sApproachBall|}
						 								)
						 								[| {|get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,terminate|} |]
						 								dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
						 							)\{|get_CLID_sGiveSpaceToGetBall|}
						 						)
						 						[| {|get_CLID_sGoToBehindBall,sGoToBehindBall::entered,terminate|} |]
						 						dbisim(Clock_CLID_sGoToBehindBall(id__,0))
						 					)\{|get_CLID_sGoToBehindBall|}
						 				)
						 				[| {|get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered,terminate|} |]
						 				dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
						 			)\{|get_CLID_sMoveAwayFromBall|}
						 		)
						 		[| {|get_CLID_sPlaceBall,sPlaceBall::entered,terminate|} |]
						 		dbisim(Clock_CLID_sPlaceBall(id__,0))
						 	)\{|get_CLID_sPlaceBall|}
						 )
						 ))
						  [[ share__ <- x__ | x__ <- {| share__,setR_robotHasMovedAwayFromBall,setR_nodeStatus,setR_skill,setR_runningStm |} ]] 
						  [[set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_nodeStatus <- setL_nodeStatus,set_skill <- setL_skill,set_runningStm <- setL_runningStm]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_robotHasMovedAwayFromBall
						 			,setL_nodeStatus
						 			,setL_skill
						 			,setL_runningStm
						 			,setR_robotHasMovedAwayFromBall
						 			 			,setR_nodeStatus
						 			 			,setR_skill
						 			 			,setR_runningStm
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_robotHasMovedAwayFromBall,setL_nodeStatus,setL_skill,setL_runningStm |} ]]
						  [[set_robotHasMovedAwayFromBall <- setR_robotHasMovedAwayFromBall,set_nodeStatus <- setR_nodeStatus,set_skill <- setR_skill,set_runningStm <- setR_runningStm]]
						 )
						)[[setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_nodeStatus <- set_nodeStatus,setL_skill <- set_skill,setL_runningStm <- set_runningStm]]
						 [[setR_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setR_nodeStatus <- set_nodeStatus,setR_skill <- set_skill,setR_runningStm <- set_runningStm]]
						)\{terminate} 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
				
				Transitions(id__) = ((let
					Trans = share__choice(get_robotHasMovedAwayFromBall?robotHasMovedAwayFromBall -> get_nodeStatus?nodeStatus -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((share__choice(true & (share__choice(set_skill!behavior_Skill_GO_TO_BEHIND_BALL -> SKIP))) ; sGoToBehindBall::enter -> SKIP))))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_GO_TO_BEHIND_BALL -> SKIP))) ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_APPROACH_BALL -> SKIP))) ; sApproachBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_CARRY_BALL -> SKIP))) ; sPlaceBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_MOVE_AWAY_FROM_POSITION -> SKIP))) ; sMoveAwayFromBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_NONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_MOVE_AWAY_FROM_POSITION -> SKIP))) ; sGiveSpaceToGetBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_GO_TO_BEHIND_BALL -> SKIP))) ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_GO_TO_BEHIND_BALL -> SKIP))) ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_NONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_NONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 [] dbisim((robotHasMovedAwayFromBall)&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_skill!behavior_Skill_GO_TO_BEHIND_BALL -> SKIP))) ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sApproachBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sPlaceBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sMoveAwayFromBall::enter -> SKIP)))
						 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGiveSpaceToGetBall::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				
				-- Clocks
				Clock_CLID_sPlaceBall(id__,x__) = 
					TimeOut_1(
						sPlaceBall::entered -> Clock_CLID_sPlaceBall(id__,0)
						[]
						get_CLID_sPlaceBall!x__ -> Clock_CLID_sPlaceBall(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sPlaceBall(id__,clock_type_plus(x__,1,CLID_sPlaceBall_clock_type(id__))))
				Clock_CLID_sMoveAwayFromBall(id__,x__) = 
					TimeOut_1(
						sMoveAwayFromBall::entered -> Clock_CLID_sMoveAwayFromBall(id__,0)
						[]
						get_CLID_sMoveAwayFromBall!x__ -> Clock_CLID_sMoveAwayFromBall(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sMoveAwayFromBall(id__,clock_type_plus(x__,1,CLID_sMoveAwayFromBall_clock_type(id__))))
				Clock_CLID_sGoToBehindBall(id__,x__) = 
					TimeOut_1(
						sGoToBehindBall::entered -> Clock_CLID_sGoToBehindBall(id__,0)
						[]
						get_CLID_sGoToBehindBall!x__ -> Clock_CLID_sGoToBehindBall(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sGoToBehindBall(id__,clock_type_plus(x__,1,CLID_sGoToBehindBall_clock_type(id__))))
				Clock_CLID_sGiveSpaceToGetBall(id__,x__) = 
					TimeOut_1(
						sGiveSpaceToGetBall::entered -> Clock_CLID_sGiveSpaceToGetBall(id__,0)
						[]
						get_CLID_sGiveSpaceToGetBall!x__ -> Clock_CLID_sGiveSpaceToGetBall(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sGiveSpaceToGetBall(id__,clock_type_plus(x__,1,CLID_sGiveSpaceToGetBall_clock_type(id__))))
				Clock_CLID_sApproachBall(id__,x__) = 
					TimeOut_1(
						sApproachBall::entered -> Clock_CLID_sApproachBall(id__,0)
						[]
						get_CLID_sApproachBall!x__ -> Clock_CLID_sApproachBall(id__,x__)
						[]
						terminate -> SKIP,Clock_CLID_sApproachBall(id__,clock_type_plus(x__,1,CLID_sApproachBall_clock_type(id__))))
				
				StateClocks(id__) = dbisim(Clock_CLID_sPlaceBall(id__,0))
				[| { terminate } |] (
				dbisim(Clock_CLID_sMoveAwayFromBall(id__,0))
				[| { terminate } |] (
				dbisim(Clock_CLID_sGoToBehindBall(id__,0))
				[| { terminate } |] (
				dbisim(Clock_CLID_sGiveSpaceToGetBall(id__,0))
				[| { terminate } |] (
				dbisim(Clock_CLID_sApproachBall(id__,0))
				)
				)
				)
				)
				
				stateClockSync = {|get_CLID_sPlaceBall,sPlaceBall::entered,get_CLID_sMoveAwayFromBall,sMoveAwayFromBall::entered,get_CLID_sGoToBehindBall,sGoToBehindBall::entered,get_CLID_sGiveSpaceToGetBall,sGiveSpaceToGetBall::entered,get_CLID_sApproachBall,sApproachBall::entered|}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		-- END of Nodes --
		
		Timed(OneStep) {
		-- Operation calls --
		-- Only the undefined operations are declared here.
		-- If the state machine is in isolation, all required operations will be undefined.
		-- If it is in the context of a controller, the required operations not provided by the
		-- controller will be declared here, and the defined operations will be defined in the
		-- context of the Controller module, and therefore within scope of the state machine module.
		
		-- END of Operation calls --
	
		-- STM processes
		STM(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
		( 
			(
				(
					(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
				 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
				)
			[| {share__} |]
			SKIP
			)
			[| union(sharedVarSync,{terminate}) |]
			dbisim(sharedVarMemory(id__))
		)\sharedVarHide
		,<{terminate},{tock}>)
		
		STM_VS_O(id__) = prioritise(-- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
		( 
			(
				(
					(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
				 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
				)
			[| {share__} |]
			SKIP
			)
			[| union(sharedVarSync,{terminate}) |]
			dbisim(sharedVarMemory(id__))
		)\sharedVarHide
		,<{terminate},{tock}>)
		
		-- Transitions
		Transitions(id__) = ((let
			Trans = TimeOut_1(
				 (share__ -> SKIP
				 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
				 [] dbisim((true)&(startCarryBallOnBallPlacement__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
				 [] dbisim((true)&(stopCarryBallOnBallPlacement__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP)));share__choice(true & (share__choice(set_skill!behavior_Skill_NONE -> SKIP))) ; sFinal::enter -> SKIP)))
				 []
				 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
				 []
				 terminate -> SKIP
				 )
			,SKIP);Trans
		within
			Trans [|{terminate}|> SKIP
		)
		)
		
		-- Stateful
		-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
		
		-- Named process definitions
		MachineBody(id__) = 
			dbisim((
			let
				finalNodesEntered = {|sFinal::entered|}
			within
				(dbisim((dbisim((let
					-- IMPLEMENTATION NOTE:
					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
					-- modules for defining the semantics of each node.
					enterSS = {|
					sInitial::enter,
					sFinal::enter,
					sWaitStart::enter,
					sRun::enter
					|}
					hideSet = union(enterSS,{|exit,exited,internal__|})
				within 
					((let
						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						-- because CSPM modules are used for the semantics of Node.
						flowevts = union(enterSS,{|exit,exited,interrupt|})
						transSync = {|internal__.NID_sInitial,startCarryBallOnBallPlacement__.NID_sWaitStart.in,stopCarryBallOnBallPlacement__.NID_sRun.in|}
					within
						((
						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						   sInitial::D__(id__)
						   [| { share__, terminate } |] (
						   sFinal::D__(id__)
						   [| { share__, terminate } |] (
						   sWaitStart::D__(id__)
						   [| { share__, terminate } |] (
						   sRun::D__(id__)
						   )
						   )
						   )
						 )
						 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBallOnBallPlacement__.NID_sWaitStart.in|}]]
						 [[sRun::interrupt <- x__ | x__ <- {|interrupt,stopCarryBallOnBallPlacement__.NID_sRun.in|}]]
						 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 )
						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 )
						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						|}) |]
						 ((sInitial::enter -> Transitions(id__))
						  [[ share__ <- x__ | x__ <- {| share__ |} ]]
						 )
						)
						)
					)
					 \ hideSet)
					[[
						startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
						stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
						carryBallOnBallPlacementSkill__.x____ <- carryBallOnBallPlacementSkill
						| x____ <- NIDS
					]]
				)
				)
				 [| union(stateClockSync,{terminate}) |]
				 StateClocks(id__)
				)\diff(stateClockSync,enteredSS))
				 [| {| interrupt |} |] SKIP)
			)
			)
		
		Behaviour(id__) = 
			dbisim((let
				stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
			 within
				(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
			)
			)
		
		IteratedBehaviour(id__) = 
			dbisim((let
				stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
			 within
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								MachineBody(id__)
								[| {|get_CLID_sRun,sRun::entered,terminate|} |]
								dbisim(Clock_CLID_sRun(id__,0))
							)\{|get_CLID_sRun|}
						)
						[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
						dbisim(Clock_CLID_sWaitStart(id__,0))
					)\{|get_CLID_sWaitStart|}
				)
				) \ union(stateClockSync,enteredSS)
			)
			)
		
		Stateful(id__) = 
			((let
				getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,
				get_runningStm,set_runningStm,
				get_skill,set_skill|}
				clockSync = {||}
			within
				(Behaviour(id__) 
				 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
				 (varMemory(id__) [| {terminate} |] Clocks(id__))
			 	)\union(getsetLocalChannels,clockSync)
			)
			)
		
		IteratedStateful(id__) =
			(dbisim(
				sbisim(
					dbisim(
						sbisim(
							dbisim(
								sbisim(
									IteratedBehaviour(id__)
									[| {|get_skill,set_skill,terminate|} |]
									Memory_skill(behavior_Skill_NONE)
								)\{|get_skill,set_skill|}
							)
							[| {|get_runningStm,set_runningStm,terminate|} |]
							Memory_runningStm("")
						)\{|get_runningStm,set_runningStm|}
					)
					[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
					Memory_robotHasMovedAwayFromBall(true)
				)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
			)
			)
		
		-- Visible counterparts
		MachineBody_VS_O(id__) = 
			dbisim((
			let
				finalNodesEntered = {|sFinal::entered|}
			within
				(dbisim((dbisim((let
					-- IMPLEMENTATION NOTE:
					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
					-- modules for defining the semantics of each node.
					enterSS = {|
					sInitial::enter,
					sFinal::enter,
					sWaitStart::enter,
					sRun::enter
					|}
					hideSet = union(enterSS,{|exit,exited,internal__|})
				within 
					((let
						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						-- because CSPM modules are used for the semantics of Node.
						flowevts = union(enterSS,{|exit,exited,interrupt|})
						transSync = {|internal__.NID_sInitial,startCarryBallOnBallPlacement__.NID_sWaitStart.in,stopCarryBallOnBallPlacement__.NID_sRun.in|}
					within
						((
						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						   sInitial::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sFinal::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sWaitStart::VS_O__(id__)
						   [| { share__, terminate } |] (
						   sRun::VS_O__(id__)
						   )
						   )
						   )
						 )
						 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBallOnBallPlacement__.NID_sWaitStart.in|}]]
						 [[sRun::interrupt <- x__ | x__ <- {|interrupt,stopCarryBallOnBallPlacement__.NID_sRun.in|}]]
						 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 )
						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 )
						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						|}) |]
						 ((sInitial::enter -> Transitions(id__))
						  [[ share__ <- x__ | x__ <- {| share__ |} ]]
						 )
						)
						)
					)
					 \ hideSet)
					[[
						startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
						stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
						carryBallOnBallPlacementSkill__.x____ <- carryBallOnBallPlacementSkill
						| x____ <- NIDS
					]]
				)
				)
				 [| union(stateClockSync,{terminate}) |]
				 StateClocks(id__)
				)\diff(stateClockSync,enteredSS))
				 [| {| interrupt |} |] SKIP)
			)
			)
		
		Behaviour_VS_O(id__) = 
			dbisim((let
				stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
			 within
				(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
			)
			)
		
		IteratedBehaviour_VS_O(id__) = 
			dbisim((let
				stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
			 within
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								MachineBody_VS_O(id__)
								[| {|get_CLID_sRun,sRun::entered,terminate|} |]
								dbisim(Clock_CLID_sRun(id__,0))
							)\{|get_CLID_sRun|}
						)
						[| {|get_CLID_sWaitStart,sWaitStart::entered,terminate|} |]
						dbisim(Clock_CLID_sWaitStart(id__,0))
					)\{|get_CLID_sWaitStart|}
				)
				) \ diff(union(stateClockSync,enteredSS),enteredSS)
			)
			)
		
		Stateful_VS_O(id__) = 
			dbisim((let
				getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,
				get_runningStm,set_runningStm,
				get_skill,set_skill|}
				clockSync = {||}
			within
				(Behaviour_VS_O(id__) 
				 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
				 (varMemory(id__) [| {terminate} |] Clocks(id__))
			 	)\union(getsetLocalChannels,clockSync)
			)
			)
		
		IteratedStateful_VS_O(id__) =
			(dbisim(
				sbisim(
					dbisim(
						sbisim(
							dbisim(
								sbisim(
									IteratedBehaviour_VS_O(id__)
									[| {|get_skill,set_skill,terminate|} |]
									Memory_skill(behavior_Skill_NONE)
								)\{|get_skill,set_skill|}
							)
							[| {|get_runningStm,set_runningStm,terminate|} |]
							Memory_runningStm("")
						)\{|get_runningStm,set_runningStm|}
					)
					[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
					Memory_robotHasMovedAwayFromBall(true)
				)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
			)
			)
		
		-- END
		
		-- Memory
		-- Memory variables
		Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall) =
			get_robotHasMovedAwayFromBall!robotHasMovedAwayFromBall -> Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall)
			[]
			set_robotHasMovedAwayFromBall?x__ -> Memory_robotHasMovedAwayFromBall(x__)
			[]
			terminate -> SKIP
		Memory_runningStm(runningStm) =
			get_runningStm!runningStm -> Memory_runningStm(runningStm)
			[]
			set_runningStm?x__ -> Memory_runningStm(x__)
			[]
			terminate -> SKIP
		Memory_skill(skill) =
			get_skill!skill -> Memory_skill(skill)
			[]
			set_skill?x__ -> Memory_skill(x__)
			[]
			terminate -> SKIP
		
		-- varMemory process
		varMemory(id__) = Memory_robotHasMovedAwayFromBall(true)
		[| { terminate } |] (
		Memory_runningStm("")
		[| { terminate } |] (
		Memory_skill(behavior_Skill_NONE)
		)
		)
		
		getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,get_runningStm,set_runningStm,get_skill,set_skill|}
		
		-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
		FVS__(id__) = STM_VS_O(id__) \ localClockResets
		D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
		O__(id__) = dbisim(D__(id__))
		VS__(id__) = FVS__(id__)
		VS_O__(id__) = dbisim(FVS__(id__))
		HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
		FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
		HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
		
		-- Clocks
		
		Clocks(id__) = terminate -> SKIP
		
		clockSync = {||}
		
		Clock_CLID_sWaitStart(id__,x__) = 
			TimeOut_1(
				sWaitStart::entered -> Clock_CLID_sWaitStart(id__,0)
				[]
				get_CLID_sWaitStart!x__ -> Clock_CLID_sWaitStart(id__,x__)
				[]
				terminate -> SKIP,Clock_CLID_sWaitStart(id__,clock_type_plus(x__,1,CLID_sWaitStart_clock_type(id__))))
		Clock_CLID_sRun(id__,x__) = 
			TimeOut_1(
				sRun::entered -> Clock_CLID_sRun(id__,0)
				[]
				get_CLID_sRun!x__ -> Clock_CLID_sRun(id__,x__)
				[]
				terminate -> SKIP,Clock_CLID_sRun(id__,clock_type_plus(x__,1,CLID_sRun_clock_type(id__))))
		
		StateClocks(id__) = dbisim(Clock_CLID_sWaitStart(id__,0))
		[| { terminate } |] (
		dbisim(Clock_CLID_sRun(id__,0))
		)
		
		stateClockSync = {|get_CLID_sWaitStart,sWaitStart::entered,get_CLID_sRun,sRun::entered|}
		
		-- Shared memory
		-- Shared memory variables
		Memory_nodeStatus(nodeStatus) =
			get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
			[]
			set_nodeStatus?x__ -> Memory_nodeStatus(x__)
			[]
			set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
			[]
			terminate -> SKIP
		
		-- sharedVarMemory process
		sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
		
		sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
		
		sharedVarHide = {|get_nodeStatus|}
		}
endmodule
