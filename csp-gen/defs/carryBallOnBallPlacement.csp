
--
-- RoboChart generator version 3.0.0.202206212138
-- Automatically generated on 08-11-2023 12:25:46
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module carryBallOnBallPlacement
exports


	module BehaviorController
		shared_variable_events = {|
		|}
		
	exports
		transparent diamond
		transparent sbisim
		transparent dbisim
		transparent chase

		-- declaring controller events
		channel receiveFrame: InOut.core_string
		channel receiveField: InOut.core_string
		channel receiveTactic: InOut.Tactic
		channel sendAction: InOut.core_string
		channel sendSkill: InOut.carryBallOnBallPlacement_Skill
		
		channel set_nodeStatus: NODE_STATUS
		channel get_nodeStatus: NODE_STATUS
		
		
		-- declaring call and ret events for undefined operations
		
		-- declaring controller termination channel
		channel terminate
		
		-- channel set with all visible events
		sem__events = {|
			terminate
		,	receiveFrame,
			receiveField,
			receiveTactic,
			sendAction,
			sendSkill
		|}

		-- defined operations
	
		-- declaring machines
		module stm_behavior_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sWaitTactic|
			              NID_jCheckCurrentTactic|
			              NID_jStopLastTactic|
			              NID_jStartCurrentTactic
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_currentTactic, set_currentTactic, setL_currentTactic, setR_currentTactic: Tactic
			channel get_lastTactic, set_lastTactic, setL_lastTactic, setR_lastTactic: Tactic
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel receiveFrame__: NIDS.InOut.core_string
			channel receiveFrame: InOut.core_string
			channel receiveField__: NIDS.InOut.core_string
			channel receiveField: InOut.core_string
			channel receiveTactic__: NIDS.InOut.Tactic
			channel receiveTactic: InOut.Tactic
			channel sendAction__: NIDS.InOut.core_string
			channel sendAction: InOut.core_string
			channel sendSkill__: NIDS.InOut.carryBallOnBallPlacement_Skill
			channel sendSkill: InOut.carryBallOnBallPlacement_Skill
			channel startCarryBallOnBallPlacement__: NIDS.InOut
			channel startCarryBallOnBallPlacement: InOut
			channel stopCarryBallOnBallPlacement__: NIDS.InOut
			channel stopCarryBallOnBallPlacement: InOut
			channel startHalt__: NIDS.InOut
			channel startHalt: InOut
			channel stopHalt__: NIDS.InOut
			channel stopHalt: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sWaitTactic::enter,
			jCheckCurrentTactic::enter,
			jStopLastTactic::enter,
			jStartCurrentTactic::enter
			|}
			
			enteredSS = 	{|
			sWaitTactic::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	receiveFrame,
				receiveField,
				receiveTactic,
				sendAction,
				sendSkill,
				startCarryBallOnBallPlacement,
				stopCarryBallOnBallPlacement,
				startHalt,
				stopHalt
				|}
		
			-- Nodes --
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: sInitial
			module sInitial
			exports
			
				channel enter, interrupt
				
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sWaitTactic
			module sWaitTactic
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--	Nodes
				-- declaring all nodes
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Junction: jCheckCurrentTactic
			module jCheckCurrentTactic
			exports
			
				channel enter, interrupt
				
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Junction: jStopLastTactic
			module jStopLastTactic
			exports
			
				channel enter, interrupt
				
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Junction: jStartCurrentTactic
			module jStartCurrentTactic
			exports
			
				channel enter, interrupt
				
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			-- END of Nodes --
			
			-- Operation calls --
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machine module.
			
			-- END of Operation calls --
			
			-- STM processes
			STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {||} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {||} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			-- Transitions
			Transitions(id__) = ((let
				Trans = share__choice(get_currentTactic?currentTactic -> get_lastTactic?lastTactic -> (
					((share__ -> SKIP
					 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitTactic::enter -> SKIP))))
					 	 [] dbisim((true)&(receiveTactic__!NID_sWaitTactic.in?currentTactic:{currentTactic|currentTactic <- Tactic, true} -> share__choice(set_currentTactic!currentTactic -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; jCheckCurrentTactic::enter -> SKIP)))
					 	 [] dbisim(((currentTactic==lastTactic))&(internal__!NID_jCheckCurrentTactic -> SKIP ;  ((SKIP ; sWaitTactic::enter -> SKIP))))
					 	 [] dbisim(((currentTactic!=lastTactic))&(internal__!NID_jCheckCurrentTactic -> SKIP ;  ((SKIP ; jStopLastTactic::enter -> SKIP))))
					 	 [] dbisim(((lastTactic==Tactic_PLACE_BALL_IN_POSITION))&(internal__!NID_jStopLastTactic -> SKIP ;  ((true&(share__choice(stopCarryBallOnBallPlacement.out -> SKIP)) ; jStartCurrentTactic::enter -> SKIP))))
					 	 [] dbisim(((lastTactic==Tactic_HALT))&(internal__!NID_jStopLastTactic -> SKIP ;  ((true&(share__choice(stopHalt.out -> SKIP)) ; jStartCurrentTactic::enter -> SKIP))))
					 	 [] dbisim(((currentTactic==Tactic_PLACE_BALL_IN_POSITION))&(internal__!NID_jStartCurrentTactic -> SKIP ;  ((true&(share__choice(startCarryBallOnBallPlacement.out -> SKIP)) ; sWaitTactic::enter -> SKIP))))
					 	 [] dbisim(((currentTactic==Tactic_HALT))&(internal__!NID_jStartCurrentTactic -> SKIP ;  ((true&(share__choice(startHalt.out -> SKIP)) ; sWaitTactic::enter -> SKIP))))
					 ) ; Trans)
					 []
					 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
					 []
					 terminate -> SKIP
				)
				)
			within
				Trans
			)
			)
			
			-- Stateful
			-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
			
			-- Named process definitions
			MachineBody(id__) = 
				dbisim((
				let
					finalNodesEntered = {||}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sWaitTactic::enter,
						jCheckCurrentTactic::enter,
						jStopLastTactic::enter,
						jStartCurrentTactic::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,receiveTactic__.NID_sWaitTactic.in,internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic,internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic,internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::D__(id__)
							   [| { share__, terminate } |] (
							   sWaitTactic::D__(id__)
							   [| { share__, terminate } |] (
							   jCheckCurrentTactic::D__(id__)
							   [| { share__, terminate } |] (
							   jStopLastTactic::D__(id__)
							   [| { share__, terminate } |] (
							   jStartCurrentTactic::D__(id__)
							   )
							   )
							   )
							   )
							 )
							 [[sWaitTactic::interrupt <- x__ | x__ <- {|interrupt,receiveTactic__.NID_sWaitTactic.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 [[jCheckCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic|}]]
							 [[jStopLastTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic|}]]
							 [[jStartCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__,setR_currentTactic |} ]] 
							  [[set_currentTactic <- setL_currentTactic,set_lastTactic <- setL_lastTactic]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_currentTactic
							 			,setL_lastTactic
							 			,setR_currentTactic
							 			|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__,setL_currentTactic,setL_lastTactic |} ]]
							  [[set_currentTactic <- setR_currentTactic]]
							 )
							)[[setL_currentTactic <- set_currentTactic,setL_lastTactic <- set_lastTactic]]
							 [[setR_currentTactic <- set_currentTactic]]
							)
						)
						 \ hideSet)
						[[
							receiveFrame__.x____ <- receiveFrame,
							receiveField__.x____ <- receiveField,
							receiveTactic__.x____ <- receiveTactic,
							sendAction__.x____ <- sendAction,
							sendSkill__.x____ <- sendSkill,
							startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
							stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
							startHalt__.x____ <- startHalt,
							stopHalt__.x____ <- stopHalt
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			IteratedBehaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			Stateful(id__) = 
				((
					(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										Behaviour(id__)
										[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
										Memory_nodeStatus(NODE_STATUS_RUNNING)
									)\{|get_nodeStatus,set_nodeStatus|}
								)
								[| {|get_lastTactic,set_lastTactic,terminate|} |]
								Memory_lastTactic(Tactic_HALT)
							)\{|get_lastTactic,set_lastTactic|}
						)
						[| {|get_currentTactic,set_currentTactic,terminate|} |]
						Memory_currentTactic(Tactic_HALT)
					)\{|get_currentTactic,set_currentTactic|}
				)
				)
			
			-- Visible counterparts
			MachineBody_VS_O(id__) = 
				dbisim((
				let
					finalNodesEntered = {||}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sWaitTactic::enter,
						jCheckCurrentTactic::enter,
						jStopLastTactic::enter,
						jStartCurrentTactic::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,receiveTactic__.NID_sWaitTactic.in,internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic,internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic,internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sWaitTactic::VS_O__(id__)
							   [| { share__, terminate } |] (
							   jCheckCurrentTactic::VS_O__(id__)
							   [| { share__, terminate } |] (
							   jStopLastTactic::VS_O__(id__)
							   [| { share__, terminate } |] (
							   jStartCurrentTactic::VS_O__(id__)
							   )
							   )
							   )
							   )
							 )
							 [[sWaitTactic::interrupt <- x__ | x__ <- {|interrupt,receiveTactic__.NID_sWaitTactic.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 [[jCheckCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic|}]]
							 [[jStopLastTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic|}]]
							 [[jStartCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__,setR_currentTactic |} ]] 
							  [[set_currentTactic <- setL_currentTactic,set_lastTactic <- setL_lastTactic]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_currentTactic
							 			,setL_lastTactic
							 			,setR_currentTactic
							 			|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__,setL_currentTactic,setL_lastTactic |} ]]
							  [[set_currentTactic <- setR_currentTactic]]
							 )
							)[[setL_currentTactic <- set_currentTactic,setL_lastTactic <- set_lastTactic]]
							 [[setR_currentTactic <- set_currentTactic]]
							)
						)
						 \ hideSet)
						[[
							receiveFrame__.x____ <- receiveFrame,
							receiveField__.x____ <- receiveField,
							receiveTactic__.x____ <- receiveTactic,
							sendAction__.x____ <- sendAction,
							sendSkill__.x____ <- sendSkill,
							startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
							stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
							startHalt__.x____ <- startHalt,
							stopHalt__.x____ <- stopHalt
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			IteratedBehaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			Stateful_VS_O(id__) = 
				dbisim((
					(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful_VS_O(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										Behaviour_VS_O(id__)
										[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
										Memory_nodeStatus(NODE_STATUS_RUNNING)
									)\{|get_nodeStatus,set_nodeStatus|}
								)
								[| {|get_lastTactic,set_lastTactic,terminate|} |]
								Memory_lastTactic(Tactic_HALT)
							)\{|get_lastTactic,set_lastTactic|}
						)
						[| {|get_currentTactic,set_currentTactic,terminate|} |]
						Memory_currentTactic(Tactic_HALT)
					)\{|get_currentTactic,set_currentTactic|}
				)
				)
			
			-- END
			
			-- Memory
			-- Memory variables
			Memory_currentTactic(currentTactic) =
				get_currentTactic!currentTactic -> Memory_currentTactic(currentTactic)
				[]
				set_currentTactic?x__ -> Memory_currentTactic(x__)
				[]
				terminate -> SKIP
			Memory_lastTactic(lastTactic) =
				get_lastTactic!lastTactic -> Memory_lastTactic(lastTactic)
				[]
				set_lastTactic?x__ -> Memory_lastTactic(x__)
				[]
				terminate -> SKIP
			Memory_nodeStatus(nodeStatus) =
				get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
				[]
				set_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				terminate -> SKIP
			
			-- varMemory process
			varMemory(id__) = Memory_currentTactic(Tactic_HALT)
			[| { terminate } |] (
			Memory_lastTactic(Tactic_HALT)
			[| { terminate } |] (
			Memory_nodeStatus(NODE_STATUS_RUNNING)
			)
			)
			
			getsetLocalChannels = {|get_currentTactic,set_currentTactic,get_lastTactic,set_lastTactic,get_nodeStatus,set_nodeStatus|}
			
			-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			FVS__(id__) = STM_VS_O(id__)
			
			D__(id__) = STM(id__) \ internal_events
			O__(id__) = sbisim(diamond(D__(id__)))
			VS__(id__) = FVS__(id__)
			VS_O__(id__) = sbisim(diamond(FVS__(id__)))
			HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
			HUP__(id__) = O__(id__) [|{share__}|] SKIP
			
			-- Shared memory
			-- Shared memory variables
			
			-- sharedVarMemory process
			sharedVarMemory(id__) = terminate -> SKIP
			
			sharedVarSync = {||}
			
			sharedVarHide = {||}
		endmodule
		module stm_carry_ball_on_ball_placement_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_robotHasMovedAwayFromBall, set_robotHasMovedAwayFromBall, setL_robotHasMovedAwayFromBall, setR_robotHasMovedAwayFromBall: core_boolean
			channel get_runningStm, set_runningStm, setL_runningStm, setR_runningStm: core_string
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startCarryBallOnBallPlacement__: NIDS.InOut
			channel startCarryBallOnBallPlacement: InOut
			channel stopCarryBallOnBallPlacement__: NIDS.InOut
			channel stopCarryBallOnBallPlacement: InOut
			channel startGoToBehindBall__: NIDS.InOut
			channel startGoToBehindBall: InOut
			channel stopGoToBehindBall__: NIDS.InOut
			channel stopGoToBehindBall: InOut
			channel startApproachBall__: NIDS.InOut
			channel startApproachBall: InOut
			channel stopApproachBall__: NIDS.InOut
			channel stopApproachBall: InOut
			channel startCarryBall__: NIDS.InOut
			channel startCarryBall: InOut
			channel stopCarryBall__: NIDS.InOut
			channel stopCarryBall: InOut
			channel startMoveAwayFromPosition__: NIDS.InOut
			channel startMoveAwayFromPosition: InOut
			channel stopMoveAwayFromPosition__: NIDS.InOut
			channel stopMoveAwayFromPosition: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startCarryBallOnBallPlacement,
				stopCarryBallOnBallPlacement,
				startGoToBehindBall,
				stopGoToBehindBall,
				startApproachBall,
				stopApproachBall,
				startCarryBall,
				stopCarryBall,
				startMoveAwayFromPosition,
				stopMoveAwayFromPosition
				|}
		
			-- Nodes --
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: sInitial
			module sInitial
			exports
			
				channel enter, interrupt
				
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Final state: sFinal
			module sFinal
			
			exports
			
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
				--	Rule: behaviours(Node)
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
						
						Entering 	= entered -> SKIP ; Active
						Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
						Interrupted	= share__choice(exit -> exited -> Inactive)
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sWaitStart
			module sWaitStart
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--	Nodes
				-- declaring all nodes
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sRun
			module sRun
			
			enterSS = 
					{|			sInitial::enter,
						sGoToBehindBall::enter,
						sGiveSpaceToGetBall::enter,
						sApproachBall::enter,
						sPlaceBall::enter,
						sMoveAwayFromBall::enter,
						sFinal::enter
					|}
			enteredSS = 
					{|			sGoToBehindBall::entered,
						sGiveSpaceToGetBall::entered,
						sApproachBall::entered,
						sPlaceBall::entered,
						sMoveAwayFromBall::entered,
						sFinal::entered
					|}
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_sInitial|
				              NID_sGoToBehindBall|
				              NID_sGiveSpaceToGetBall|
				              NID_sApproachBall|
				              NID_sPlaceBall|
				              NID_sMoveAwayFromBall|
				              NID_sFinal
				
				channel internal__ : NIDS
				channel startCarryBallOnBallPlacement__: NIDS.InOut
				channel stopCarryBallOnBallPlacement__: NIDS.InOut
				channel startGoToBehindBall__: NIDS.InOut
				channel stopGoToBehindBall__: NIDS.InOut
				channel startApproachBall__: NIDS.InOut
				channel stopApproachBall__: NIDS.InOut
				channel startCarryBall__: NIDS.InOut
				channel stopCarryBall__: NIDS.InOut
				channel startMoveAwayFromPosition__: NIDS.InOut
				channel stopMoveAwayFromPosition__: NIDS.InOut
				
				--	Nodes
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sGoToBehindBall
				module sGoToBehindBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sGiveSpaceToGetBall
				module sGiveSpaceToGetBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sApproachBall
				module sApproachBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sPlaceBall
				module sPlaceBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sMoveAwayFromBall
				module sMoveAwayFromBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sGoToBehindBall::enter,
						 	sGiveSpaceToGetBall::enter,
						 	sApproachBall::enter,
						 	sPlaceBall::enter,
						 	sMoveAwayFromBall::enter,
						 	sFinal::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sGoToBehindBall::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sGiveSpaceToGetBall::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sApproachBall::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sPlaceBall::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sMoveAwayFromBall::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sFinal::D__(id__)
						 		   )
						 		   )
						 		   )
						 		   )
						 		   )
						 		   )
						 		 )
						 		 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
						 		 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
						 		 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
						 		 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
						 		 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_nodeStatus
						 		 			,setL_robotHasMovedAwayFromBall
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
						 		 )
						 		)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
						 		stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
						 		startGoToBehindBall__.x____ <- startGoToBehindBall,
						 		stopGoToBehindBall__.x____ <- stopGoToBehindBall,
						 		startApproachBall__.x____ <- startApproachBall,
						 		stopApproachBall__.x____ <- stopApproachBall,
						 		startCarryBall__.x____ <- startCarryBall,
						 		stopCarryBall__.x____ <- stopCarryBall,
						 		startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
						 		stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotHasMovedAwayFromBall,setR_runningStm |} ]] 
						  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_runningStm <- setL_runningStm]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_nodeStatus
						 			,setL_robotHasMovedAwayFromBall
						 			,setL_runningStm
						 			,setR_nodeStatus
						 			 			,setR_robotHasMovedAwayFromBall
						 			 			,setR_runningStm
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall,setL_runningStm |} ]]
						  [[set_nodeStatus <- setR_nodeStatus,set_robotHasMovedAwayFromBall <- setR_robotHasMovedAwayFromBall,set_runningStm <- setR_runningStm]]
						 )
						)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_runningStm <- set_runningStm]]
						 [[setR_nodeStatus <- set_nodeStatus,setR_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setR_runningStm <- set_runningStm]]
						)\union(enteredSS,{terminate}) 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sGoToBehindBall::enter,
						 	sGiveSpaceToGetBall::enter,
						 	sApproachBall::enter,
						 	sPlaceBall::enter,
						 	sMoveAwayFromBall::enter,
						 	sFinal::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sGoToBehindBall::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sGiveSpaceToGetBall::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sApproachBall::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sPlaceBall::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sMoveAwayFromBall::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sFinal::VS_O__(id__)
						 		   )
						 		   )
						 		   )
						 		   )
						 		   )
						 		   )
						 		 )
						 		 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
						 		 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
						 		 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
						 		 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
						 		 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_nodeStatus
						 		 			,setL_robotHasMovedAwayFromBall
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
						 		 )
						 		)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
						 		stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
						 		startGoToBehindBall__.x____ <- startGoToBehindBall,
						 		stopGoToBehindBall__.x____ <- stopGoToBehindBall,
						 		startApproachBall__.x____ <- startApproachBall,
						 		stopApproachBall__.x____ <- stopApproachBall,
						 		startCarryBall__.x____ <- startCarryBall,
						 		stopCarryBall__.x____ <- stopCarryBall,
						 		startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
						 		stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotHasMovedAwayFromBall,setR_runningStm |} ]] 
						  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_runningStm <- setL_runningStm]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_nodeStatus
						 			,setL_robotHasMovedAwayFromBall
						 			,setL_runningStm
						 			,setR_nodeStatus
						 			 			,setR_robotHasMovedAwayFromBall
						 			 			,setR_runningStm
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall,setL_runningStm |} ]]
						  [[set_nodeStatus <- setR_nodeStatus,set_robotHasMovedAwayFromBall <- setR_robotHasMovedAwayFromBall,set_runningStm <- setR_runningStm]]
						 )
						)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_runningStm <- set_runningStm]]
						 [[setR_nodeStatus <- set_nodeStatus,setR_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setR_runningStm <- set_runningStm]]
						)\{terminate} 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
				
				Transitions(id__) = ((let
					Trans = share__choice(get_nodeStatus?nodeStatus -> get_robotHasMovedAwayFromBall?robotHasMovedAwayFromBall -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP))))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(startApproachBall.out -> SKIP)) ; sApproachBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(startCarryBall.out -> SKIP)) ; sPlaceBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(startMoveAwayFromPosition.out -> SKIP)) ; sMoveAwayFromBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(startMoveAwayFromPosition.out -> SKIP)) ; sGiveSpaceToGetBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP)) ; sFinal::enter -> SKIP)))
						 	 [] dbisim((robotHasMovedAwayFromBall)&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sApproachBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sPlaceBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sMoveAwayFromBall::enter -> SKIP)))
						 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGiveSpaceToGetBall::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
			
			endmodule
			----------------------------------------------------------------------
			
			-- END of Nodes --
			
			-- Operation calls --
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machine module.
			
			-- END of Operation calls --
			
			-- STM processes
			STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			-- Transitions
			Transitions(id__) = ((let
				Trans = (
					((share__ -> SKIP
					 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
					 	 [] dbisim((true)&(startCarryBallOnBallPlacement__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
					 	 [] dbisim((true)&(stopCarryBallOnBallPlacement__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP)));true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
					 ) ; Trans)
					 []
					 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
					 []
					 terminate -> SKIP
				)
			within
				Trans
			)
			)
			
			-- Stateful
			-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
			
			-- Named process definitions
			MachineBody(id__) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startCarryBallOnBallPlacement__.NID_sWaitStart.in,stopCarryBallOnBallPlacement__.NID_sRun.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::D__(id__)
							   [| { share__, terminate } |] (
							   sFinal::D__(id__)
							   [| { share__, terminate } |] (
							   sWaitStart::D__(id__)
							   [| { share__, terminate } |] (
							   sRun::D__(id__)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBallOnBallPlacement__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,stopCarryBallOnBallPlacement__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__ |} ]]
							 )
							)
							)
						)
						 \ hideSet)
						[[
							startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
							stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
							startGoToBehindBall__.x____ <- startGoToBehindBall,
							stopGoToBehindBall__.x____ <- stopGoToBehindBall,
							startApproachBall__.x____ <- startApproachBall,
							stopApproachBall__.x____ <- stopApproachBall,
							startCarryBall__.x____ <- startCarryBall,
							stopCarryBall__.x____ <- stopCarryBall,
							startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
							stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			IteratedBehaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			Stateful(id__) = 
				((
					(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								Behaviour(id__)
								[| {|get_runningStm,set_runningStm,terminate|} |]
								Memory_runningStm("")
							)\{|get_runningStm,set_runningStm|}
						)
						[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
						Memory_robotHasMovedAwayFromBall(true)
					)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
				)
				)
			
			-- Visible counterparts
			MachineBody_VS_O(id__) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startCarryBallOnBallPlacement__.NID_sWaitStart.in,stopCarryBallOnBallPlacement__.NID_sRun.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sFinal::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sWaitStart::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sRun::VS_O__(id__)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBallOnBallPlacement__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,stopCarryBallOnBallPlacement__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__ |} ]]
							 )
							)
							)
						)
						 \ hideSet)
						[[
							startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
							stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
							startGoToBehindBall__.x____ <- startGoToBehindBall,
							stopGoToBehindBall__.x____ <- stopGoToBehindBall,
							startApproachBall__.x____ <- startApproachBall,
							stopApproachBall__.x____ <- stopApproachBall,
							startCarryBall__.x____ <- startCarryBall,
							stopCarryBall__.x____ <- stopCarryBall,
							startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
							stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			IteratedBehaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			Stateful_VS_O(id__) = 
				dbisim((
					(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful_VS_O(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								Behaviour_VS_O(id__)
								[| {|get_runningStm,set_runningStm,terminate|} |]
								Memory_runningStm("")
							)\{|get_runningStm,set_runningStm|}
						)
						[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
						Memory_robotHasMovedAwayFromBall(true)
					)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
				)
				)
			
			-- END
			
			-- Memory
			-- Memory variables
			Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall) =
				get_robotHasMovedAwayFromBall!robotHasMovedAwayFromBall -> Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall)
				[]
				set_robotHasMovedAwayFromBall?x__ -> Memory_robotHasMovedAwayFromBall(x__)
				[]
				terminate -> SKIP
			Memory_runningStm(runningStm) =
				get_runningStm!runningStm -> Memory_runningStm(runningStm)
				[]
				set_runningStm?x__ -> Memory_runningStm(x__)
				[]
				terminate -> SKIP
			
			-- varMemory process
			varMemory(id__) = Memory_robotHasMovedAwayFromBall(true)
			[| { terminate } |] (
			Memory_runningStm("")
			)
			
			getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,get_runningStm,set_runningStm|}
			
			-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			FVS__(id__) = STM_VS_O(id__)
			
			D__(id__) = STM(id__) \ internal_events
			O__(id__) = sbisim(diamond(D__(id__)))
			VS__(id__) = FVS__(id__)
			VS_O__(id__) = sbisim(diamond(FVS__(id__)))
			HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
			HUP__(id__) = O__(id__) [|{share__}|] SKIP
			
			-- Shared memory
			-- Shared memory variables
			Memory_nodeStatus(nodeStatus) =
				get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
				[]
				set_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				terminate -> SKIP
			
			-- sharedVarMemory process
			sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
			
			sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
			
			sharedVarHide = {|get_nodeStatus|}
		endmodule
		module stm_go_to_behind_ball_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyIsBehindBall, set_allyIsBehindBall, setL_allyIsBehindBall, setR_allyIsBehindBall: core_boolean
			channel get_allyIsCloseToBall, set_allyIsCloseToBall, setL_allyIsCloseToBall, setR_allyIsCloseToBall: core_boolean
			channel get_allyIsPushingBallWithHisBack, set_allyIsPushingBallWithHisBack, setL_allyIsPushingBallWithHisBack, setR_allyIsPushingBallWithHisBack: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startGoToBehindBall__: NIDS.InOut
			channel startGoToBehindBall: InOut
			channel stopGoToBehindBall__: NIDS.InOut
			channel stopGoToBehindBall: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startGoToBehindBall,
				stopGoToBehindBall
				|}
		
			-- Nodes --
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: sInitial
			module sInitial
			exports
			
				channel enter, interrupt
				
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Final state: sFinal
			module sFinal
			
			exports
			
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
				--	Rule: behaviours(Node)
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
						
						Entering 	= entered -> SKIP ; Active
						Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
						Interrupted	= share__choice(exit -> exited -> Inactive)
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sWaitStart
			module sWaitStart
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--	Nodes
				-- declaring all nodes
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sRun
			module sRun
			
			enterSS = 
					{|			sInitial::enter,
						sFinal::enter,
						sGoToBehindBall::enter
					|}
			enteredSS = 
					{|			sFinal::entered,
						sGoToBehindBall::entered
					|}
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_sInitial|
				              NID_sFinal|
				              NID_sGoToBehindBall
				
				channel internal__ : NIDS
				channel startGoToBehindBall__: NIDS.InOut
				channel stopGoToBehindBall__: NIDS.InOut
				
				--	Nodes
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sGoToBehindBall
				module sGoToBehindBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sFinal::enter,
						 	sGoToBehindBall::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sFinal::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sGoToBehindBall::D__(id__)
						 		   )
						 		   )
						 		 )
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_allyIsBehindBall
						 		 			,setL_allyIsCloseToBall
						 		 			,setL_allyIsPushingBallWithHisBack
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsBehindBall,setL_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack |} ]]
						 		 )
						 		)[[setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startGoToBehindBall__.x____ <- startGoToBehindBall,
						 		stopGoToBehindBall__.x____ <- stopGoToBehindBall
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_allyIsBehindBall,setR_allyIsCloseToBall,setR_allyIsPushingBallWithHisBack |} ]] 
						  [[set_nodeStatus <- setL_nodeStatus,set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_nodeStatus
						 			,setL_allyIsBehindBall
						 			,setL_allyIsCloseToBall
						 			,setL_allyIsPushingBallWithHisBack
						 			,setR_nodeStatus
						 			 			,setR_allyIsBehindBall
						 			 			,setR_allyIsCloseToBall
						 			 			,setR_allyIsPushingBallWithHisBack
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_allyIsBehindBall,setL_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack |} ]]
						  [[set_nodeStatus <- setR_nodeStatus,set_allyIsBehindBall <- setR_allyIsBehindBall,set_allyIsCloseToBall <- setR_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setR_allyIsPushingBallWithHisBack]]
						 )
						)[[setL_nodeStatus <- set_nodeStatus,setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
						 [[setR_nodeStatus <- set_nodeStatus,setR_allyIsBehindBall <- set_allyIsBehindBall,setR_allyIsCloseToBall <- set_allyIsCloseToBall,setR_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
						)\union(enteredSS,{terminate}) 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sFinal::enter,
						 	sGoToBehindBall::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sFinal::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sGoToBehindBall::VS_O__(id__)
						 		   )
						 		   )
						 		 )
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_allyIsBehindBall
						 		 			,setL_allyIsCloseToBall
						 		 			,setL_allyIsPushingBallWithHisBack
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsBehindBall,setL_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack |} ]]
						 		 )
						 		)[[setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startGoToBehindBall__.x____ <- startGoToBehindBall,
						 		stopGoToBehindBall__.x____ <- stopGoToBehindBall
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_allyIsBehindBall,setR_allyIsCloseToBall,setR_allyIsPushingBallWithHisBack |} ]] 
						  [[set_nodeStatus <- setL_nodeStatus,set_allyIsBehindBall <- setL_allyIsBehindBall,set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setL_allyIsPushingBallWithHisBack]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_nodeStatus
						 			,setL_allyIsBehindBall
						 			,setL_allyIsCloseToBall
						 			,setL_allyIsPushingBallWithHisBack
						 			,setR_nodeStatus
						 			 			,setR_allyIsBehindBall
						 			 			,setR_allyIsCloseToBall
						 			 			,setR_allyIsPushingBallWithHisBack
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_allyIsBehindBall,setL_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack |} ]]
						  [[set_nodeStatus <- setR_nodeStatus,set_allyIsBehindBall <- setR_allyIsBehindBall,set_allyIsCloseToBall <- setR_allyIsCloseToBall,set_allyIsPushingBallWithHisBack <- setR_allyIsPushingBallWithHisBack]]
						 )
						)[[setL_nodeStatus <- set_nodeStatus,setL_allyIsBehindBall <- set_allyIsBehindBall,setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
						 [[setR_nodeStatus <- set_nodeStatus,setR_allyIsBehindBall <- set_allyIsBehindBall,setR_allyIsCloseToBall <- set_allyIsCloseToBall,setR_allyIsPushingBallWithHisBack <- set_allyIsPushingBallWithHisBack]]
						)\{terminate} 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
				
				Transitions(id__) = ((let
					Trans = share__choice(get_allyIsBehindBall?allyIsBehindBall -> get_allyIsCloseToBall?allyIsCloseToBall -> get_allyIsPushingBallWithHisBack?allyIsPushingBallWithHisBack -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sGoToBehindBall::enter -> SKIP))))
						 	 [] dbisim((((allyIsBehindBall and allyIsCloseToBall)))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 	 [] dbisim((((not (((allyIsBehindBall and allyIsCloseToBall)))) and (not (allyIsPushingBallWithHisBack))))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sGoToBehindBall::enter -> SKIP)))
						 	 [] dbisim((allyIsPushingBallWithHisBack)&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
			
			endmodule
			----------------------------------------------------------------------
			
			-- END of Nodes --
			
			-- Operation calls --
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machine module.
			
			-- END of Operation calls --
			
			-- STM processes
			STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			-- Transitions
			Transitions(id__) = ((let
				Trans = share__choice(get_nodeStatus?nodeStatus -> (
					((share__ -> SKIP
					 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
					 	 [] dbisim((true)&(startGoToBehindBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
					 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
					 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
					 	 [] dbisim((true)&(stopGoToBehindBall__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
					 	 [] dbisim((true)&(stopGoToBehindBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
					 ) ; Trans)
					 []
					 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
					 []
					 terminate -> SKIP
				)
				)
			within
				Trans
			)
			)
			
			-- Stateful
			-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
			
			-- Named process definitions
			MachineBody(id__) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startGoToBehindBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopGoToBehindBall__.NID_sRun.in,stopGoToBehindBall__.NID_sWaitStart.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::D__(id__)
							   [| { share__, terminate } |] (
							   sFinal::D__(id__)
							   [| { share__, terminate } |] (
							   sWaitStart::D__(id__)
							   [| { share__, terminate } |] (
							   sRun::D__(id__)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startGoToBehindBall__.NID_sWaitStart.in,stopGoToBehindBall__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopGoToBehindBall__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_nodeStatus <- setL_nodeStatus]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_nodeStatus
							|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
							 )
							)[[setL_nodeStatus <- set_nodeStatus]]
							)
						)
						 \ hideSet)
						[[
							startGoToBehindBall__.x____ <- startGoToBehindBall,
							stopGoToBehindBall__.x____ <- stopGoToBehindBall
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			IteratedBehaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			Stateful(id__) = 
				((
					(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										Behaviour(id__)
										[| {|get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack,terminate|} |]
										Memory_allyIsPushingBallWithHisBack(true)
									)\{|get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
								)
								[| {|get_allyIsCloseToBall,set_allyIsCloseToBall,terminate|} |]
								Memory_allyIsCloseToBall(true)
							)\{|get_allyIsCloseToBall,set_allyIsCloseToBall|}
						)
						[| {|get_allyIsBehindBall,set_allyIsBehindBall,terminate|} |]
						Memory_allyIsBehindBall(true)
					)\{|get_allyIsBehindBall,set_allyIsBehindBall|}
				)
				)
			
			-- Visible counterparts
			MachineBody_VS_O(id__) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startGoToBehindBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopGoToBehindBall__.NID_sRun.in,stopGoToBehindBall__.NID_sWaitStart.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sFinal::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sWaitStart::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sRun::VS_O__(id__)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startGoToBehindBall__.NID_sWaitStart.in,stopGoToBehindBall__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopGoToBehindBall__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_nodeStatus <- setL_nodeStatus]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_nodeStatus
							|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
							 )
							)[[setL_nodeStatus <- set_nodeStatus]]
							)
						)
						 \ hideSet)
						[[
							startGoToBehindBall__.x____ <- startGoToBehindBall,
							stopGoToBehindBall__.x____ <- stopGoToBehindBall
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			IteratedBehaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			Stateful_VS_O(id__) = 
				dbisim((
					(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful_VS_O(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										Behaviour_VS_O(id__)
										[| {|get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack,terminate|} |]
										Memory_allyIsPushingBallWithHisBack(true)
									)\{|get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
								)
								[| {|get_allyIsCloseToBall,set_allyIsCloseToBall,terminate|} |]
								Memory_allyIsCloseToBall(true)
							)\{|get_allyIsCloseToBall,set_allyIsCloseToBall|}
						)
						[| {|get_allyIsBehindBall,set_allyIsBehindBall,terminate|} |]
						Memory_allyIsBehindBall(true)
					)\{|get_allyIsBehindBall,set_allyIsBehindBall|}
				)
				)
			
			-- END
			
			-- Memory
			-- Memory variables
			Memory_allyIsBehindBall(allyIsBehindBall) =
				get_allyIsBehindBall!allyIsBehindBall -> Memory_allyIsBehindBall(allyIsBehindBall)
				[]
				set_allyIsBehindBall?x__ -> Memory_allyIsBehindBall(x__)
				[]
				terminate -> SKIP
			Memory_allyIsCloseToBall(allyIsCloseToBall) =
				get_allyIsCloseToBall!allyIsCloseToBall -> Memory_allyIsCloseToBall(allyIsCloseToBall)
				[]
				set_allyIsCloseToBall?x__ -> Memory_allyIsCloseToBall(x__)
				[]
				terminate -> SKIP
			Memory_allyIsPushingBallWithHisBack(allyIsPushingBallWithHisBack) =
				get_allyIsPushingBallWithHisBack!allyIsPushingBallWithHisBack -> Memory_allyIsPushingBallWithHisBack(allyIsPushingBallWithHisBack)
				[]
				set_allyIsPushingBallWithHisBack?x__ -> Memory_allyIsPushingBallWithHisBack(x__)
				[]
				terminate -> SKIP
			
			-- varMemory process
			varMemory(id__) = Memory_allyIsBehindBall(true)
			[| { terminate } |] (
			Memory_allyIsCloseToBall(true)
			[| { terminate } |] (
			Memory_allyIsPushingBallWithHisBack(true)
			)
			)
			
			getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,get_allyIsCloseToBall,set_allyIsCloseToBall,get_allyIsPushingBallWithHisBack,set_allyIsPushingBallWithHisBack|}
			
			-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			FVS__(id__) = STM_VS_O(id__)
			
			D__(id__) = STM(id__) \ internal_events
			O__(id__) = sbisim(diamond(D__(id__)))
			VS__(id__) = FVS__(id__)
			VS_O__(id__) = sbisim(diamond(FVS__(id__)))
			HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
			HUP__(id__) = O__(id__) [|{share__}|] SKIP
			
			-- Shared memory
			-- Shared memory variables
			Memory_nodeStatus(nodeStatus) =
				get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
				[]
				set_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				terminate -> SKIP
			
			-- sharedVarMemory process
			sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
			
			sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
			
			sharedVarHide = {|get_nodeStatus|}
		endmodule
		module stm_approach_ball_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyIsBehindBall, set_allyIsBehindBall, setL_allyIsBehindBall, setR_allyIsBehindBall: core_boolean
			channel get_allyIsCloseToBall, set_allyIsCloseToBall, setL_allyIsCloseToBall, setR_allyIsCloseToBall: core_boolean
			channel get_allyHasBall, set_allyHasBall, setL_allyHasBall, setR_allyHasBall: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startApproachBall__: NIDS.InOut
			channel startApproachBall: InOut
			channel stopApproachBall__: NIDS.InOut
			channel stopApproachBall: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startApproachBall,
				stopApproachBall
				|}
		
			-- Nodes --
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: sInitial
			module sInitial
			exports
			
				channel enter, interrupt
				
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Final state: sFinal
			module sFinal
			
			exports
			
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
				--	Rule: behaviours(Node)
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
						
						Entering 	= entered -> SKIP ; Active
						Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
						Interrupted	= share__choice(exit -> exited -> Inactive)
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sWaitStart
			module sWaitStart
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--	Nodes
				-- declaring all nodes
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sRun
			module sRun
			
			enterSS = 
					{|			sInitial::enter,
						sFinal::enter,
						sApproach::enter
					|}
			enteredSS = 
					{|			sFinal::entered,
						sApproach::entered
					|}
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_sInitial|
				              NID_sFinal|
				              NID_sApproach
				
				channel internal__ : NIDS
				channel startApproachBall__: NIDS.InOut
				channel stopApproachBall__: NIDS.InOut
				
				--	Nodes
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sApproach
				module sApproach
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sFinal::enter,
						 	sApproach::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sFinal::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sApproach::D__(id__)
						 		   )
						 		   )
						 		 )
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sApproach::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_allyIsCloseToBall
						 		 			,setL_allyHasBall
						 		 			,setL_allyIsBehindBall
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_allyHasBall,setL_allyIsBehindBall |} ]]
						 		 )
						 		)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startApproachBall__.x____ <- startApproachBall,
						 		stopApproachBall__.x____ <- stopApproachBall
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_allyIsCloseToBall,setR_nodeStatus,setR_allyHasBall,setR_allyIsBehindBall |} ]] 
						  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_nodeStatus <- setL_nodeStatus,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_allyIsCloseToBall
						 			,setL_nodeStatus
						 			,setL_allyHasBall
						 			,setL_allyIsBehindBall
						 			,setR_allyIsCloseToBall
						 			 			,setR_nodeStatus
						 			 			,setR_allyHasBall
						 			 			,setR_allyIsBehindBall
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_nodeStatus,setL_allyHasBall,setL_allyIsBehindBall |} ]]
						  [[set_allyIsCloseToBall <- setR_allyIsCloseToBall,set_nodeStatus <- setR_nodeStatus,set_allyHasBall <- setR_allyHasBall,set_allyIsBehindBall <- setR_allyIsBehindBall]]
						 )
						)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_nodeStatus <- set_nodeStatus,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
						 [[setR_allyIsCloseToBall <- set_allyIsCloseToBall,setR_nodeStatus <- set_nodeStatus,setR_allyHasBall <- set_allyHasBall,setR_allyIsBehindBall <- set_allyIsBehindBall]]
						)\union(enteredSS,{terminate}) 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sFinal::enter,
						 	sApproach::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sFinal::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sApproach::VS_O__(id__)
						 		   )
						 		   )
						 		 )
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sApproach::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproach,internal__.NID_sApproach,internal__.NID_sApproach|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_allyIsCloseToBall
						 		 			,setL_allyHasBall
						 		 			,setL_allyIsBehindBall
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_allyHasBall,setL_allyIsBehindBall |} ]]
						 		 )
						 		)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startApproachBall__.x____ <- startApproachBall,
						 		stopApproachBall__.x____ <- stopApproachBall
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_allyIsCloseToBall,setR_nodeStatus,setR_allyHasBall,setR_allyIsBehindBall |} ]] 
						  [[set_allyIsCloseToBall <- setL_allyIsCloseToBall,set_nodeStatus <- setL_nodeStatus,set_allyHasBall <- setL_allyHasBall,set_allyIsBehindBall <- setL_allyIsBehindBall]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_allyIsCloseToBall
						 			,setL_nodeStatus
						 			,setL_allyHasBall
						 			,setL_allyIsBehindBall
						 			,setR_allyIsCloseToBall
						 			 			,setR_nodeStatus
						 			 			,setR_allyHasBall
						 			 			,setR_allyIsBehindBall
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_allyIsCloseToBall,setL_nodeStatus,setL_allyHasBall,setL_allyIsBehindBall |} ]]
						  [[set_allyIsCloseToBall <- setR_allyIsCloseToBall,set_nodeStatus <- setR_nodeStatus,set_allyHasBall <- setR_allyHasBall,set_allyIsBehindBall <- setR_allyIsBehindBall]]
						 )
						)[[setL_allyIsCloseToBall <- set_allyIsCloseToBall,setL_nodeStatus <- set_nodeStatus,setL_allyHasBall <- set_allyHasBall,setL_allyIsBehindBall <- set_allyIsBehindBall]]
						 [[setR_allyIsCloseToBall <- set_allyIsCloseToBall,setR_nodeStatus <- set_nodeStatus,setR_allyHasBall <- set_allyHasBall,setR_allyIsBehindBall <- set_allyIsBehindBall]]
						)\{terminate} 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
				
				Transitions(id__) = ((let
					Trans = share__choice(get_allyIsCloseToBall?allyIsCloseToBall -> get_allyHasBall?allyHasBall -> get_allyIsBehindBall?allyIsBehindBall -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sApproach::enter -> SKIP))))
						 	 [] dbisim((allyHasBall)&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 	 [] dbisim(((((not (allyIsBehindBall)) or (not (allyIsCloseToBall)))))&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
						 	 [] dbisim(((((not (allyHasBall))) and (not ((((not (allyIsBehindBall)) or (not (allyIsCloseToBall))))))))&(internal__!NID_sApproach -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sApproach::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
			
			endmodule
			----------------------------------------------------------------------
			
			-- END of Nodes --
			
			-- Operation calls --
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machine module.
			
			-- END of Operation calls --
			
			-- STM processes
			STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			-- Transitions
			Transitions(id__) = ((let
				Trans = share__choice(get_nodeStatus?nodeStatus -> (
					((share__ -> SKIP
					 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
					 	 [] dbisim((true)&(startApproachBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
					 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
					 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
					 	 [] dbisim((true)&(stopApproachBall__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
					 	 [] dbisim((true)&(stopApproachBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
					 ) ; Trans)
					 []
					 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
					 []
					 terminate -> SKIP
				)
				)
			within
				Trans
			)
			)
			
			-- Stateful
			-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
			
			-- Named process definitions
			MachineBody(id__) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startApproachBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopApproachBall__.NID_sRun.in,stopApproachBall__.NID_sWaitStart.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::D__(id__)
							   [| { share__, terminate } |] (
							   sFinal::D__(id__)
							   [| { share__, terminate } |] (
							   sWaitStart::D__(id__)
							   [| { share__, terminate } |] (
							   sRun::D__(id__)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startApproachBall__.NID_sWaitStart.in,stopApproachBall__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopApproachBall__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_nodeStatus <- setL_nodeStatus]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_nodeStatus
							|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
							 )
							)[[setL_nodeStatus <- set_nodeStatus]]
							)
						)
						 \ hideSet)
						[[
							startApproachBall__.x____ <- startApproachBall,
							stopApproachBall__.x____ <- stopApproachBall
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			IteratedBehaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			Stateful(id__) = 
				((
					(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										Behaviour(id__)
										[| {|get_allyHasBall,set_allyHasBall,terminate|} |]
										Memory_allyHasBall(true)
									)\{|get_allyHasBall,set_allyHasBall|}
								)
								[| {|get_allyIsCloseToBall,set_allyIsCloseToBall,terminate|} |]
								Memory_allyIsCloseToBall(true)
							)\{|get_allyIsCloseToBall,set_allyIsCloseToBall|}
						)
						[| {|get_allyIsBehindBall,set_allyIsBehindBall,terminate|} |]
						Memory_allyIsBehindBall(true)
					)\{|get_allyIsBehindBall,set_allyIsBehindBall|}
				)
				)
			
			-- Visible counterparts
			MachineBody_VS_O(id__) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startApproachBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopApproachBall__.NID_sRun.in,stopApproachBall__.NID_sWaitStart.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sFinal::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sWaitStart::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sRun::VS_O__(id__)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startApproachBall__.NID_sWaitStart.in,stopApproachBall__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopApproachBall__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_nodeStatus <- setL_nodeStatus]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_nodeStatus
							|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
							 )
							)[[setL_nodeStatus <- set_nodeStatus]]
							)
						)
						 \ hideSet)
						[[
							startApproachBall__.x____ <- startApproachBall,
							stopApproachBall__.x____ <- stopApproachBall
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			IteratedBehaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			Stateful_VS_O(id__) = 
				dbisim((
					(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful_VS_O(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										Behaviour_VS_O(id__)
										[| {|get_allyHasBall,set_allyHasBall,terminate|} |]
										Memory_allyHasBall(true)
									)\{|get_allyHasBall,set_allyHasBall|}
								)
								[| {|get_allyIsCloseToBall,set_allyIsCloseToBall,terminate|} |]
								Memory_allyIsCloseToBall(true)
							)\{|get_allyIsCloseToBall,set_allyIsCloseToBall|}
						)
						[| {|get_allyIsBehindBall,set_allyIsBehindBall,terminate|} |]
						Memory_allyIsBehindBall(true)
					)\{|get_allyIsBehindBall,set_allyIsBehindBall|}
				)
				)
			
			-- END
			
			-- Memory
			-- Memory variables
			Memory_allyIsBehindBall(allyIsBehindBall) =
				get_allyIsBehindBall!allyIsBehindBall -> Memory_allyIsBehindBall(allyIsBehindBall)
				[]
				set_allyIsBehindBall?x__ -> Memory_allyIsBehindBall(x__)
				[]
				terminate -> SKIP
			Memory_allyIsCloseToBall(allyIsCloseToBall) =
				get_allyIsCloseToBall!allyIsCloseToBall -> Memory_allyIsCloseToBall(allyIsCloseToBall)
				[]
				set_allyIsCloseToBall?x__ -> Memory_allyIsCloseToBall(x__)
				[]
				terminate -> SKIP
			Memory_allyHasBall(allyHasBall) =
				get_allyHasBall!allyHasBall -> Memory_allyHasBall(allyHasBall)
				[]
				set_allyHasBall?x__ -> Memory_allyHasBall(x__)
				[]
				terminate -> SKIP
			
			-- varMemory process
			varMemory(id__) = Memory_allyIsBehindBall(true)
			[| { terminate } |] (
			Memory_allyIsCloseToBall(true)
			[| { terminate } |] (
			Memory_allyHasBall(true)
			)
			)
			
			getsetLocalChannels = {|get_allyIsBehindBall,set_allyIsBehindBall,get_allyIsCloseToBall,set_allyIsCloseToBall,get_allyHasBall,set_allyHasBall|}
			
			-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			FVS__(id__) = STM_VS_O(id__)
			
			D__(id__) = STM(id__) \ internal_events
			O__(id__) = sbisim(diamond(D__(id__)))
			VS__(id__) = FVS__(id__)
			VS_O__(id__) = sbisim(diamond(FVS__(id__)))
			HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
			HUP__(id__) = O__(id__) [|{share__}|] SKIP
			
			-- Shared memory
			-- Shared memory variables
			Memory_nodeStatus(nodeStatus) =
				get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
				[]
				set_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				terminate -> SKIP
			
			-- sharedVarMemory process
			sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
			
			sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
			
			sharedVarHide = {|get_nodeStatus|}
		endmodule
		module stm_carry_ball_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_allyHasBall, set_allyHasBall, setL_allyHasBall, setR_allyHasBall: core_boolean
			channel get_ballIsPositioned, set_ballIsPositioned, setL_ballIsPositioned, setR_ballIsPositioned: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startCarryBall__: NIDS.InOut
			channel startCarryBall: InOut
			channel stopCarryBall__: NIDS.InOut
			channel stopCarryBall: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startCarryBall,
				stopCarryBall
				|}
		
			-- Nodes --
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: sInitial
			module sInitial
			exports
			
				channel enter, interrupt
				
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Final state: sFinal
			module sFinal
			
			exports
			
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
				--	Rule: behaviours(Node)
				D__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
						
						Entering 	= entered -> SKIP ; Active
						Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
						Interrupted	= share__choice(exit -> exited -> Inactive)
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = D__(id__)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sWaitStart
			module sWaitStart
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--	Nodes
				-- declaring all nodes
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sRun
			module sRun
			
			enterSS = 
					{|			sInitial::enter,
						sFinal::enter,
						sCarryBall::enter
					|}
			enteredSS = 
					{|			sFinal::entered,
						sCarryBall::entered
					|}
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_sInitial|
				              NID_sFinal|
				              NID_sCarryBall
				
				channel internal__ : NIDS
				channel startCarryBall__: NIDS.InOut
				channel stopCarryBall__: NIDS.InOut
				
				--	Nodes
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = D__(id__)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sCarryBall
				module sCarryBall
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sFinal::enter,
						 	sCarryBall::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sFinal::D__(id__)
						 		   [| { share__, terminate } |] (
						 		   sCarryBall::D__(id__)
						 		   )
						 		   )
						 		 )
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sCarryBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_ballIsPositioned <- setL_ballIsPositioned,set_allyHasBall <- setL_allyHasBall]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_ballIsPositioned
						 		 			,setL_allyHasBall
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned,setL_allyHasBall |} ]]
						 		 )
						 		)[[setL_ballIsPositioned <- set_ballIsPositioned,setL_allyHasBall <- set_allyHasBall]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startCarryBall__.x____ <- startCarryBall,
						 		stopCarryBall__.x____ <- stopCarryBall
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_ballIsPositioned,setR_nodeStatus,setR_allyHasBall |} ]] 
						  [[set_ballIsPositioned <- setL_ballIsPositioned,set_nodeStatus <- setL_nodeStatus,set_allyHasBall <- setL_allyHasBall]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_ballIsPositioned
						 			,setL_nodeStatus
						 			,setL_allyHasBall
						 			,setR_ballIsPositioned
						 			 			,setR_nodeStatus
						 			 			,setR_allyHasBall
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned,setL_nodeStatus,setL_allyHasBall |} ]]
						  [[set_ballIsPositioned <- setR_ballIsPositioned,set_nodeStatus <- setR_nodeStatus,set_allyHasBall <- setR_allyHasBall]]
						 )
						)[[setL_ballIsPositioned <- set_ballIsPositioned,setL_nodeStatus <- set_nodeStatus,setL_allyHasBall <- set_allyHasBall]]
						 [[setR_ballIsPositioned <- set_ballIsPositioned,setR_nodeStatus <- set_nodeStatus,setR_allyHasBall <- set_allyHasBall]]
						)\union(enteredSS,{terminate}) 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sFinal::enter,
						 	sCarryBall::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sFinal::VS_O__(id__)
						 		   [| { share__, terminate } |] (
						 		   sCarryBall::VS_O__(id__)
						 		   )
						 		   )
						 		 )
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sCarryBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sCarryBall,internal__.NID_sCarryBall,internal__.NID_sCarryBall|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_ballIsPositioned <- setL_ballIsPositioned,set_allyHasBall <- setL_allyHasBall]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_ballIsPositioned
						 		 			,setL_allyHasBall
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned,setL_allyHasBall |} ]]
						 		 )
						 		)[[setL_ballIsPositioned <- set_ballIsPositioned,setL_allyHasBall <- set_allyHasBall]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startCarryBall__.x____ <- startCarryBall,
						 		stopCarryBall__.x____ <- stopCarryBall
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_ballIsPositioned,setR_nodeStatus,setR_allyHasBall |} ]] 
						  [[set_ballIsPositioned <- setL_ballIsPositioned,set_nodeStatus <- setL_nodeStatus,set_allyHasBall <- setL_allyHasBall]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_ballIsPositioned
						 			,setL_nodeStatus
						 			,setL_allyHasBall
						 			,setR_ballIsPositioned
						 			 			,setR_nodeStatus
						 			 			,setR_allyHasBall
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned,setL_nodeStatus,setL_allyHasBall |} ]]
						  [[set_ballIsPositioned <- setR_ballIsPositioned,set_nodeStatus <- setR_nodeStatus,set_allyHasBall <- setR_allyHasBall]]
						 )
						)[[setL_ballIsPositioned <- set_ballIsPositioned,setL_nodeStatus <- set_nodeStatus,setL_allyHasBall <- set_allyHasBall]]
						 [[setR_ballIsPositioned <- set_ballIsPositioned,setR_nodeStatus <- set_nodeStatus,setR_allyHasBall <- set_allyHasBall]]
						)\{terminate} 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
				
				Transitions(id__) = ((let
					Trans = share__choice(get_ballIsPositioned?ballIsPositioned -> get_allyHasBall?allyHasBall -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sCarryBall::enter -> SKIP))))
						 	 [] dbisim((ballIsPositioned)&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 	 [] dbisim(((((not (ballIsPositioned))) and allyHasBall))&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sCarryBall::enter -> SKIP)))
						 	 [] dbisim(((not (allyHasBall)))&(internal__!NID_sCarryBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
			
			endmodule
			----------------------------------------------------------------------
			
			-- END of Nodes --
			
			-- Operation calls --
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machine module.
			
			-- END of Operation calls --
			
			-- STM processes
			STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__))
			)\sharedVarHide
			
			-- Transitions
			Transitions(id__) = ((let
				Trans = share__choice(get_ballIsPositioned?ballIsPositioned -> (
					((share__ -> SKIP
					 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
					 	 [] dbisim((true)&(startCarryBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
					 	 [] dbisim((ballIsPositioned)&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sWaitStart::enter -> SKIP)))
					 	 [] dbisim((true)&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sWaitStart::enter -> SKIP)))
					 	 [] dbisim((true)&(stopCarryBall__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
					 	 [] dbisim((true)&(stopCarryBall__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
					 ) ; Trans)
					 []
					 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
					 []
					 terminate -> SKIP
				)
				)
			within
				Trans
			)
			)
			
			-- Stateful
			-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
			
			-- Named process definitions
			MachineBody(id__) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startCarryBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopCarryBall__.NID_sWaitStart.in,stopCarryBall__.NID_sRun.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::D__(id__)
							   [| { share__, terminate } |] (
							   sFinal::D__(id__)
							   [| { share__, terminate } |] (
							   sWaitStart::D__(id__)
							   [| { share__, terminate } |] (
							   sRun::D__(id__)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBall__.NID_sWaitStart.in,stopCarryBall__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopCarryBall__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_ballIsPositioned <- setL_ballIsPositioned]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_ballIsPositioned
							|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned |} ]]
							 )
							)[[setL_ballIsPositioned <- set_ballIsPositioned]]
							)
						)
						 \ hideSet)
						[[
							startCarryBall__.x____ <- startCarryBall,
							stopCarryBall__.x____ <- stopCarryBall
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			IteratedBehaviour(id__) = 
				dbisim((MachineBody(id__)\ enteredSS)
				)
			
			Stateful(id__) = 
				((
					(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								Behaviour(id__)
								[| {|get_ballIsPositioned,set_ballIsPositioned,terminate|} |]
								Memory_ballIsPositioned(true)
							)\{|get_ballIsPositioned,set_ballIsPositioned|}
						)
						[| {|get_allyHasBall,set_allyHasBall,terminate|} |]
						Memory_allyHasBall(true)
					)\{|get_allyHasBall,set_allyHasBall|}
				)
				)
			
			-- Visible counterparts
			MachineBody_VS_O(id__) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startCarryBall__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopCarryBall__.NID_sWaitStart.in,stopCarryBall__.NID_sRun.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sFinal::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sWaitStart::VS_O__(id__)
							   [| { share__, terminate } |] (
							   sRun::VS_O__(id__)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBall__.NID_sWaitStart.in,stopCarryBall__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopCarryBall__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_ballIsPositioned <- setL_ballIsPositioned]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_ballIsPositioned
							|}) |]
							 ((sInitial::enter -> Transitions(id__))
							  [[ share__ <- x__ | x__ <- {| share__,setL_ballIsPositioned |} ]]
							 )
							)[[setL_ballIsPositioned <- set_ballIsPositioned]]
							)
						)
						 \ hideSet)
						[[
							startCarryBall__.x____ <- startCarryBall,
							stopCarryBall__.x____ <- stopCarryBall
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			IteratedBehaviour_VS_O(id__) = 
				dbisim((MachineBody_VS_O(id__))
				)
			
			Stateful_VS_O(id__) = 
				dbisim((
					(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful_VS_O(id__) =
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								Behaviour_VS_O(id__)
								[| {|get_ballIsPositioned,set_ballIsPositioned,terminate|} |]
								Memory_ballIsPositioned(true)
							)\{|get_ballIsPositioned,set_ballIsPositioned|}
						)
						[| {|get_allyHasBall,set_allyHasBall,terminate|} |]
						Memory_allyHasBall(true)
					)\{|get_allyHasBall,set_allyHasBall|}
				)
				)
			
			-- END
			
			-- Memory
			-- Memory variables
			Memory_allyHasBall(allyHasBall) =
				get_allyHasBall!allyHasBall -> Memory_allyHasBall(allyHasBall)
				[]
				set_allyHasBall?x__ -> Memory_allyHasBall(x__)
				[]
				terminate -> SKIP
			Memory_ballIsPositioned(ballIsPositioned) =
				get_ballIsPositioned!ballIsPositioned -> Memory_ballIsPositioned(ballIsPositioned)
				[]
				set_ballIsPositioned?x__ -> Memory_ballIsPositioned(x__)
				[]
				terminate -> SKIP
			
			-- varMemory process
			varMemory(id__) = Memory_allyHasBall(true)
			[| { terminate } |] (
			Memory_ballIsPositioned(true)
			)
			
			getsetLocalChannels = {|get_allyHasBall,set_allyHasBall,get_ballIsPositioned,set_ballIsPositioned|}
			
			-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			FVS__(id__) = STM_VS_O(id__)
			
			D__(id__) = STM(id__) \ internal_events
			O__(id__) = sbisim(diamond(D__(id__)))
			VS__(id__) = FVS__(id__)
			VS_O__(id__) = sbisim(diamond(FVS__(id__)))
			HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
			HUP__(id__) = O__(id__) [|{share__}|] SKIP
			
			-- Shared memory
			-- Shared memory variables
			Memory_nodeStatus(nodeStatus) =
				get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
				[]
				set_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				terminate -> SKIP
			
			-- sharedVarMemory process
			sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
			
			sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
			
			sharedVarHide = {|get_nodeStatus|}
		endmodule
		module stm_move_away_ref
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
		
			-- Transition identifiers
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_sInitial|
			              NID_sFinal|
			              NID_sWaitStart|
			              NID_sRun
			
			channel internal__ : NIDS
			
			-- Flow channels		
			channel interrupt
			channel exited
			channel exit
			channel terminate
			
			-- Variable channels
			channel get_robotIsFarEnoughFromPosition, set_robotIsFarEnoughFromPosition, setL_robotIsFarEnoughFromPosition, setR_robotIsFarEnoughFromPosition: core_boolean
			channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
			
			-- Shared variable channels
			channel set_EXT_nodeStatus: NODE_STATUS
			
			-- Local variable channels for defined operations that are required by the state machine
			
			-- Declaring state machine events
			channel startMoveAwayFromPosition__: NIDS.InOut
			channel startMoveAwayFromPosition: InOut
			channel stopMoveAwayFromPosition__: NIDS.InOut
			channel stopMoveAwayFromPosition: InOut
			
			-- Declaring call and ret events for undefined operations
			
			enterSS = {|
			sInitial::enter,
			sFinal::enter,
			sWaitStart::enter,
			sRun::enter
			|}
			
			enteredSS = 	{|
			sFinal::entered,
			sWaitStart::entered,
			sRun::entered
			|}
			
			internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
			
			shared_variable_events = {|
				set_EXT_nodeStatus
			|}
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	set_EXT_nodeStatus, set_nodeStatus
			,	startMoveAwayFromPosition,
				stopMoveAwayFromPosition
				|}
		
			-- Nodes --
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: sInitial
			module sInitial
			exports
			
				channel enter, interrupt
				
				D__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = D__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Final state: sFinal
			module sFinal
			
			exports
			
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
				--	Rule: behaviours(Node)
				D__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
						
						Entering 	= entered -> SKIP ; Active
						Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
						Interrupted	= share__choice(exit -> exited -> Inactive)
					within
						Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = D__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sWaitStart
			module sWaitStart
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--	Nodes
				-- declaring all nodes
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: sRun
			module sRun
			
			enterSS = 
					{|			sInitial::enter,
						sFinal::enter,
						sMoveAway::enter
					|}
			enteredSS = 
					{|			sFinal::entered,
						sMoveAway::entered
					|}
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_sInitial|
				              NID_sFinal|
				              NID_sMoveAway
				
				channel internal__ : NIDS
				channel startMoveAwayFromPosition__: NIDS.InOut
				channel stopMoveAwayFromPosition__: NIDS.InOut
				
				--	Nodes
				-- declaring all nodes
				
				----------------------------------------------------------------------
				-- Initial: sInitial
				module sInitial
				exports
				
					channel enter, interrupt
					
					D__(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = D__(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- Final state: sFinal
				module sFinal
				
				exports
				
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
					--	Rule: behaviours(Node)
					D__(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = D__(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
				
				endmodule
				----------------------------------------------------------------------
				
				
				----------------------------------------------------------------------
				-- State: sMoveAway
				module sMoveAway
				
				enterSS = {}
				
				enteredSS = {}
				
				exports
				
					--  Declarations
					
					channel enter, entered, interrupt
					channel enteredL, enteredR
					
									
					
					--	Nodes
					-- declaring all nodes
					
					
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
				
				endmodule
				----------------------------------------------------------------------
				
				
				
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sFinal::enter,
						 	sMoveAway::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::D__(id__,
						 		   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						 		   [| { share__, terminate } |] (
						 		   sFinal::D__(id__,
						 		   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						 		   [| { share__, terminate } |] (
						 		   sMoveAway::D__(id__,
						 		   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						 		   )
						 		   )
						 		 )
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sMoveAway::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_robotIsFarEnoughFromPosition
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__,
						 		 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_robotIsFarEnoughFromPosition |} ]]
						 		 )
						 		)[[setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
						 		stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotIsFarEnoughFromPosition |} ]] 
						  [[set_nodeStatus <- setL_nodeStatus,set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_nodeStatus
						 			,setL_robotIsFarEnoughFromPosition
						 			,setR_nodeStatus
						 			 			,setR_robotIsFarEnoughFromPosition
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotIsFarEnoughFromPosition |} ]]
						  [[set_nodeStatus <- setR_nodeStatus,set_robotIsFarEnoughFromPosition <- setR_robotIsFarEnoughFromPosition]]
						 )
						)[[setL_nodeStatus <- set_nodeStatus,setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
						 [[setR_nodeStatus <- set_nodeStatus,setR_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
						)\union(enteredSS,{terminate}) 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((let
						 	-- IMPLEMENTATION NOTE:
						 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 	-- modules for defining the semantics of each node.
						 	enterSS = {|
						 	sInitial::enter,
						 	sFinal::enter,
						 	sMoveAway::enter
						 	|}
						 	hideSet = union(enterSS,{|exit,exited,internal__|})
						 within 
						 	((let
						 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 		-- because CSPM modules are used for the semantics of Node.
						 		flowevts = union(enterSS,{|exit,exited,interrupt|})
						 		transSync = {|internal__.NID_sInitial,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}
						 	within
						 		((
						 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 		   sInitial::VS_O__(id__,
						 		   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						 		   [| { share__, terminate } |] (
						 		   sFinal::VS_O__(id__,
						 		   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						 		   [| { share__, terminate } |] (
						 		   sMoveAway::VS_O__(id__,
						 		   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						 		   )
						 		   )
						 		 )
						 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
						 		 [[sMoveAway::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAway,internal__.NID_sMoveAway,internal__.NID_sMoveAway|}]]
						 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
						 		 )
						 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 		  [[set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition]]
						 		 )
						 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 		 			,setL_robotIsFarEnoughFromPosition
						 		|}) |]
						 		 ((sInitial::enter -> Transitions(id__,
						 		 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
						 		  [[ share__ <- x__ | x__ <- {| share__,setL_robotIsFarEnoughFromPosition |} ]]
						 		 )
						 		)[[setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
						 		)
						 	)
						 	 \ hideSet)
						 	[[
						 		startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
						 		stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
						 		| x____ <- NIDS
						 	]]
						 )
						 )
						  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotIsFarEnoughFromPosition |} ]] 
						  [[set_nodeStatus <- setL_nodeStatus,set_robotIsFarEnoughFromPosition <- setL_robotIsFarEnoughFromPosition]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_nodeStatus
						 			,setL_robotIsFarEnoughFromPosition
						 			,setR_nodeStatus
						 			 			,setR_robotIsFarEnoughFromPosition
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotIsFarEnoughFromPosition |} ]]
						  [[set_nodeStatus <- setR_nodeStatus,set_robotIsFarEnoughFromPosition <- setR_robotIsFarEnoughFromPosition]]
						 )
						)[[setL_nodeStatus <- set_nodeStatus,setL_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
						 [[setR_nodeStatus <- set_nodeStatus,setR_robotIsFarEnoughFromPosition <- set_robotIsFarEnoughFromPosition]]
						)\{terminate} 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
				
				Transitions(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = ((let
					Trans = share__choice(get_robotIsFarEnoughFromPosition?robotIsFarEnoughFromPosition -> (
						((share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sMoveAway::enter -> SKIP))))
						 	 [] dbisim((robotIsFarEnoughFromPosition)&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_DONE -> SKIP))) ; sFinal::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; sMoveAway::enter -> SKIP)))
						 	 [] dbisim((true)&(internal__!NID_sMoveAway -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_FAILED -> SKIP))) ; sFinal::enter -> SKIP)))
						 ) ; Trans)
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
					)
					)
				within
					Trans
				)
				)
				
			
			endmodule
			----------------------------------------------------------------------
			
			-- END of Nodes --
			
			-- Operation calls --
			-- Only the undefined operations are declared here.
			-- If the state machine is in isolation, all required operations will be undefined.
			-- If it is in the context of a controller, the required operations not provided by the
			-- controller will be declared here, and the defined operations will be defined in the
			-- context of the Controller module, and therefore within scope of the state machine module.
			
			-- END of Operation calls --
			
			-- STM processes
			STM(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
			)\sharedVarHide
			
			STM_VS_O(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
			( 
				(
					(
						(IteratedStateful_VS_O(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) \ {terminate} ; share__choice(terminate -> SKIP))
					 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
					)
				[| {share__} |]
				SKIP
				)
				[| union(sharedVarSync,{terminate}) |]
				dbisim(sharedVarMemory(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
			)\sharedVarHide
			
			-- Transitions
			Transitions(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = ((let
				Trans = share__choice(get_nodeStatus?nodeStatus -> (
					((share__ -> SKIP
					 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
					 	 [] dbisim((true)&(startMoveAwayFromPosition__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
					 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
					 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sRun -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sWaitStart::enter -> SKIP)))
					 	 [] dbisim((true)&(stopMoveAwayFromPosition__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
					 	 [] dbisim((true)&(stopMoveAwayFromPosition__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP))) ; sFinal::enter -> SKIP)))
					 ) ; Trans)
					 []
					 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
					 []
					 terminate -> SKIP
				)
				)
			within
				Trans
			)
			)
			
			-- Stateful
			-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
			
			-- Named process definitions
			MachineBody(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startMoveAwayFromPosition__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopMoveAwayFromPosition__.NID_sRun.in,stopMoveAwayFromPosition__.NID_sWaitStart.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::D__(id__,
							   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							   [| { share__, terminate } |] (
							   sFinal::D__(id__,
							   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							   [| { share__, terminate } |] (
							   sWaitStart::D__(id__,
							   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							   [| { share__, terminate } |] (
							   sRun::D__(id__,
							   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startMoveAwayFromPosition__.NID_sWaitStart.in,stopMoveAwayFromPosition__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopMoveAwayFromPosition__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_nodeStatus <- setL_nodeStatus]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_nodeStatus
							|}) |]
							 ((sInitial::enter -> Transitions(id__,
							 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
							  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
							 )
							)[[setL_nodeStatus <- set_nodeStatus]]
							)
						)
						 \ hideSet)
						[[
							startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
							stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim((MachineBody(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)\ enteredSS)
				)
			
			IteratedBehaviour(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim((MachineBody(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)\ enteredSS)
				)
			
			Stateful(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				((
					(Behaviour(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) =
				(dbisim(
					sbisim(
						Behaviour(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						[| {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition,terminate|} |]
						Memory_robotIsFarEnoughFromPosition(true)
					)\{|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
				)
				)
			
			-- Visible counterparts
			MachineBody_VS_O(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim((
				let
					finalNodesEntered = {|sFinal::entered|}
				within
					((let
						-- IMPLEMENTATION NOTE:
						-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						-- modules for defining the semantics of each node.
						enterSS = {|
						sInitial::enter,
						sFinal::enter,
						sWaitStart::enter,
						sRun::enter
						|}
						hideSet = union(enterSS,{|exit,exited,internal__|})
					within 
						((let
							-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
							-- because CSPM modules are used for the semantics of Node.
							flowevts = union(enterSS,{|exit,exited,interrupt|})
							transSync = {|internal__.NID_sInitial,startMoveAwayFromPosition__.NID_sWaitStart.in,internal__.NID_sRun,internal__.NID_sRun,stopMoveAwayFromPosition__.NID_sRun.in,stopMoveAwayFromPosition__.NID_sWaitStart.in|}
						within
							((
							 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
							   sInitial::VS_O__(id__,
							   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							   [| { share__, terminate } |] (
							   sFinal::VS_O__(id__,
							   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							   [| { share__, terminate } |] (
							   sWaitStart::VS_O__(id__,
							   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							   [| { share__, terminate } |] (
							   sRun::VS_O__(id__,
							   		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
							   )
							   )
							   )
							 )
							 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
							 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startMoveAwayFromPosition__.NID_sWaitStart.in,stopMoveAwayFromPosition__.NID_sWaitStart.in|}]]
							 [[sRun::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sRun,internal__.NID_sRun,stopMoveAwayFromPosition__.NID_sRun.in|}]]
							 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
							 )
							  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
							  [[set_nodeStatus <- setL_nodeStatus]]
							 )
							 [| union(union(union(flowevts,transSync),{terminate}),{|share__
							 			,setL_nodeStatus
							|}) |]
							 ((sInitial::enter -> Transitions(id__,
							 		    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
							  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus |} ]]
							 )
							)[[setL_nodeStatus <- set_nodeStatus]]
							)
						)
						 \ hideSet)
						[[
							startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
							stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
							| x____ <- NIDS
						]]
					)
					 [| {| interrupt |} |] SKIP)
				)
				)
			
			Behaviour_VS_O(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim((MachineBody_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				)
			
			IteratedBehaviour_VS_O(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim((MachineBody_VS_O(id__,
						    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				)
			
			Stateful_VS_O(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = 
				dbisim((
					(Behaviour_VS_O(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__,
							    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE))
				 	\getsetLocalChannels
				)
				)
			
			IteratedStateful_VS_O(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) =
				(dbisim(
					sbisim(
						Behaviour_VS_O(id__,
								    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
						[| {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition,terminate|} |]
						Memory_robotIsFarEnoughFromPosition(true)
					)\{|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
				)
				)
			
			-- END
			
			-- Memory
			-- Memory variables
			Memory_robotIsFarEnoughFromPosition(robotIsFarEnoughFromPosition) =
				get_robotIsFarEnoughFromPosition!robotIsFarEnoughFromPosition -> Memory_robotIsFarEnoughFromPosition(robotIsFarEnoughFromPosition)
				[]
				set_robotIsFarEnoughFromPosition?x__ -> Memory_robotIsFarEnoughFromPosition(x__)
				[]
				terminate -> SKIP
			
			-- varMemory process
			varMemory(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = Memory_robotIsFarEnoughFromPosition(true)
			
			getsetLocalChannels = {|get_robotIsFarEnoughFromPosition,set_robotIsFarEnoughFromPosition|}
			
			-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
			FVS__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = STM_VS_O(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
			
			D__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = STM(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) \ internal_events
			O__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = sbisim(diamond(D__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)))
			VS__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = FVS__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)
			VS_O__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = sbisim(diamond(FVS__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)))
			HEXT__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = O__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [|shared_variable_events|] SKIP
			HUP__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = O__(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) [|{share__}|] SKIP
			
			-- Shared memory
			-- Shared memory variables
			Memory_nodeStatus(nodeStatus) =
				get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
				[]
				set_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
				[]
				terminate -> SKIP
			
			-- sharedVarMemory process
			sharedVarMemory(id__,
					    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE) = Memory_nodeStatus(NODE_STATUS_RUNNING)
			
			sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
			
			sharedVarHide = {|get_nodeStatus|}
		endmodule
		
			-- undefined operations
			
			-- declaring controller memory
			Memory(id__, nodeStatus) = (
				set_nodeStatus?x__ -> stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus!x__ -> stm_go_to_behind_ball_ref::set_EXT_nodeStatus!x__ -> stm_approach_ball_ref::set_EXT_nodeStatus!x__ -> stm_carry_ball_ref::set_EXT_nodeStatus!x__ -> stm_move_away_ref::set_EXT_nodeStatus!x__ -> 
				Memory(id__,x__)
			)
			
			D__(id__,
					    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = 	((
					(
						stm_behavior_ref::D__(id__)[[
							stm_behavior_ref::terminate <- terminate,
							stm_behavior_ref::receiveField <- receiveField,
							stm_behavior_ref::receiveFrame <- receiveFrame,
							stm_behavior_ref::receiveTactic <- receiveTactic,
							stm_behavior_ref::sendAction <- sendAction
						]]
						\ {|
							stm_behavior_ref::sendSkill,
							stm_behavior_ref::startHalt,
							stm_behavior_ref::stopHalt
						|}
					)
						[|{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|}|]
					(
						(
							stm_carry_ball_on_ball_placement_ref::D__(id__)[[
								stm_carry_ball_on_ball_placement_ref::terminate <- terminate,
								stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.in <- stm_behavior_ref::startCarryBallOnBallPlacement.out,
								stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.out <- stm_behavior_ref::startCarryBallOnBallPlacement.in,
								stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.in <- stm_behavior_ref::stopCarryBallOnBallPlacement.out,
								stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.out <- stm_behavior_ref::stopCarryBallOnBallPlacement.in,
								stm_carry_ball_on_ball_placement_ref::set_nodeStatus <- set_nodeStatus,
								stm_carry_ball_on_ball_placement_ref::get_nodeStatus <- get_nodeStatus
							]]
						)
							[|{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|}|]
						(
							(
								stm_go_to_behind_ball_ref::D__(id__)[[
									stm_go_to_behind_ball_ref::terminate <- terminate,
									stm_go_to_behind_ball_ref::startGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.out,
									stm_go_to_behind_ball_ref::startGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.in,
									stm_go_to_behind_ball_ref::stopGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.out,
									stm_go_to_behind_ball_ref::stopGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.in,
									stm_go_to_behind_ball_ref::set_nodeStatus <- set_nodeStatus,
									stm_go_to_behind_ball_ref::get_nodeStatus <- get_nodeStatus
								]]
							)
								[|{|terminate|}|]
							(
								(
									stm_approach_ball_ref::D__(id__)[[
										stm_approach_ball_ref::terminate <- terminate,
										stm_approach_ball_ref::startApproachBall.in <- stm_carry_ball_on_ball_placement_ref::startApproachBall.out,
										stm_approach_ball_ref::startApproachBall.out <- stm_carry_ball_on_ball_placement_ref::startApproachBall.in,
										stm_approach_ball_ref::stopApproachBall.in <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.out,
										stm_approach_ball_ref::stopApproachBall.out <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.in,
										stm_approach_ball_ref::set_nodeStatus <- set_nodeStatus,
										stm_approach_ball_ref::get_nodeStatus <- get_nodeStatus
									]]
								)
									[|{|terminate|}|]
								(
									(
										stm_carry_ball_ref::D__(id__)[[
											stm_carry_ball_ref::terminate <- terminate,
											stm_carry_ball_ref::startCarryBall.in <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.out,
											stm_carry_ball_ref::startCarryBall.out <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.in,
											stm_carry_ball_ref::stopCarryBall.in <- stm_carry_ball_on_ball_placement_ref::startCarryBall.out,
											stm_carry_ball_ref::stopCarryBall.out <- stm_carry_ball_on_ball_placement_ref::startCarryBall.in,
											stm_carry_ball_ref::set_nodeStatus <- set_nodeStatus,
											stm_carry_ball_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
										[|{|terminate|}|]
									(
										let
											const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE = 30
										within 
										stm_move_away_ref::D__(id__,
												    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)[[
											stm_move_away_ref::terminate <- terminate,
											stm_move_away_ref::startMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.out,
											stm_move_away_ref::startMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.in,
											stm_move_away_ref::stopMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.out,
											stm_move_away_ref::stopMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.in,
											stm_move_away_ref::set_nodeStatus <- set_nodeStatus,
											stm_move_away_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|},
						{|terminate|}
					)
				)
				\diff(
					{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|},
					{|terminate|}
				)
					[|
						union(
							{|
								set_nodeStatus
							|},
							{|
								stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
								stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
								stm_approach_ball_ref::set_EXT_nodeStatus,
								stm_carry_ball_ref::set_EXT_nodeStatus,
								stm_move_away_ref::set_EXT_nodeStatus
							|}
						)
					|]
				Memory(id__, NODE_STATUS_RUNNING)
			)
			\ union(
				{|
					set_nodeStatus, get_nodeStatus
				|},
				{|
					stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
					stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
					stm_approach_ball_ref::set_EXT_nodeStatus,
					stm_carry_ball_ref::set_EXT_nodeStatus,
					stm_move_away_ref::set_EXT_nodeStatus
				|}
			)
			[|{|terminate|}|>SKIP
			
			-- VS version
			VS__(id__,
					    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = 	((
					(
						stm_behavior_ref::VS__(id__)[[
							stm_behavior_ref::terminate <- terminate,
							stm_behavior_ref::receiveField <- receiveField,
							stm_behavior_ref::receiveFrame <- receiveFrame,
							stm_behavior_ref::receiveTactic <- receiveTactic,
							stm_behavior_ref::sendAction <- sendAction
						]]
						\ {|
							stm_behavior_ref::sendSkill,
							stm_behavior_ref::startHalt,
							stm_behavior_ref::stopHalt
						|}
					)
						[|{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|}|]
					(
						(
							stm_carry_ball_on_ball_placement_ref::VS__(id__)[[
								stm_carry_ball_on_ball_placement_ref::terminate <- terminate,
								stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.in <- stm_behavior_ref::startCarryBallOnBallPlacement.out,
								stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.out <- stm_behavior_ref::startCarryBallOnBallPlacement.in,
								stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.in <- stm_behavior_ref::stopCarryBallOnBallPlacement.out,
								stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.out <- stm_behavior_ref::stopCarryBallOnBallPlacement.in,
								stm_carry_ball_on_ball_placement_ref::set_nodeStatus <- set_nodeStatus,
								stm_carry_ball_on_ball_placement_ref::get_nodeStatus <- get_nodeStatus
							]]
						)
							[|{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|}|]
						(
							(
								stm_go_to_behind_ball_ref::VS__(id__)[[
									stm_go_to_behind_ball_ref::terminate <- terminate,
									stm_go_to_behind_ball_ref::startGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.out,
									stm_go_to_behind_ball_ref::startGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.in,
									stm_go_to_behind_ball_ref::stopGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.out,
									stm_go_to_behind_ball_ref::stopGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.in,
									stm_go_to_behind_ball_ref::set_nodeStatus <- set_nodeStatus,
									stm_go_to_behind_ball_ref::get_nodeStatus <- get_nodeStatus
								]]
							)
								[|{|terminate|}|]
							(
								(
									stm_approach_ball_ref::VS__(id__)[[
										stm_approach_ball_ref::terminate <- terminate,
										stm_approach_ball_ref::startApproachBall.in <- stm_carry_ball_on_ball_placement_ref::startApproachBall.out,
										stm_approach_ball_ref::startApproachBall.out <- stm_carry_ball_on_ball_placement_ref::startApproachBall.in,
										stm_approach_ball_ref::stopApproachBall.in <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.out,
										stm_approach_ball_ref::stopApproachBall.out <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.in,
										stm_approach_ball_ref::set_nodeStatus <- set_nodeStatus,
										stm_approach_ball_ref::get_nodeStatus <- get_nodeStatus
									]]
								)
									[|{|terminate|}|]
								(
									(
										stm_carry_ball_ref::VS__(id__)[[
											stm_carry_ball_ref::terminate <- terminate,
											stm_carry_ball_ref::startCarryBall.in <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.out,
											stm_carry_ball_ref::startCarryBall.out <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.in,
											stm_carry_ball_ref::stopCarryBall.in <- stm_carry_ball_on_ball_placement_ref::startCarryBall.out,
											stm_carry_ball_ref::stopCarryBall.out <- stm_carry_ball_on_ball_placement_ref::startCarryBall.in,
											stm_carry_ball_ref::set_nodeStatus <- set_nodeStatus,
											stm_carry_ball_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
										[|{|terminate|}|]
									(
										let
											const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE = 30
										within 
										stm_move_away_ref::VS__(id__,
												    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)[[
											stm_move_away_ref::terminate <- terminate,
											stm_move_away_ref::startMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.out,
											stm_move_away_ref::startMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.in,
											stm_move_away_ref::stopMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.out,
											stm_move_away_ref::stopMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.in,
											stm_move_away_ref::set_nodeStatus <- set_nodeStatus,
											stm_move_away_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|},
						{|terminate|}
					)
				)
				\diff(
					{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|},
					{|terminate|}
				)
					[|
						union(
							{|
								set_nodeStatus
							|},
							{|
								stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
								stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
								stm_approach_ball_ref::set_EXT_nodeStatus,
								stm_carry_ball_ref::set_EXT_nodeStatus,
								stm_move_away_ref::set_EXT_nodeStatus
							|}
						)
					|]
				Memory(id__, NODE_STATUS_RUNNING)
			)
			\ union(
				{|
					set_nodeStatus, get_nodeStatus
				|},
				{|
					stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
					stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
					stm_approach_ball_ref::set_EXT_nodeStatus,
					stm_carry_ball_ref::set_EXT_nodeStatus,
					stm_move_away_ref::set_EXT_nodeStatus
				|}
			)
			[|{|terminate|}|>SKIP
		
			-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
			O__(id__,
					    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = sbisim(diamond(	((
					(
						stm_behavior_ref::O__(id__)[[
							stm_behavior_ref::terminate <- terminate,
							stm_behavior_ref::receiveField <- receiveField,
							stm_behavior_ref::receiveFrame <- receiveFrame,
							stm_behavior_ref::receiveTactic <- receiveTactic,
							stm_behavior_ref::sendAction <- sendAction
						]]
						\ {|
							stm_behavior_ref::sendSkill,
							stm_behavior_ref::startHalt,
							stm_behavior_ref::stopHalt
						|}
					)
						[|{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|}|]
					(
						(
							stm_carry_ball_on_ball_placement_ref::O__(id__)[[
								stm_carry_ball_on_ball_placement_ref::terminate <- terminate,
								stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.in <- stm_behavior_ref::startCarryBallOnBallPlacement.out,
								stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.out <- stm_behavior_ref::startCarryBallOnBallPlacement.in,
								stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.in <- stm_behavior_ref::stopCarryBallOnBallPlacement.out,
								stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.out <- stm_behavior_ref::stopCarryBallOnBallPlacement.in,
								stm_carry_ball_on_ball_placement_ref::set_nodeStatus <- set_nodeStatus,
								stm_carry_ball_on_ball_placement_ref::get_nodeStatus <- get_nodeStatus
							]]
						)
							[|{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|}|]
						(
							(
								stm_go_to_behind_ball_ref::O__(id__)[[
									stm_go_to_behind_ball_ref::terminate <- terminate,
									stm_go_to_behind_ball_ref::startGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.out,
									stm_go_to_behind_ball_ref::startGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.in,
									stm_go_to_behind_ball_ref::stopGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.out,
									stm_go_to_behind_ball_ref::stopGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.in,
									stm_go_to_behind_ball_ref::set_nodeStatus <- set_nodeStatus,
									stm_go_to_behind_ball_ref::get_nodeStatus <- get_nodeStatus
								]]
							)
								[|{|terminate|}|]
							(
								(
									stm_approach_ball_ref::O__(id__)[[
										stm_approach_ball_ref::terminate <- terminate,
										stm_approach_ball_ref::startApproachBall.in <- stm_carry_ball_on_ball_placement_ref::startApproachBall.out,
										stm_approach_ball_ref::startApproachBall.out <- stm_carry_ball_on_ball_placement_ref::startApproachBall.in,
										stm_approach_ball_ref::stopApproachBall.in <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.out,
										stm_approach_ball_ref::stopApproachBall.out <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.in,
										stm_approach_ball_ref::set_nodeStatus <- set_nodeStatus,
										stm_approach_ball_ref::get_nodeStatus <- get_nodeStatus
									]]
								)
									[|{|terminate|}|]
								(
									(
										stm_carry_ball_ref::O__(id__)[[
											stm_carry_ball_ref::terminate <- terminate,
											stm_carry_ball_ref::startCarryBall.in <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.out,
											stm_carry_ball_ref::startCarryBall.out <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.in,
											stm_carry_ball_ref::stopCarryBall.in <- stm_carry_ball_on_ball_placement_ref::startCarryBall.out,
											stm_carry_ball_ref::stopCarryBall.out <- stm_carry_ball_on_ball_placement_ref::startCarryBall.in,
											stm_carry_ball_ref::set_nodeStatus <- set_nodeStatus,
											stm_carry_ball_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
										[|{|terminate|}|]
									(
										let
											const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE = 30
										within 
										stm_move_away_ref::O__(id__,
												    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)[[
											stm_move_away_ref::terminate <- terminate,
											stm_move_away_ref::startMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.out,
											stm_move_away_ref::startMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.in,
											stm_move_away_ref::stopMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.out,
											stm_move_away_ref::stopMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.in,
											stm_move_away_ref::set_nodeStatus <- set_nodeStatus,
											stm_move_away_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|},
						{|terminate|}
					)
				)
				\diff(
					{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|},
					{|terminate|}
				)
					[|
						union(
							{|
								set_nodeStatus
							|},
							{|
								stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
								stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
								stm_approach_ball_ref::set_EXT_nodeStatus,
								stm_carry_ball_ref::set_EXT_nodeStatus,
								stm_move_away_ref::set_EXT_nodeStatus
							|}
						)
					|]
				dbisim(Memory(id__, NODE_STATUS_RUNNING))
			)
			\ union(
				{|
					set_nodeStatus, get_nodeStatus
				|},
				{|
					stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
					stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
					stm_approach_ball_ref::set_EXT_nodeStatus,
					stm_carry_ball_ref::set_EXT_nodeStatus,
					stm_move_away_ref::set_EXT_nodeStatus
				|}
			)
			[|{|terminate|}|>SKIP
			))
							
			-- VS_O version
			VS_O__(id__,
					    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = sbisim(diamond(	((
					(
						stm_behavior_ref::VS_O__(id__)[[
							stm_behavior_ref::terminate <- terminate,
							stm_behavior_ref::receiveField <- receiveField,
							stm_behavior_ref::receiveFrame <- receiveFrame,
							stm_behavior_ref::receiveTactic <- receiveTactic,
							stm_behavior_ref::sendAction <- sendAction
						]]
						\ {|
							stm_behavior_ref::sendSkill,
							stm_behavior_ref::startHalt,
							stm_behavior_ref::stopHalt
						|}
					)
						[|{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|}|]
					(
						(
							stm_carry_ball_on_ball_placement_ref::VS_O__(id__)[[
								stm_carry_ball_on_ball_placement_ref::terminate <- terminate,
								stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.in <- stm_behavior_ref::startCarryBallOnBallPlacement.out,
								stm_carry_ball_on_ball_placement_ref::startCarryBallOnBallPlacement.out <- stm_behavior_ref::startCarryBallOnBallPlacement.in,
								stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.in <- stm_behavior_ref::stopCarryBallOnBallPlacement.out,
								stm_carry_ball_on_ball_placement_ref::stopCarryBallOnBallPlacement.out <- stm_behavior_ref::stopCarryBallOnBallPlacement.in,
								stm_carry_ball_on_ball_placement_ref::set_nodeStatus <- set_nodeStatus,
								stm_carry_ball_on_ball_placement_ref::get_nodeStatus <- get_nodeStatus
							]]
						)
							[|{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|}|]
						(
							(
								stm_go_to_behind_ball_ref::VS_O__(id__)[[
									stm_go_to_behind_ball_ref::terminate <- terminate,
									stm_go_to_behind_ball_ref::startGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.out,
									stm_go_to_behind_ball_ref::startGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::startGoToBehindBall.in,
									stm_go_to_behind_ball_ref::stopGoToBehindBall.in <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.out,
									stm_go_to_behind_ball_ref::stopGoToBehindBall.out <- stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall.in,
									stm_go_to_behind_ball_ref::set_nodeStatus <- set_nodeStatus,
									stm_go_to_behind_ball_ref::get_nodeStatus <- get_nodeStatus
								]]
							)
								[|{|terminate|}|]
							(
								(
									stm_approach_ball_ref::VS_O__(id__)[[
										stm_approach_ball_ref::terminate <- terminate,
										stm_approach_ball_ref::startApproachBall.in <- stm_carry_ball_on_ball_placement_ref::startApproachBall.out,
										stm_approach_ball_ref::startApproachBall.out <- stm_carry_ball_on_ball_placement_ref::startApproachBall.in,
										stm_approach_ball_ref::stopApproachBall.in <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.out,
										stm_approach_ball_ref::stopApproachBall.out <- stm_carry_ball_on_ball_placement_ref::stopApproachBall.in,
										stm_approach_ball_ref::set_nodeStatus <- set_nodeStatus,
										stm_approach_ball_ref::get_nodeStatus <- get_nodeStatus
									]]
								)
									[|{|terminate|}|]
								(
									(
										stm_carry_ball_ref::VS_O__(id__)[[
											stm_carry_ball_ref::terminate <- terminate,
											stm_carry_ball_ref::startCarryBall.in <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.out,
											stm_carry_ball_ref::startCarryBall.out <- stm_carry_ball_on_ball_placement_ref::stopCarryBall.in,
											stm_carry_ball_ref::stopCarryBall.in <- stm_carry_ball_on_ball_placement_ref::startCarryBall.out,
											stm_carry_ball_ref::stopCarryBall.out <- stm_carry_ball_on_ball_placement_ref::startCarryBall.in,
											stm_carry_ball_ref::set_nodeStatus <- set_nodeStatus,
											stm_carry_ball_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
										[|{|terminate|}|]
									(
										let
											const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE = 30
										within 
										stm_move_away_ref::VS_O__(id__,
												    const_MoveAwayFromPositionSTM_TIME_LIMIT_TO_BEHAVE)[[
											stm_move_away_ref::terminate <- terminate,
											stm_move_away_ref::startMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.out,
											stm_move_away_ref::startMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition.in,
											stm_move_away_ref::stopMoveAwayFromPosition.in <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.out,
											stm_move_away_ref::stopMoveAwayFromPosition.out <- stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition.in,
											stm_move_away_ref::set_nodeStatus <- set_nodeStatus,
											stm_move_away_ref::get_nodeStatus <- get_nodeStatus
										]]
									)
								)
								\diff(
									{|terminate|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate|},
							{|terminate|}
						)
					)
					\diff(
						{|terminate, stm_carry_ball_on_ball_placement_ref::startGoToBehindBall, stm_carry_ball_on_ball_placement_ref::stopGoToBehindBall, stm_carry_ball_on_ball_placement_ref::startApproachBall, stm_carry_ball_on_ball_placement_ref::stopApproachBall, stm_carry_ball_on_ball_placement_ref::stopCarryBall, stm_carry_ball_on_ball_placement_ref::startCarryBall, stm_carry_ball_on_ball_placement_ref::startMoveAwayFromPosition, stm_carry_ball_on_ball_placement_ref::stopMoveAwayFromPosition|},
						{|terminate|}
					)
				)
				\diff(
					{|terminate, stm_behavior_ref::startCarryBallOnBallPlacement, stm_behavior_ref::stopCarryBallOnBallPlacement|},
					{|terminate|}
				)
					[|
						union(
							{|
								set_nodeStatus
							|},
							{|
								stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
								stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
								stm_approach_ball_ref::set_EXT_nodeStatus,
								stm_carry_ball_ref::set_EXT_nodeStatus,
								stm_move_away_ref::set_EXT_nodeStatus
							|}
						)
					|]
				dbisim(Memory(id__, NODE_STATUS_RUNNING))
			)
			\ union(
				{|
					set_nodeStatus, get_nodeStatus
				|},
				{|
					stm_carry_ball_on_ball_placement_ref::set_EXT_nodeStatus,
					stm_go_to_behind_ball_ref::set_EXT_nodeStatus,
					stm_approach_ball_ref::set_EXT_nodeStatus,
					stm_carry_ball_ref::set_EXT_nodeStatus,
					stm_move_away_ref::set_EXT_nodeStatus
				|}
			)
			[|{|terminate|}|>SKIP
			))
		
			HEXT(id__,
					    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) = O__(id__,
					    const_carryBallOnBallPlacement_BehaviorController_stm_move_away_ref_TIME_LIMIT_TO_BEHAVE) [|shared_variable_events|] SKIP			

	endmodule

module CarryBallOnBallPlacementSTM
exports
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase

	-- Transition identifiers
	-- declaring identifiers of transitions
	datatype NIDS = 
	              NID_sInitial|
	              NID_sFinal|
	              NID_sWaitStart|
	              NID_sRun
	
	channel internal__ : NIDS
	
	-- Flow channels		
	channel interrupt
	channel exited
	channel exit
	channel terminate
	
	-- Variable channels
	channel get_robotHasMovedAwayFromBall, set_robotHasMovedAwayFromBall, setL_robotHasMovedAwayFromBall, setR_robotHasMovedAwayFromBall: core_boolean
	channel get_runningStm, set_runningStm, setL_runningStm, setR_runningStm: core_string
	channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
	
	-- Shared variable channels
	channel set_EXT_nodeStatus: NODE_STATUS
	
	-- Local variable channels for defined operations that are required by the state machine
	
	-- Declaring state machine events
	channel startCarryBallOnBallPlacement__: NIDS.InOut
	channel startCarryBallOnBallPlacement: InOut
	channel stopCarryBallOnBallPlacement__: NIDS.InOut
	channel stopCarryBallOnBallPlacement: InOut
	channel startGoToBehindBall__: NIDS.InOut
	channel startGoToBehindBall: InOut
	channel stopGoToBehindBall__: NIDS.InOut
	channel stopGoToBehindBall: InOut
	channel startApproachBall__: NIDS.InOut
	channel startApproachBall: InOut
	channel stopApproachBall__: NIDS.InOut
	channel stopApproachBall: InOut
	channel startCarryBall__: NIDS.InOut
	channel startCarryBall: InOut
	channel stopCarryBall__: NIDS.InOut
	channel stopCarryBall: InOut
	channel startMoveAwayFromPosition__: NIDS.InOut
	channel startMoveAwayFromPosition: InOut
	channel stopMoveAwayFromPosition__: NIDS.InOut
	channel stopMoveAwayFromPosition: InOut
	
	-- Declaring call and ret events for undefined operations
	
	enterSS = {|
	sInitial::enter,
	sFinal::enter,
	sWaitStart::enter,
	sRun::enter
	|}
	
	enteredSS = 	{|
	sFinal::entered,
	sWaitStart::entered,
	sRun::entered
	|}
	
	internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
	
	shared_variable_events = {|
		set_EXT_nodeStatus
	|}
	
	-- channel set with all visible events
	sem__events = {|
		terminate
	,	set_EXT_nodeStatus, set_nodeStatus
	,	startCarryBallOnBallPlacement,
		stopCarryBallOnBallPlacement,
		startGoToBehindBall,
		stopGoToBehindBall,
		startApproachBall,
		stopApproachBall,
		startCarryBall,
		stopCarryBall,
		startMoveAwayFromPosition,
		stopMoveAwayFromPosition
		|}

	-- Nodes --
	-- declaring all nodes
	
	----------------------------------------------------------------------
	-- Initial: sInitial
	module sInitial
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
		
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- Final state: sFinal
	module sFinal
	
	exports
	
		channel enter, entered, interrupt
		channel enteredL, enteredR
		
		--	Rule: behaviours(Node)
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
				
				Entering 	= entered -> SKIP ; Active
				Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
				Interrupted	= share__choice(exit -> exited -> Inactive)
			within
				Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- State: sWaitStart
	module sWaitStart
	
	enterSS = {}
	
	enteredSS = {}
	
	exports
	
		--  Declarations
		
		channel enter, entered, interrupt
		channel enteredL, enteredR
		
						
		
		--	Nodes
		-- declaring all nodes
		
		
		--	Rule: behaviours(Node)
		--  Note that FDR has problems with efficiently compiling the process below
		-- 	if using a different recursion pattern.
		D__(id__) = 
		dbisim(let
			-- IMPLEMENTATION NOTE: 
			-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
			-- however FDR struggles with that form in certain cases. So we use the exception operator
			-- instead to 'terminate'.
			
			Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
			
			Termination = terminate -> SKIP
			
			Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
					 	  Behaviour ; 
					 	  share__choice(exit -> SKIP) ; SKIP ; 
					 	  share__choice(exited -> SKIP) ; Inactive
		
			Behaviour 	= entered -> During
			During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
		within
			Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = 
		dbisim(let
			Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
			
			Termination = terminate -> SKIP
			
			Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
					 	  Behaviour ; 
					 	  share__choice(exit -> SKIP) ; SKIP ; 
					 	  share__choice(exited -> SKIP) ; Inactive
		
			Behaviour 	= entered -> During
			During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
		within
			Inactive [| {terminate} |> SKIP)
		
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- State: sRun
	module sRun
	
	enterSS = 
			{|			sInitial::enter,
				sGoToBehindBall::enter,
				sGiveSpaceToGetBall::enter,
				sApproachBall::enter,
				sPlaceBall::enter,
				sMoveAwayFromBall::enter,
				sFinal::enter
			|}
	enteredSS = 
			{|			sGoToBehindBall::entered,
				sGiveSpaceToGetBall::entered,
				sApproachBall::entered,
				sPlaceBall::entered,
				sMoveAwayFromBall::entered,
				sFinal::entered
			|}
	exports
	
		--  Declarations
		
		channel enter, entered, interrupt
		channel enteredL, enteredR
		
						
		-- declaring identifiers of transitions
		datatype NIDS = 
		              NID_sInitial|
		              NID_sGoToBehindBall|
		              NID_sGiveSpaceToGetBall|
		              NID_sApproachBall|
		              NID_sPlaceBall|
		              NID_sMoveAwayFromBall|
		              NID_sFinal
		
		channel internal__ : NIDS
		channel startCarryBallOnBallPlacement__: NIDS.InOut
		channel stopCarryBallOnBallPlacement__: NIDS.InOut
		channel startGoToBehindBall__: NIDS.InOut
		channel stopGoToBehindBall__: NIDS.InOut
		channel startApproachBall__: NIDS.InOut
		channel stopApproachBall__: NIDS.InOut
		channel startCarryBall__: NIDS.InOut
		channel stopCarryBall__: NIDS.InOut
		channel startMoveAwayFromPosition__: NIDS.InOut
		channel stopMoveAwayFromPosition__: NIDS.InOut
		
		--	Nodes
		-- declaring all nodes
		
		----------------------------------------------------------------------
		-- Initial: sInitial
		module sInitial
		exports
		
			channel enter, interrupt
			
			D__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(interrupt -> SKIP) ; Inactive
				within
					Inactive [| {terminate} |> SKIP)
			
			VS_O__(id__) = D__(id__)
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sGoToBehindBall
		module sGoToBehindBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--	Nodes
			-- declaring all nodes
			
			
			--	Rule: behaviours(Node)
			--  Note that FDR has problems with efficiently compiling the process below
			-- 	if using a different recursion pattern.
			D__(id__) = 
			dbisim(let
				-- IMPLEMENTATION NOTE: 
				-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
				-- however FDR struggles with that form in certain cases. So we use the exception operator
				-- instead to 'terminate'.
				
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
				
			VS_O__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
			
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sGiveSpaceToGetBall
		module sGiveSpaceToGetBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--	Nodes
			-- declaring all nodes
			
			
			--	Rule: behaviours(Node)
			--  Note that FDR has problems with efficiently compiling the process below
			-- 	if using a different recursion pattern.
			D__(id__) = 
			dbisim(let
				-- IMPLEMENTATION NOTE: 
				-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
				-- however FDR struggles with that form in certain cases. So we use the exception operator
				-- instead to 'terminate'.
				
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
				
			VS_O__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
			
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sApproachBall
		module sApproachBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--	Nodes
			-- declaring all nodes
			
			
			--	Rule: behaviours(Node)
			--  Note that FDR has problems with efficiently compiling the process below
			-- 	if using a different recursion pattern.
			D__(id__) = 
			dbisim(let
				-- IMPLEMENTATION NOTE: 
				-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
				-- however FDR struggles with that form in certain cases. So we use the exception operator
				-- instead to 'terminate'.
				
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
				
			VS_O__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
			
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sPlaceBall
		module sPlaceBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--	Nodes
			-- declaring all nodes
			
			
			--	Rule: behaviours(Node)
			--  Note that FDR has problems with efficiently compiling the process below
			-- 	if using a different recursion pattern.
			D__(id__) = 
			dbisim(let
				-- IMPLEMENTATION NOTE: 
				-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
				-- however FDR struggles with that form in certain cases. So we use the exception operator
				-- instead to 'terminate'.
				
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
				
			VS_O__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
			
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: sMoveAwayFromBall
		module sMoveAwayFromBall
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--	Nodes
			-- declaring all nodes
			
			
			--	Rule: behaviours(Node)
			--  Note that FDR has problems with efficiently compiling the process below
			-- 	if using a different recursion pattern.
			D__(id__) = 
			dbisim(let
				-- IMPLEMENTATION NOTE: 
				-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
				-- however FDR struggles with that form in certain cases. So we use the exception operator
				-- instead to 'terminate'.
				
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
				
			VS_O__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_RUNNING -> SKIP))) ; 
						 	  Behaviour ; 
						 	  share__choice(exit -> SKIP) ; SKIP ; 
						 	  share__choice(exited -> SKIP) ; Inactive
			
				Behaviour 	= entered -> During
				During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
			within
				Inactive [| {terminate} |> SKIP)
			
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- Final state: sFinal
		module sFinal
		
		exports
		
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
			--	Rule: behaviours(Node)
			D__(id__) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
					
					Entering 	= entered -> SKIP ; Active
					Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
					Interrupted	= share__choice(exit -> exited -> Inactive)
				within
					Inactive [| {terminate} |> SKIP)
				
			VS_O__(id__) = D__(id__)
		
		endmodule
		----------------------------------------------------------------------
		
		
		
		--	Rule: behaviours(Node)
		--  Note that FDR has problems with efficiently compiling the process below
		-- 	if using a different recursion pattern.
		D__(id__) = 
		dbisim(let
			-- IMPLEMENTATION NOTE: 
			-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
			-- however FDR struggles with that form in certain cases. So we use the exception operator
			-- instead to 'terminate'.
			
			Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
			
			Termination = terminate -> SKIP
			
			Active 		= SKIP ; 
					 	  Behaviour ; 
					 	  share__choice(exit -> SKIP) ; SKIP ; 
					 	  share__choice(exited -> SKIP) ; Inactive
		
		
			Behaviour 	= dbisim(
				((
				 (((let
				 	-- IMPLEMENTATION NOTE:
				 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
				 	-- modules for defining the semantics of each node.
				 	enterSS = {|
				 	sInitial::enter,
				 	sGoToBehindBall::enter,
				 	sGiveSpaceToGetBall::enter,
				 	sApproachBall::enter,
				 	sPlaceBall::enter,
				 	sMoveAwayFromBall::enter,
				 	sFinal::enter
				 	|}
				 	hideSet = union(enterSS,{|exit,exited,internal__|})
				 within 
				 	((let
				 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
				 		-- because CSPM modules are used for the semantics of Node.
				 		flowevts = union(enterSS,{|exit,exited,interrupt|})
				 		transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
				 	within
				 		((
				 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
				 		   sInitial::D__(id__)
				 		   [| { share__, terminate } |] (
				 		   sGoToBehindBall::D__(id__)
				 		   [| { share__, terminate } |] (
				 		   sGiveSpaceToGetBall::D__(id__)
				 		   [| { share__, terminate } |] (
				 		   sApproachBall::D__(id__)
				 		   [| { share__, terminate } |] (
				 		   sPlaceBall::D__(id__)
				 		   [| { share__, terminate } |] (
				 		   sMoveAwayFromBall::D__(id__)
				 		   [| { share__, terminate } |] (
				 		   sFinal::D__(id__)
				 		   )
				 		   )
				 		   )
				 		   )
				 		   )
				 		   )
				 		 )
				 		 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
				 		 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
				 		 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
				 		 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
				 		 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
				 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
				 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
				 		 )
				 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
				 		  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
				 		 )
				 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
				 		 			,setL_nodeStatus
				 		 			,setL_robotHasMovedAwayFromBall
				 		|}) |]
				 		 ((sInitial::enter -> Transitions(id__))
				 		  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
				 		 )
				 		)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
				 		)
				 	)
				 	 \ hideSet)
				 	[[
				 		startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
				 		stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
				 		startGoToBehindBall__.x____ <- startGoToBehindBall,
				 		stopGoToBehindBall__.x____ <- stopGoToBehindBall,
				 		startApproachBall__.x____ <- startApproachBall,
				 		stopApproachBall__.x____ <- stopApproachBall,
				 		startCarryBall__.x____ <- startCarryBall,
				 		stopCarryBall__.x____ <- stopCarryBall,
				 		startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
				 		stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
				 		| x____ <- NIDS
				 	]]
				 )
				 )
				  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotHasMovedAwayFromBall,setR_runningStm |} ]] 
				  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_runningStm <- setL_runningStm]]
				 )
				 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
				 			,setL_nodeStatus
				 			,setL_robotHasMovedAwayFromBall
				 			,setL_runningStm
				 			,setR_nodeStatus
				 			 			,setR_robotHasMovedAwayFromBall
				 			 			,setR_runningStm
				 			|}) |]
				 ((During)
				  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall,setL_runningStm |} ]]
				  [[set_nodeStatus <- setR_nodeStatus,set_robotHasMovedAwayFromBall <- setR_robotHasMovedAwayFromBall,set_runningStm <- setR_runningStm]]
				 )
				)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_runningStm <- set_runningStm]]
				 [[setR_nodeStatus <- set_nodeStatus,setR_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setR_runningStm <- set_runningStm]]
				)\union(enteredSS,{terminate}) 
			)
			During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
					 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
		within
			Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = 
		dbisim(let
			Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
			
			Termination = terminate -> SKIP
			
			Active 		= SKIP ; 
					 	  Behaviour ; 
					 	  share__choice(exit -> SKIP) ; SKIP ; 
					 	  share__choice(exited -> SKIP) ; Inactive
		
		
			Behaviour 	= dbisim(
				((
				 (((let
				 	-- IMPLEMENTATION NOTE:
				 	-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
				 	-- modules for defining the semantics of each node.
				 	enterSS = {|
				 	sInitial::enter,
				 	sGoToBehindBall::enter,
				 	sGiveSpaceToGetBall::enter,
				 	sApproachBall::enter,
				 	sPlaceBall::enter,
				 	sMoveAwayFromBall::enter,
				 	sFinal::enter
				 	|}
				 	hideSet = union(enterSS,{|exit,exited,internal__|})
				 within 
				 	((let
				 		-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
				 		-- because CSPM modules are used for the semantics of Node.
				 		flowevts = union(enterSS,{|exit,exited,interrupt|})
				 		transSync = {|internal__.NID_sInitial,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGoToBehindBall,internal__.NID_sApproachBall,internal__.NID_sPlaceBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sGiveSpaceToGetBall|}
				 	within
				 		((
				 		 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
				 		   sInitial::VS_O__(id__)
				 		   [| { share__, terminate } |] (
				 		   sGoToBehindBall::VS_O__(id__)
				 		   [| { share__, terminate } |] (
				 		   sGiveSpaceToGetBall::VS_O__(id__)
				 		   [| { share__, terminate } |] (
				 		   sApproachBall::VS_O__(id__)
				 		   [| { share__, terminate } |] (
				 		   sPlaceBall::VS_O__(id__)
				 		   [| { share__, terminate } |] (
				 		   sMoveAwayFromBall::VS_O__(id__)
				 		   [| { share__, terminate } |] (
				 		   sFinal::VS_O__(id__)
				 		   )
				 		   )
				 		   )
				 		   )
				 		   )
				 		   )
				 		 )
				 		 [[sGoToBehindBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall,internal__.NID_sGoToBehindBall|}]]
				 		 [[sGiveSpaceToGetBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall,internal__.NID_sGiveSpaceToGetBall|}]]
				 		 [[sApproachBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sApproachBall,internal__.NID_sApproachBall,internal__.NID_sApproachBall|}]]
				 		 [[sPlaceBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall,internal__.NID_sPlaceBall|}]]
				 		 [[sMoveAwayFromBall::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall,internal__.NID_sMoveAwayFromBall|}]]
				 		 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
				 		 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
				 		 )
				 		  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
				 		  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall]]
				 		 )
				 		 [| union(union(union(flowevts,transSync),{terminate}),{|share__
				 		 			,setL_nodeStatus
				 		 			,setL_robotHasMovedAwayFromBall
				 		|}) |]
				 		 ((sInitial::enter -> Transitions(id__))
				 		  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall |} ]]
				 		 )
				 		)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall]]
				 		)
				 	)
				 	 \ hideSet)
				 	[[
				 		startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
				 		stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
				 		startGoToBehindBall__.x____ <- startGoToBehindBall,
				 		stopGoToBehindBall__.x____ <- stopGoToBehindBall,
				 		startApproachBall__.x____ <- startApproachBall,
				 		stopApproachBall__.x____ <- stopApproachBall,
				 		startCarryBall__.x____ <- startCarryBall,
				 		stopCarryBall__.x____ <- stopCarryBall,
				 		startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
				 		stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
				 		| x____ <- NIDS
				 	]]
				 )
				 )
				  [[ share__ <- x__ | x__ <- {| share__,setR_nodeStatus,setR_robotHasMovedAwayFromBall,setR_runningStm |} ]] 
				  [[set_nodeStatus <- setL_nodeStatus,set_robotHasMovedAwayFromBall <- setL_robotHasMovedAwayFromBall,set_runningStm <- setL_runningStm]]
				 )
				 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
				 			,setL_nodeStatus
				 			,setL_robotHasMovedAwayFromBall
				 			,setL_runningStm
				 			,setR_nodeStatus
				 			 			,setR_robotHasMovedAwayFromBall
				 			 			,setR_runningStm
				 			|}) |]
				 ((During)
				  [[ share__ <- x__ | x__ <- {| share__,setL_nodeStatus,setL_robotHasMovedAwayFromBall,setL_runningStm |} ]]
				  [[set_nodeStatus <- setR_nodeStatus,set_robotHasMovedAwayFromBall <- setR_robotHasMovedAwayFromBall,set_runningStm <- setR_runningStm]]
				 )
				)[[setL_nodeStatus <- set_nodeStatus,setL_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setL_runningStm <- set_runningStm]]
				 [[setR_nodeStatus <- set_nodeStatus,setR_robotHasMovedAwayFromBall <- set_robotHasMovedAwayFromBall,setR_runningStm <- set_runningStm]]
				)\{terminate} 
			)
			During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
					 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
		within
			Inactive [| {terminate} |> SKIP)
		
		Transitions(id__) = ((let
			Trans = share__choice(get_nodeStatus?nodeStatus -> get_robotHasMovedAwayFromBall?robotHasMovedAwayFromBall -> (
				((share__ -> SKIP
				 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP))))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(startApproachBall.out -> SKIP)) ; sApproachBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(startCarryBall.out -> SKIP)) ; sPlaceBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(startMoveAwayFromPosition.out -> SKIP)) ; sMoveAwayFromBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_DONE))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(startMoveAwayFromPosition.out -> SKIP)) ; sGiveSpaceToGetBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_FAILED))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopGoToBehindBall.out -> SKIP)) ; sFinal::enter -> SKIP)))
				 	 [] dbisim((robotHasMovedAwayFromBall)&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sGoToBehindBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGoToBehindBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGoToBehindBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sApproachBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sApproachBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sPlaceBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sPlaceBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sMoveAwayFromBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sMoveAwayFromBall::enter -> SKIP)))
				 	 [] dbisim(((nodeStatus==NODE_STATUS_RUNNING))&(internal__!NID_sGiveSpaceToGetBall -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sGiveSpaceToGetBall::enter -> SKIP)))
				 ) ; Trans)
				 []
				 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
				 []
				 terminate -> SKIP
			)
			)
		within
			Trans
		)
		)
		
	
	endmodule
	----------------------------------------------------------------------
	
	-- END of Nodes --
	
	-- Operation calls --
	-- Only the undefined operations are declared here.
	-- If the state machine is in isolation, all required operations will be undefined.
	-- If it is in the context of a controller, the required operations not provided by the
	-- controller will be declared here, and the defined operations will be defined in the
	-- context of the Controller module, and therefore within scope of the state machine module.
	
	-- END of Operation calls --
	
	-- STM processes
	STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
	( 
		(
			(
				(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
			 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
			)
		[| {share__} |]
		SKIP
		)
		[| union(sharedVarSync,{terminate}) |]
		dbisim(sharedVarMemory(id__))
	)\sharedVarHide
	
	STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
	( 
		(
			(
				(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
			 	[[ share__ <- x__ | x__ <- {|set_EXT_nodeStatus|} ]]
			)
		[| {share__} |]
		SKIP
		)
		[| union(sharedVarSync,{terminate}) |]
		dbisim(sharedVarMemory(id__))
	)\sharedVarHide
	
	-- Transitions
	Transitions(id__) = ((let
		Trans = (
			((share__ -> SKIP
			 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitStart::enter -> SKIP))))
			 	 [] dbisim((true)&(startCarryBallOnBallPlacement__!NID_sWaitStart.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; sRun::enter -> SKIP)))
			 	 [] dbisim((true)&(stopCarryBallOnBallPlacement__!NID_sRun.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_nodeStatus!NODE_STATUS_ABORTED -> SKIP)));true&(share__choice(stopGoToBehindBall.out -> SKIP));true&(share__choice(stopApproachBall.out -> SKIP));true&(share__choice(stopCarryBall.out -> SKIP));true&(share__choice(stopMoveAwayFromPosition.out -> SKIP));true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; sFinal::enter -> SKIP)))
			 ) ; Trans)
			 []
			 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
			 []
			 terminate -> SKIP
		)
	within
		Trans
	)
	)
	
	-- Stateful
	-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
	
	-- Named process definitions
	MachineBody(id__) = 
		dbisim((
		let
			finalNodesEntered = {|sFinal::entered|}
		within
			((let
				-- IMPLEMENTATION NOTE:
				-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
				-- modules for defining the semantics of each node.
				enterSS = {|
				sInitial::enter,
				sFinal::enter,
				sWaitStart::enter,
				sRun::enter
				|}
				hideSet = union(enterSS,{|exit,exited,internal__|})
			within 
				((let
					-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
					-- because CSPM modules are used for the semantics of Node.
					flowevts = union(enterSS,{|exit,exited,interrupt|})
					transSync = {|internal__.NID_sInitial,startCarryBallOnBallPlacement__.NID_sWaitStart.in,stopCarryBallOnBallPlacement__.NID_sRun.in|}
				within
					((
					 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
					   sInitial::D__(id__)
					   [| { share__, terminate } |] (
					   sFinal::D__(id__)
					   [| { share__, terminate } |] (
					   sWaitStart::D__(id__)
					   [| { share__, terminate } |] (
					   sRun::D__(id__)
					   )
					   )
					   )
					 )
					 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
					 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBallOnBallPlacement__.NID_sWaitStart.in|}]]
					 [[sRun::interrupt <- x__ | x__ <- {|interrupt,stopCarryBallOnBallPlacement__.NID_sRun.in|}]]
					 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
					 )
					  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
					 )
					 [| union(union(union(flowevts,transSync),{terminate}),{|share__
					|}) |]
					 ((sInitial::enter -> Transitions(id__))
					  [[ share__ <- x__ | x__ <- {| share__ |} ]]
					 )
					)
					)
				)
				 \ hideSet)
				[[
					startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
					stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
					startGoToBehindBall__.x____ <- startGoToBehindBall,
					stopGoToBehindBall__.x____ <- stopGoToBehindBall,
					startApproachBall__.x____ <- startApproachBall,
					stopApproachBall__.x____ <- stopApproachBall,
					startCarryBall__.x____ <- startCarryBall,
					stopCarryBall__.x____ <- stopCarryBall,
					startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
					stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
					| x____ <- NIDS
				]]
			)
			 [| {| interrupt |} |] SKIP)
		)
		)
	
	Behaviour(id__) = 
		dbisim((MachineBody(id__)\ enteredSS)
		)
	
	IteratedBehaviour(id__) = 
		dbisim((MachineBody(id__)\ enteredSS)
		)
	
	Stateful(id__) = 
		((
			(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
		 	\getsetLocalChannels
		)
		)
	
	IteratedStateful(id__) =
		(dbisim(
			sbisim(
				dbisim(
					sbisim(
						Behaviour(id__)
						[| {|get_runningStm,set_runningStm,terminate|} |]
						Memory_runningStm("")
					)\{|get_runningStm,set_runningStm|}
				)
				[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
				Memory_robotHasMovedAwayFromBall(true)
			)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
		)
		)
	
	-- Visible counterparts
	MachineBody_VS_O(id__) = 
		dbisim((
		let
			finalNodesEntered = {|sFinal::entered|}
		within
			((let
				-- IMPLEMENTATION NOTE:
				-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
				-- modules for defining the semantics of each node.
				enterSS = {|
				sInitial::enter,
				sFinal::enter,
				sWaitStart::enter,
				sRun::enter
				|}
				hideSet = union(enterSS,{|exit,exited,internal__|})
			within 
				((let
					-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
					-- because CSPM modules are used for the semantics of Node.
					flowevts = union(enterSS,{|exit,exited,interrupt|})
					transSync = {|internal__.NID_sInitial,startCarryBallOnBallPlacement__.NID_sWaitStart.in,stopCarryBallOnBallPlacement__.NID_sRun.in|}
				within
					((
					 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
					   sInitial::VS_O__(id__)
					   [| { share__, terminate } |] (
					   sFinal::VS_O__(id__)
					   [| { share__, terminate } |] (
					   sWaitStart::VS_O__(id__)
					   [| { share__, terminate } |] (
					   sRun::VS_O__(id__)
					   )
					   )
					   )
					 )
					 [[sFinal::interrupt <- x__ | x__ <- {|interrupt|}]]
					 [[sWaitStart::interrupt <- x__ | x__ <- {|interrupt,startCarryBallOnBallPlacement__.NID_sWaitStart.in|}]]
					 [[sRun::interrupt <- x__ | x__ <- {|interrupt,stopCarryBallOnBallPlacement__.NID_sRun.in|}]]
					 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
					 )
					  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
					 )
					 [| union(union(union(flowevts,transSync),{terminate}),{|share__
					|}) |]
					 ((sInitial::enter -> Transitions(id__))
					  [[ share__ <- x__ | x__ <- {| share__ |} ]]
					 )
					)
					)
				)
				 \ hideSet)
				[[
					startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
					stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
					startGoToBehindBall__.x____ <- startGoToBehindBall,
					stopGoToBehindBall__.x____ <- stopGoToBehindBall,
					startApproachBall__.x____ <- startApproachBall,
					stopApproachBall__.x____ <- stopApproachBall,
					startCarryBall__.x____ <- startCarryBall,
					stopCarryBall__.x____ <- stopCarryBall,
					startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
					stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
					| x____ <- NIDS
				]]
			)
			 [| {| interrupt |} |] SKIP)
		)
		)
	
	Behaviour_VS_O(id__) = 
		dbisim((MachineBody_VS_O(id__))
		)
	
	IteratedBehaviour_VS_O(id__) = 
		dbisim((MachineBody_VS_O(id__))
		)
	
	Stateful_VS_O(id__) = 
		dbisim((
			(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
		 	\getsetLocalChannels
		)
		)
	
	IteratedStateful_VS_O(id__) =
		(dbisim(
			sbisim(
				dbisim(
					sbisim(
						Behaviour_VS_O(id__)
						[| {|get_runningStm,set_runningStm,terminate|} |]
						Memory_runningStm("")
					)\{|get_runningStm,set_runningStm|}
				)
				[| {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,terminate|} |]
				Memory_robotHasMovedAwayFromBall(true)
			)\{|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall|}
		)
		)
	
	-- END
	
	-- Memory
	-- Memory variables
	Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall) =
		get_robotHasMovedAwayFromBall!robotHasMovedAwayFromBall -> Memory_robotHasMovedAwayFromBall(robotHasMovedAwayFromBall)
		[]
		set_robotHasMovedAwayFromBall?x__ -> Memory_robotHasMovedAwayFromBall(x__)
		[]
		terminate -> SKIP
	Memory_runningStm(runningStm) =
		get_runningStm!runningStm -> Memory_runningStm(runningStm)
		[]
		set_runningStm?x__ -> Memory_runningStm(x__)
		[]
		terminate -> SKIP
	
	-- varMemory process
	varMemory(id__) = Memory_robotHasMovedAwayFromBall(true)
	[| { terminate } |] (
	Memory_runningStm("")
	)
	
	getsetLocalChannels = {|get_robotHasMovedAwayFromBall,set_robotHasMovedAwayFromBall,get_runningStm,set_runningStm|}
	
	-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
	FVS__(id__) = STM_VS_O(id__)
	
	D__(id__) = STM(id__) \ internal_events
	O__(id__) = sbisim(diamond(D__(id__)))
	VS__(id__) = FVS__(id__)
	VS_O__(id__) = sbisim(diamond(FVS__(id__)))
	HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
	HUP__(id__) = O__(id__) [|{share__}|] SKIP
	
	-- Shared memory
	-- Shared memory variables
	Memory_nodeStatus(nodeStatus) =
		get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
		[]
		set_nodeStatus?x__ -> Memory_nodeStatus(x__)
		[]
		set_EXT_nodeStatus?x__ -> Memory_nodeStatus(x__)
		[]
		terminate -> SKIP
	
	-- sharedVarMemory process
	sharedVarMemory(id__) = Memory_nodeStatus(NODE_STATUS_RUNNING)
	
	sharedVarSync = {|get_nodeStatus,set_nodeStatus,set_EXT_nodeStatus|}
	
	sharedVarHide = {|get_nodeStatus|}
endmodule
module BehaviorSTM
exports
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase

	-- Transition identifiers
	-- declaring identifiers of transitions
	datatype NIDS = 
	              NID_sInitial|
	              NID_sWaitTactic|
	              NID_jCheckCurrentTactic|
	              NID_jStopLastTactic|
	              NID_jStartCurrentTactic
	
	channel internal__ : NIDS
	
	-- Flow channels		
	channel interrupt
	channel exited
	channel exit
	channel terminate
	
	-- Variable channels
	channel get_currentTactic, set_currentTactic, setL_currentTactic, setR_currentTactic: Tactic
	channel get_lastTactic, set_lastTactic, setL_lastTactic, setR_lastTactic: Tactic
	channel get_nodeStatus, set_nodeStatus, setL_nodeStatus, setR_nodeStatus: NODE_STATUS
	
	-- Shared variable channels
	
	-- Local variable channels for defined operations that are required by the state machine
	
	-- Declaring state machine events
	channel receiveFrame__: NIDS.InOut.core_string
	channel receiveFrame: InOut.core_string
	channel receiveField__: NIDS.InOut.core_string
	channel receiveField: InOut.core_string
	channel receiveTactic__: NIDS.InOut.Tactic
	channel receiveTactic: InOut.Tactic
	channel sendAction__: NIDS.InOut.core_string
	channel sendAction: InOut.core_string
	channel sendSkill__: NIDS.InOut.carryBallOnBallPlacement_Skill
	channel sendSkill: InOut.carryBallOnBallPlacement_Skill
	channel startCarryBallOnBallPlacement__: NIDS.InOut
	channel startCarryBallOnBallPlacement: InOut
	channel stopCarryBallOnBallPlacement__: NIDS.InOut
	channel stopCarryBallOnBallPlacement: InOut
	channel startHalt__: NIDS.InOut
	channel startHalt: InOut
	channel stopHalt__: NIDS.InOut
	channel stopHalt: InOut
	
	-- Declaring call and ret events for undefined operations
	
	enterSS = {|
	sInitial::enter,
	sWaitTactic::enter,
	jCheckCurrentTactic::enter,
	jStopLastTactic::enter,
	jStartCurrentTactic::enter
	|}
	
	enteredSS = 	{|
	sWaitTactic::entered
	|}
	
	internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
	
	shared_variable_events = {|
	|}
	
	-- channel set with all visible events
	sem__events = {|
		terminate
	,	receiveFrame,
		receiveField,
		receiveTactic,
		sendAction,
		sendSkill,
		startCarryBallOnBallPlacement,
		stopCarryBallOnBallPlacement,
		startHalt,
		stopHalt
		|}

	-- Nodes --
	-- declaring all nodes
	
	----------------------------------------------------------------------
	-- Initial: sInitial
	module sInitial
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
		
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- State: sWaitTactic
	module sWaitTactic
	
	enterSS = {}
	
	enteredSS = {}
	
	exports
	
		--  Declarations
		
		channel enter, entered, interrupt
		channel enteredL, enteredR
		
						
		
		--	Nodes
		-- declaring all nodes
		
		
		--	Rule: behaviours(Node)
		--  Note that FDR has problems with efficiently compiling the process below
		-- 	if using a different recursion pattern.
		D__(id__) = 
		dbisim(let
			-- IMPLEMENTATION NOTE: 
			-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
			-- however FDR struggles with that form in certain cases. So we use the exception operator
			-- instead to 'terminate'.
			
			Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
			
			Termination = terminate -> SKIP
			
			Active 		= SKIP ; 
					 	  Behaviour ; 
					 	  share__choice(exit -> SKIP) ; SKIP ; 
					 	  share__choice(exited -> SKIP) ; Inactive
		
			Behaviour 	= entered -> During
			During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
		within
			Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = 
		dbisim(let
			Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
			
			Termination = terminate -> SKIP
			
			Active 		= SKIP ; 
					 	  Behaviour ; 
					 	  share__choice(exit -> SKIP) ; SKIP ; 
					 	  share__choice(exited -> SKIP) ; Inactive
		
			Behaviour 	= entered -> During
			During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
		within
			Inactive [| {terminate} |> SKIP)
		
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- Junction: jCheckCurrentTactic
	module jCheckCurrentTactic
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- Junction: jStopLastTactic
	module jStopLastTactic
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- Junction: jStartCurrentTactic
	module jStartCurrentTactic
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	-- END of Nodes --
	
	-- Operation calls --
	-- Only the undefined operations are declared here.
	-- If the state machine is in isolation, all required operations will be undefined.
	-- If it is in the context of a controller, the required operations not provided by the
	-- controller will be declared here, and the defined operations will be defined in the
	-- context of the Controller module, and therefore within scope of the state machine module.
	
	-- END of Operation calls --
	
	-- STM processes
	STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
	( 
		(
			(
				(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
			 	[[ share__ <- x__ | x__ <- {||} ]]
			)
		[| {share__} |]
		SKIP
		)
		[| union(sharedVarSync,{terminate}) |]
		dbisim(sharedVarMemory(id__))
	)\sharedVarHide
	
	STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
	( 
		(
			(
				(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
			 	[[ share__ <- x__ | x__ <- {||} ]]
			)
		[| {share__} |]
		SKIP
		)
		[| union(sharedVarSync,{terminate}) |]
		dbisim(sharedVarMemory(id__))
	)\sharedVarHide
	
	-- Transitions
	Transitions(id__) = ((let
		Trans = share__choice(get_currentTactic?currentTactic -> get_lastTactic?lastTactic -> (
			((share__ -> SKIP
			 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitTactic::enter -> SKIP))))
			 	 [] dbisim((true)&(receiveTactic__!NID_sWaitTactic.in?currentTactic:{currentTactic|currentTactic <- Tactic, true} -> share__choice(set_currentTactic!currentTactic -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; jCheckCurrentTactic::enter -> SKIP)))
			 	 [] dbisim(((currentTactic==lastTactic))&(internal__!NID_jCheckCurrentTactic -> SKIP ;  ((SKIP ; sWaitTactic::enter -> SKIP))))
			 	 [] dbisim(((currentTactic!=lastTactic))&(internal__!NID_jCheckCurrentTactic -> SKIP ;  ((SKIP ; jStopLastTactic::enter -> SKIP))))
			 	 [] dbisim(((lastTactic==Tactic_PLACE_BALL_IN_POSITION))&(internal__!NID_jStopLastTactic -> SKIP ;  ((true&(share__choice(stopCarryBallOnBallPlacement.out -> SKIP)) ; jStartCurrentTactic::enter -> SKIP))))
			 	 [] dbisim(((lastTactic==Tactic_HALT))&(internal__!NID_jStopLastTactic -> SKIP ;  ((true&(share__choice(stopHalt.out -> SKIP)) ; jStartCurrentTactic::enter -> SKIP))))
			 	 [] dbisim(((currentTactic==Tactic_PLACE_BALL_IN_POSITION))&(internal__!NID_jStartCurrentTactic -> SKIP ;  ((true&(share__choice(startCarryBallOnBallPlacement.out -> SKIP)) ; sWaitTactic::enter -> SKIP))))
			 	 [] dbisim(((currentTactic==Tactic_HALT))&(internal__!NID_jStartCurrentTactic -> SKIP ;  ((true&(share__choice(startHalt.out -> SKIP)) ; sWaitTactic::enter -> SKIP))))
			 ) ; Trans)
			 []
			 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
			 []
			 terminate -> SKIP
		)
		)
	within
		Trans
	)
	)
	
	-- Stateful
	-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
	
	-- Named process definitions
	MachineBody(id__) = 
		dbisim((
		let
			finalNodesEntered = {||}
		within
			((let
				-- IMPLEMENTATION NOTE:
				-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
				-- modules for defining the semantics of each node.
				enterSS = {|
				sInitial::enter,
				sWaitTactic::enter,
				jCheckCurrentTactic::enter,
				jStopLastTactic::enter,
				jStartCurrentTactic::enter
				|}
				hideSet = union(enterSS,{|exit,exited,internal__|})
			within 
				((let
					-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
					-- because CSPM modules are used for the semantics of Node.
					flowevts = union(enterSS,{|exit,exited,interrupt|})
					transSync = {|internal__.NID_sInitial,receiveTactic__.NID_sWaitTactic.in,internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic,internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic,internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}
				within
					((
					 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
					   sInitial::D__(id__)
					   [| { share__, terminate } |] (
					   sWaitTactic::D__(id__)
					   [| { share__, terminate } |] (
					   jCheckCurrentTactic::D__(id__)
					   [| { share__, terminate } |] (
					   jStopLastTactic::D__(id__)
					   [| { share__, terminate } |] (
					   jStartCurrentTactic::D__(id__)
					   )
					   )
					   )
					   )
					 )
					 [[sWaitTactic::interrupt <- x__ | x__ <- {|interrupt,receiveTactic__.NID_sWaitTactic.in|}]]
					 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
					 [[jCheckCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic|}]]
					 [[jStopLastTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic|}]]
					 [[jStartCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}]]
					 )
					  [[ share__ <- x__ | x__ <- {| share__,setR_currentTactic |} ]] 
					  [[set_currentTactic <- setL_currentTactic,set_lastTactic <- setL_lastTactic]]
					 )
					 [| union(union(union(flowevts,transSync),{terminate}),{|share__
					 			,setL_currentTactic
					 			,setL_lastTactic
					 			,setR_currentTactic
					 			|}) |]
					 ((sInitial::enter -> Transitions(id__))
					  [[ share__ <- x__ | x__ <- {| share__,setL_currentTactic,setL_lastTactic |} ]]
					  [[set_currentTactic <- setR_currentTactic]]
					 )
					)[[setL_currentTactic <- set_currentTactic,setL_lastTactic <- set_lastTactic]]
					 [[setR_currentTactic <- set_currentTactic]]
					)
				)
				 \ hideSet)
				[[
					receiveFrame__.x____ <- receiveFrame,
					receiveField__.x____ <- receiveField,
					receiveTactic__.x____ <- receiveTactic,
					sendAction__.x____ <- sendAction,
					sendSkill__.x____ <- sendSkill,
					startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
					stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
					startHalt__.x____ <- startHalt,
					stopHalt__.x____ <- stopHalt
					| x____ <- NIDS
				]]
			)
			 [| {| interrupt |} |] SKIP)
		)
		)
	
	Behaviour(id__) = 
		dbisim((MachineBody(id__)\ enteredSS)
		)
	
	IteratedBehaviour(id__) = 
		dbisim((MachineBody(id__)\ enteredSS)
		)
	
	Stateful(id__) = 
		((
			(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
		 	\getsetLocalChannels
		)
		)
	
	IteratedStateful(id__) =
		(dbisim(
			sbisim(
				dbisim(
					sbisim(
						dbisim(
							sbisim(
								Behaviour(id__)
								[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
								Memory_nodeStatus(NODE_STATUS_RUNNING)
							)\{|get_nodeStatus,set_nodeStatus|}
						)
						[| {|get_lastTactic,set_lastTactic,terminate|} |]
						Memory_lastTactic(Tactic_HALT)
					)\{|get_lastTactic,set_lastTactic|}
				)
				[| {|get_currentTactic,set_currentTactic,terminate|} |]
				Memory_currentTactic(Tactic_HALT)
			)\{|get_currentTactic,set_currentTactic|}
		)
		)
	
	-- Visible counterparts
	MachineBody_VS_O(id__) = 
		dbisim((
		let
			finalNodesEntered = {||}
		within
			((let
				-- IMPLEMENTATION NOTE:
				-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
				-- modules for defining the semantics of each node.
				enterSS = {|
				sInitial::enter,
				sWaitTactic::enter,
				jCheckCurrentTactic::enter,
				jStopLastTactic::enter,
				jStartCurrentTactic::enter
				|}
				hideSet = union(enterSS,{|exit,exited,internal__|})
			within 
				((let
					-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
					-- because CSPM modules are used for the semantics of Node.
					flowevts = union(enterSS,{|exit,exited,interrupt|})
					transSync = {|internal__.NID_sInitial,receiveTactic__.NID_sWaitTactic.in,internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic,internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic,internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}
				within
					((
					 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
					   sInitial::VS_O__(id__)
					   [| { share__, terminate } |] (
					   sWaitTactic::VS_O__(id__)
					   [| { share__, terminate } |] (
					   jCheckCurrentTactic::VS_O__(id__)
					   [| { share__, terminate } |] (
					   jStopLastTactic::VS_O__(id__)
					   [| { share__, terminate } |] (
					   jStartCurrentTactic::VS_O__(id__)
					   )
					   )
					   )
					   )
					 )
					 [[sWaitTactic::interrupt <- x__ | x__ <- {|interrupt,receiveTactic__.NID_sWaitTactic.in|}]]
					 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
					 [[jCheckCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jCheckCurrentTactic,internal__.NID_jCheckCurrentTactic|}]]
					 [[jStopLastTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStopLastTactic,internal__.NID_jStopLastTactic|}]]
					 [[jStartCurrentTactic::interrupt <- x__ | x__ <- {|internal__.NID_jStartCurrentTactic,internal__.NID_jStartCurrentTactic|}]]
					 )
					  [[ share__ <- x__ | x__ <- {| share__,setR_currentTactic |} ]] 
					  [[set_currentTactic <- setL_currentTactic,set_lastTactic <- setL_lastTactic]]
					 )
					 [| union(union(union(flowevts,transSync),{terminate}),{|share__
					 			,setL_currentTactic
					 			,setL_lastTactic
					 			,setR_currentTactic
					 			|}) |]
					 ((sInitial::enter -> Transitions(id__))
					  [[ share__ <- x__ | x__ <- {| share__,setL_currentTactic,setL_lastTactic |} ]]
					  [[set_currentTactic <- setR_currentTactic]]
					 )
					)[[setL_currentTactic <- set_currentTactic,setL_lastTactic <- set_lastTactic]]
					 [[setR_currentTactic <- set_currentTactic]]
					)
				)
				 \ hideSet)
				[[
					receiveFrame__.x____ <- receiveFrame,
					receiveField__.x____ <- receiveField,
					receiveTactic__.x____ <- receiveTactic,
					sendAction__.x____ <- sendAction,
					sendSkill__.x____ <- sendSkill,
					startCarryBallOnBallPlacement__.x____ <- startCarryBallOnBallPlacement,
					stopCarryBallOnBallPlacement__.x____ <- stopCarryBallOnBallPlacement,
					startHalt__.x____ <- startHalt,
					stopHalt__.x____ <- stopHalt
					| x____ <- NIDS
				]]
			)
			 [| {| interrupt |} |] SKIP)
		)
		)
	
	Behaviour_VS_O(id__) = 
		dbisim((MachineBody_VS_O(id__))
		)
	
	IteratedBehaviour_VS_O(id__) = 
		dbisim((MachineBody_VS_O(id__))
		)
	
	Stateful_VS_O(id__) = 
		dbisim((
			(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
		 	\getsetLocalChannels
		)
		)
	
	IteratedStateful_VS_O(id__) =
		(dbisim(
			sbisim(
				dbisim(
					sbisim(
						dbisim(
							sbisim(
								Behaviour_VS_O(id__)
								[| {|get_nodeStatus,set_nodeStatus,terminate|} |]
								Memory_nodeStatus(NODE_STATUS_RUNNING)
							)\{|get_nodeStatus,set_nodeStatus|}
						)
						[| {|get_lastTactic,set_lastTactic,terminate|} |]
						Memory_lastTactic(Tactic_HALT)
					)\{|get_lastTactic,set_lastTactic|}
				)
				[| {|get_currentTactic,set_currentTactic,terminate|} |]
				Memory_currentTactic(Tactic_HALT)
			)\{|get_currentTactic,set_currentTactic|}
		)
		)
	
	-- END
	
	-- Memory
	-- Memory variables
	Memory_currentTactic(currentTactic) =
		get_currentTactic!currentTactic -> Memory_currentTactic(currentTactic)
		[]
		set_currentTactic?x__ -> Memory_currentTactic(x__)
		[]
		terminate -> SKIP
	Memory_lastTactic(lastTactic) =
		get_lastTactic!lastTactic -> Memory_lastTactic(lastTactic)
		[]
		set_lastTactic?x__ -> Memory_lastTactic(x__)
		[]
		terminate -> SKIP
	Memory_nodeStatus(nodeStatus) =
		get_nodeStatus!nodeStatus -> Memory_nodeStatus(nodeStatus)
		[]
		set_nodeStatus?x__ -> Memory_nodeStatus(x__)
		[]
		terminate -> SKIP
	
	-- varMemory process
	varMemory(id__) = Memory_currentTactic(Tactic_HALT)
	[| { terminate } |] (
	Memory_lastTactic(Tactic_HALT)
	[| { terminate } |] (
	Memory_nodeStatus(NODE_STATUS_RUNNING)
	)
	)
	
	getsetLocalChannels = {|get_currentTactic,set_currentTactic,get_lastTactic,set_lastTactic,get_nodeStatus,set_nodeStatus|}
	
	-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
	FVS__(id__) = STM_VS_O(id__)
	
	D__(id__) = STM(id__) \ internal_events
	O__(id__) = sbisim(diamond(D__(id__)))
	VS__(id__) = FVS__(id__)
	VS_O__(id__) = sbisim(diamond(FVS__(id__)))
	HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
	HUP__(id__) = O__(id__) [|{share__}|] SKIP
	
	-- Shared memory
	-- Shared memory variables
	
	-- sharedVarMemory process
	sharedVarMemory(id__) = terminate -> SKIP
	
	sharedVarSync = {||}
	
	sharedVarHide = {||}
endmodule
module SkillSTM
exports
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase

	-- Transition identifiers
	-- declaring identifiers of transitions
	datatype NIDS = 
	              NID_sInitial|
	              NID_sWaitSkill|
	              NID_jCheckCurrentSkill|
	              NID_jStopLastSkill|
	              NID_jStartCurrentSkill
	
	channel internal__ : NIDS
	
	-- Flow channels		
	channel interrupt
	channel exited
	channel exit
	channel terminate
	
	-- Variable channels
	channel get_currentSkill, set_currentSkill, setL_currentSkill, setR_currentSkill: carryBallOnBallPlacement_Skill
	channel get_lastSkill, set_lastSkill, setL_lastSkill, setR_lastSkill: carryBallOnBallPlacement_Skill
	
	-- Shared variable channels
	
	-- Local variable channels for defined operations that are required by the state machine
	
	-- Declaring state machine events
	channel receiveSkill__: NIDS.InOut.carryBallOnBallPlacement_Skill
	channel receiveSkill: InOut.carryBallOnBallPlacement_Skill
	channel sendAction__: NIDS.InOut.core_string
	channel sendAction: InOut.core_string
	channel startGoToBehindBall__: NIDS.InOut
	channel startGoToBehindBall: InOut
	channel stopGoToBehindBall__: NIDS.InOut
	channel stopGoToBehindBall: InOut
	channel startApproachBall__: NIDS.InOut
	channel startApproachBall: InOut
	channel stopApproachBall__: NIDS.InOut
	channel stopApproachBall: InOut
	channel startCarryBall__: NIDS.InOut
	channel startCarryBall: InOut
	channel stopCarryBall__: NIDS.InOut
	channel stopCarryBall: InOut
	channel startMoveAwayFromPosition__: NIDS.InOut
	channel startMoveAwayFromPosition: InOut
	channel stopMoveAwayFromPosition__: NIDS.InOut
	channel stopMoveAwayFromPosition: InOut
	
	-- Declaring call and ret events for undefined operations
	
	enterSS = {|
	sInitial::enter,
	sWaitSkill::enter,
	jCheckCurrentSkill::enter,
	jStopLastSkill::enter,
	jStartCurrentSkill::enter
	|}
	
	enteredSS = 	{|
	sWaitSkill::entered
	|}
	
	internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
	
	shared_variable_events = {|
	|}
	
	-- channel set with all visible events
	sem__events = {|
		terminate
	,	receiveSkill,
		sendAction,
		startGoToBehindBall,
		stopGoToBehindBall,
		startApproachBall,
		stopApproachBall,
		startCarryBall,
		stopCarryBall,
		startMoveAwayFromPosition,
		stopMoveAwayFromPosition
		|}

	-- Nodes --
	-- declaring all nodes
	
	----------------------------------------------------------------------
	-- Initial: sInitial
	module sInitial
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Termination = terminate -> SKIP
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
		
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- State: sWaitSkill
	module sWaitSkill
	
	enterSS = {}
	
	enteredSS = {}
	
	exports
	
		--  Declarations
		
		channel enter, entered, interrupt
		channel enteredL, enteredR
		
						
		
		--	Nodes
		-- declaring all nodes
		
		
		--	Rule: behaviours(Node)
		--  Note that FDR has problems with efficiently compiling the process below
		-- 	if using a different recursion pattern.
		D__(id__) = 
		dbisim(let
			-- IMPLEMENTATION NOTE: 
			-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
			-- however FDR struggles with that form in certain cases. So we use the exception operator
			-- instead to 'terminate'.
			
			Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
			
			Termination = terminate -> SKIP
			
			Active 		= SKIP ; 
					 	  Behaviour ; 
					 	  share__choice(exit -> SKIP) ; SKIP ; 
					 	  share__choice(exited -> SKIP) ; Inactive
		
			Behaviour 	= entered -> During
			During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
		within
			Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = 
		dbisim(let
			Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
			
			Termination = terminate -> SKIP
			
			Active 		= SKIP ; 
					 	  Behaviour ; 
					 	  share__choice(exit -> SKIP) ; SKIP ; 
					 	  share__choice(exited -> SKIP) ; Inactive
		
			Behaviour 	= entered -> During
			During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
		within
			Inactive [| {terminate} |> SKIP)
		
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- Junction: jCheckCurrentSkill
	module jCheckCurrentSkill
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- Junction: jStopLastSkill
	module jStopLastSkill
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	
	----------------------------------------------------------------------
	-- Junction: jStartCurrentSkill
	module jStartCurrentSkill
	exports
	
		channel enter, interrupt
		
		D__(id__) = 
			dbisim(let
				Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
				
				Active 		= share__choice(interrupt -> SKIP) ; Inactive
			within
				Inactive [| {terminate} |> SKIP)
			
		VS_O__(id__) = D__(id__)
	
	endmodule
	----------------------------------------------------------------------
	
	-- END of Nodes --
	
	-- Operation calls --
	-- Only the undefined operations are declared here.
	-- If the state machine is in isolation, all required operations will be undefined.
	-- If it is in the context of a controller, the required operations not provided by the
	-- controller will be declared here, and the defined operations will be defined in the
	-- context of the Controller module, and therefore within scope of the state machine module.
	
	-- END of Operation calls --
	
	-- STM processes
	STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
	( 
		(
			(
				(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
			 	[[ share__ <- x__ | x__ <- {||} ]]
			)
		[| {share__} |]
		SKIP
		)
		[| union(sharedVarSync,{terminate}) |]
		dbisim(sharedVarMemory(id__))
	)\sharedVarHide
	
	STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
	( 
		(
			(
				(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
			 	[[ share__ <- x__ | x__ <- {||} ]]
			)
		[| {share__} |]
		SKIP
		)
		[| union(sharedVarSync,{terminate}) |]
		dbisim(sharedVarMemory(id__))
	)\sharedVarHide
	
	-- Transitions
	Transitions(id__) = ((let
		Trans = share__choice(get_currentSkill?currentSkill -> get_lastSkill?lastSkill -> (
			((share__ -> SKIP
			 [] dbisim((true)&(internal__!NID_sInitial -> SKIP ;  ((SKIP ; sWaitSkill::enter -> SKIP))))
			 	 [] dbisim((true)&(receiveSkill__!NID_sWaitSkill.in?currentSkill:{currentSkill|currentSkill <- carryBallOnBallPlacement_Skill, true} -> share__choice(set_currentSkill!currentSkill -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; jCheckCurrentSkill::enter -> SKIP)))
			 	 [] dbisim(((currentSkill==lastSkill))&(internal__!NID_jCheckCurrentSkill -> SKIP ;  ((SKIP ; sWaitSkill::enter -> SKIP))))
			 	 [] dbisim(((currentSkill!=lastSkill))&(internal__!NID_jCheckCurrentSkill -> SKIP ;  ((SKIP ; jStopLastSkill::enter -> SKIP))))
			 	 [] dbisim(((lastSkill==carryBallOnBallPlacement_Skill_GO_TO_BEHIND_BALL))&(internal__!NID_jStopLastSkill -> SKIP ;  ((true&(share__choice(stopGoToBehindBall.out -> SKIP)) ; jStartCurrentSkill::enter -> SKIP))))
			 	 [] dbisim(((lastSkill==carryBallOnBallPlacement_Skill_APPROACH_BALL))&(internal__!NID_jStopLastSkill -> SKIP ;  ((true&(share__choice(stopApproachBall.out -> SKIP)) ; jStartCurrentSkill::enter -> SKIP))))
			 	 [] dbisim(((lastSkill==carryBallOnBallPlacement_Skill_CARRY_BALL))&(internal__!NID_jStopLastSkill -> SKIP ;  ((true&(share__choice(stopCarryBall.out -> SKIP)) ; jStartCurrentSkill::enter -> SKIP))))
			 	 [] dbisim(((lastSkill==carryBallOnBallPlacement_Skill_MOVE_AWAY_FROM_POSITION))&(internal__!NID_jStopLastSkill -> SKIP ;  ((true&(share__choice(stopMoveAwayFromPosition.out -> SKIP)) ; jStartCurrentSkill::enter -> SKIP))))
			 	 [] dbisim(((currentSkill==carryBallOnBallPlacement_Skill_GO_TO_BEHIND_BALL))&(internal__!NID_jStartCurrentSkill -> SKIP ;  ((true&(share__choice(startGoToBehindBall.out -> SKIP)) ; sWaitSkill::enter -> SKIP))))
			 ) ; Trans)
			 []
			 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
			 []
			 terminate -> SKIP
		)
		)
	within
		Trans
	)
	)
	
	-- Stateful
	-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
	
	-- Named process definitions
	MachineBody(id__) = 
		dbisim((
		let
			finalNodesEntered = {||}
		within
			((let
				-- IMPLEMENTATION NOTE:
				-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
				-- modules for defining the semantics of each node.
				enterSS = {|
				sInitial::enter,
				sWaitSkill::enter,
				jCheckCurrentSkill::enter,
				jStopLastSkill::enter,
				jStartCurrentSkill::enter
				|}
				hideSet = union(enterSS,{|exit,exited,internal__|})
			within 
				((let
					-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
					-- because CSPM modules are used for the semantics of Node.
					flowevts = union(enterSS,{|exit,exited,interrupt|})
					transSync = {|internal__.NID_sInitial,receiveSkill__.NID_sWaitSkill.in,internal__.NID_jCheckCurrentSkill,internal__.NID_jCheckCurrentSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStartCurrentSkill|}
				within
					((
					 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
					   sInitial::D__(id__)
					   [| { share__, terminate } |] (
					   sWaitSkill::D__(id__)
					   [| { share__, terminate } |] (
					   jCheckCurrentSkill::D__(id__)
					   [| { share__, terminate } |] (
					   jStopLastSkill::D__(id__)
					   [| { share__, terminate } |] (
					   jStartCurrentSkill::D__(id__)
					   )
					   )
					   )
					   )
					 )
					 [[sWaitSkill::interrupt <- x__ | x__ <- {|interrupt,receiveSkill__.NID_sWaitSkill.in|}]]
					 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
					 [[jCheckCurrentSkill::interrupt <- x__ | x__ <- {|internal__.NID_jCheckCurrentSkill,internal__.NID_jCheckCurrentSkill|}]]
					 [[jStopLastSkill::interrupt <- x__ | x__ <- {|internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill|}]]
					 [[jStartCurrentSkill::interrupt <- x__ | x__ <- {|internal__.NID_jStartCurrentSkill|}]]
					 )
					  [[ share__ <- x__ | x__ <- {| share__,setR_currentSkill |} ]] 
					  [[set_currentSkill <- setL_currentSkill,set_lastSkill <- setL_lastSkill]]
					 )
					 [| union(union(union(flowevts,transSync),{terminate}),{|share__
					 			,setL_currentSkill
					 			,setL_lastSkill
					 			,setR_currentSkill
					 			|}) |]
					 ((sInitial::enter -> Transitions(id__))
					  [[ share__ <- x__ | x__ <- {| share__,setL_currentSkill,setL_lastSkill |} ]]
					  [[set_currentSkill <- setR_currentSkill]]
					 )
					)[[setL_currentSkill <- set_currentSkill,setL_lastSkill <- set_lastSkill]]
					 [[setR_currentSkill <- set_currentSkill]]
					)
				)
				 \ hideSet)
				[[
					receiveSkill__.x____ <- receiveSkill,
					sendAction__.x____ <- sendAction,
					startGoToBehindBall__.x____ <- startGoToBehindBall,
					stopGoToBehindBall__.x____ <- stopGoToBehindBall,
					startApproachBall__.x____ <- startApproachBall,
					stopApproachBall__.x____ <- stopApproachBall,
					startCarryBall__.x____ <- startCarryBall,
					stopCarryBall__.x____ <- stopCarryBall,
					startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
					stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
					| x____ <- NIDS
				]]
			)
			 [| {| interrupt |} |] SKIP)
		)
		)
	
	Behaviour(id__) = 
		dbisim((MachineBody(id__)\ enteredSS)
		)
	
	IteratedBehaviour(id__) = 
		dbisim((MachineBody(id__)\ enteredSS)
		)
	
	Stateful(id__) = 
		((
			(Behaviour(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
		 	\getsetLocalChannels
		)
		)
	
	IteratedStateful(id__) =
		(dbisim(
			sbisim(
				dbisim(
					sbisim(
						Behaviour(id__)
						[| {|get_lastSkill,set_lastSkill,terminate|} |]
						Memory_lastSkill(carryBallOnBallPlacement_Skill_GO_TO_BEHIND_BALL)
					)\{|get_lastSkill,set_lastSkill|}
				)
				[| {|get_currentSkill,set_currentSkill,terminate|} |]
				Memory_currentSkill(carryBallOnBallPlacement_Skill_GO_TO_BEHIND_BALL)
			)\{|get_currentSkill,set_currentSkill|}
		)
		)
	
	-- Visible counterparts
	MachineBody_VS_O(id__) = 
		dbisim((
		let
			finalNodesEntered = {||}
		within
			((let
				-- IMPLEMENTATION NOTE:
				-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
				-- modules for defining the semantics of each node.
				enterSS = {|
				sInitial::enter,
				sWaitSkill::enter,
				jCheckCurrentSkill::enter,
				jStopLastSkill::enter,
				jStartCurrentSkill::enter
				|}
				hideSet = union(enterSS,{|exit,exited,internal__|})
			within 
				((let
					-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
					-- because CSPM modules are used for the semantics of Node.
					flowevts = union(enterSS,{|exit,exited,interrupt|})
					transSync = {|internal__.NID_sInitial,receiveSkill__.NID_sWaitSkill.in,internal__.NID_jCheckCurrentSkill,internal__.NID_jCheckCurrentSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStartCurrentSkill|}
				within
					((
					 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
					   sInitial::VS_O__(id__)
					   [| { share__, terminate } |] (
					   sWaitSkill::VS_O__(id__)
					   [| { share__, terminate } |] (
					   jCheckCurrentSkill::VS_O__(id__)
					   [| { share__, terminate } |] (
					   jStopLastSkill::VS_O__(id__)
					   [| { share__, terminate } |] (
					   jStartCurrentSkill::VS_O__(id__)
					   )
					   )
					   )
					   )
					 )
					 [[sWaitSkill::interrupt <- x__ | x__ <- {|interrupt,receiveSkill__.NID_sWaitSkill.in|}]]
					 [[sInitial::interrupt <- x__ | x__ <- {|internal__.NID_sInitial|}]]
					 [[jCheckCurrentSkill::interrupt <- x__ | x__ <- {|internal__.NID_jCheckCurrentSkill,internal__.NID_jCheckCurrentSkill|}]]
					 [[jStopLastSkill::interrupt <- x__ | x__ <- {|internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill,internal__.NID_jStopLastSkill|}]]
					 [[jStartCurrentSkill::interrupt <- x__ | x__ <- {|internal__.NID_jStartCurrentSkill|}]]
					 )
					  [[ share__ <- x__ | x__ <- {| share__,setR_currentSkill |} ]] 
					  [[set_currentSkill <- setL_currentSkill,set_lastSkill <- setL_lastSkill]]
					 )
					 [| union(union(union(flowevts,transSync),{terminate}),{|share__
					 			,setL_currentSkill
					 			,setL_lastSkill
					 			,setR_currentSkill
					 			|}) |]
					 ((sInitial::enter -> Transitions(id__))
					  [[ share__ <- x__ | x__ <- {| share__,setL_currentSkill,setL_lastSkill |} ]]
					  [[set_currentSkill <- setR_currentSkill]]
					 )
					)[[setL_currentSkill <- set_currentSkill,setL_lastSkill <- set_lastSkill]]
					 [[setR_currentSkill <- set_currentSkill]]
					)
				)
				 \ hideSet)
				[[
					receiveSkill__.x____ <- receiveSkill,
					sendAction__.x____ <- sendAction,
					startGoToBehindBall__.x____ <- startGoToBehindBall,
					stopGoToBehindBall__.x____ <- stopGoToBehindBall,
					startApproachBall__.x____ <- startApproachBall,
					stopApproachBall__.x____ <- stopApproachBall,
					startCarryBall__.x____ <- startCarryBall,
					stopCarryBall__.x____ <- stopCarryBall,
					startMoveAwayFromPosition__.x____ <- startMoveAwayFromPosition,
					stopMoveAwayFromPosition__.x____ <- stopMoveAwayFromPosition
					| x____ <- NIDS
				]]
			)
			 [| {| interrupt |} |] SKIP)
		)
		)
	
	Behaviour_VS_O(id__) = 
		dbisim((MachineBody_VS_O(id__))
		)
	
	IteratedBehaviour_VS_O(id__) = 
		dbisim((MachineBody_VS_O(id__))
		)
	
	Stateful_VS_O(id__) = 
		dbisim((
			(Behaviour_VS_O(id__) [| union(getsetLocalChannels,{terminate}) |] varMemory(id__))
		 	\getsetLocalChannels
		)
		)
	
	IteratedStateful_VS_O(id__) =
		(dbisim(
			sbisim(
				dbisim(
					sbisim(
						Behaviour_VS_O(id__)
						[| {|get_lastSkill,set_lastSkill,terminate|} |]
						Memory_lastSkill(carryBallOnBallPlacement_Skill_GO_TO_BEHIND_BALL)
					)\{|get_lastSkill,set_lastSkill|}
				)
				[| {|get_currentSkill,set_currentSkill,terminate|} |]
				Memory_currentSkill(carryBallOnBallPlacement_Skill_GO_TO_BEHIND_BALL)
			)\{|get_currentSkill,set_currentSkill|}
		)
		)
	
	-- END
	
	-- Memory
	-- Memory variables
	Memory_currentSkill(currentSkill) =
		get_currentSkill!currentSkill -> Memory_currentSkill(currentSkill)
		[]
		set_currentSkill?x__ -> Memory_currentSkill(x__)
		[]
		terminate -> SKIP
	Memory_lastSkill(lastSkill) =
		get_lastSkill!lastSkill -> Memory_lastSkill(lastSkill)
		[]
		set_lastSkill?x__ -> Memory_lastSkill(x__)
		[]
		terminate -> SKIP
	
	-- varMemory process
	varMemory(id__) = Memory_currentSkill(carryBallOnBallPlacement_Skill_GO_TO_BEHIND_BALL)
	[| { terminate } |] (
	Memory_lastSkill(carryBallOnBallPlacement_Skill_GO_TO_BEHIND_BALL)
	)
	
	getsetLocalChannels = {|get_currentSkill,set_currentSkill,get_lastSkill,set_lastSkill|}
	
	-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
	FVS__(id__) = STM_VS_O(id__)
	
	D__(id__) = STM(id__) \ internal_events
	O__(id__) = sbisim(diamond(D__(id__)))
	VS__(id__) = FVS__(id__)
	VS_O__(id__) = sbisim(diamond(FVS__(id__)))
	HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
	HUP__(id__) = O__(id__) [|{share__}|] SKIP
	
	-- Shared memory
	-- Shared memory variables
	
	-- sharedVarMemory process
	sharedVarMemory(id__) = terminate -> SKIP
	
	sharedVarSync = {||}
	
	sharedVarHide = {||}
endmodule


endmodule
