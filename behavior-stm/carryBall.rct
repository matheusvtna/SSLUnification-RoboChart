import utils

// --------------------------------------------
//                 CARRY BALL
// --------------------------------------------
interface CarryBallI {
	carryBall(frame: Frame, targetPosition: Point, distanceThreshold: real)
}

// This operation makes robot move to a target position
// by carrying the ball. It succeeds when the ball is
// at the target position and it fails if the robot
// loses the ball on carry.
//
// @param ball: Ball.
// @param angleThreshold: real.
//
// TODO: Add a FSM output -> makes robot move...
operation carryBall(frame: Frame, targetPosition: Point, distanceThreshold: real) {
	requires GetDistanceBetweenTwoPointsI
	requires AllyHasBallI
	requires NodeStatusI	
	
	var robot: Robot = frame.robot
	var ball: Ball = frame.ball
	var ballPosition: Point = ball.pos
	var ballIsPositioned: boolean
	

	// Variables conditions.
	var allyHasBall: boolean
	
	// States.
	initial sInitial
	state sCarryBall {
		entry
			nodeStatus = NODE_STATUS::RUNNING;
			GetDistanceBetweenTwoPoints(ballPosition, targetPosition); 
			ballIsPositioned = getDistanceBetweenTwoPointsResult < distanceThreshold;
			
			AllyHasBall(robot, ball);
			allyHasBall = allyHasBallResult
	}
	final sFinal
	
	// Transitions.
	transition start {
		from sInitial
		to sCarryBall
	}
	
	transition success {		
		from sCarryBall
		to sFinal
		condition ballIsPositioned
		action nodeStatus = NODE_STATUS::DONE
	}
	
	transition recalculate {
		from sCarryBall
		to sCarryBall
		condition (not ballIsPositioned) /\ allyHasBall
		action nodeStatus = NODE_STATUS::RUNNING
	}
	
	transition fail {		
		from sCarryBall
		to sFinal
		condition not allyHasBall
		action nodeStatus = NODE_STATUS::FAILED
	}
}
