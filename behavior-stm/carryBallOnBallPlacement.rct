package behavior

import goToBehindBall
import approachBall
import carryBall
import moveAwayFromPosition

// TODO: Move BehaviorSTM, IBehavior and BehaviorController away.
interface BehaviorI {
	// Input events.
	event receiveFrame: string
	event receiveField: string
	event receiveTactic: Tactic
		
	// Output events.
	event sendAction: Action	
}

interface TacticI {
	var skill: Skill
}

interface CarryBallOnBallPlacementI {
	event startCarryBallOnBallPlacement
	event stopCarryBallOnBallPlacement
	event carryBallOnBallPlacementSkill
}

interface HaltI {
	event startHalt
	event stopHalt
	event haltSkill
}

// TODO: Move to specific file...
interface SkillI {
	event receiveSkill: Skill
}

enumeration Skill {
	NONE
	GO_TO_BEHIND_BALL
	APPROACH_BALL
	CARRY_BALL
	MOVE_AWAY_FROM_POSITION
}

controller BehaviorController {
	var currentTactic: Tactic
	
	uses BehaviorI
	uses TacticI
	uses NodeStatusI
		
	sref stm_behavior_ref = behavior::BehaviorSTM
	connection BehaviorController on receiveField to stm_behavior_ref on receiveField
	connection BehaviorController on receiveFrame to stm_behavior_ref on receiveFrame
	connection BehaviorController on receiveTactic to stm_behavior_ref on receiveTactic

	sref stm_carry_ball_on_ball_placement_ref = behavior::CarryBallOnBallPlacementSTM
	connection stm_behavior_ref on startCarryBallOnBallPlacement to stm_carry_ball_on_ball_placement_ref on startCarryBallOnBallPlacement
	connection stm_behavior_ref on stopCarryBallOnBallPlacement to stm_carry_ball_on_ball_placement_ref on stopCarryBallOnBallPlacement

	// Sub-FSMs.
	sref stm_go_to_behind_ball_ref = behavior::GoToBehindBallSTM
	sref stm_approach_ball_ref = behavior::ApproachBallSTM
	sref stm_carry_ball_ref = behavior::CarryBallSTM
	sref stm_move_away_ref = behavior::MoveAwayFromPositionSTM

	sref stm_skill_ref = behavior::SkillSTM
	connection stm_skill_ref on startGoToBehindBall to stm_go_to_behind_ball_ref on startGoToBehindBall
	connection stm_skill_ref on stopGoToBehindBall to stm_go_to_behind_ball_ref on stopGoToBehindBall
	connection stm_skill_ref on startApproachBall to stm_approach_ball_ref on startApproachBall
	connection stm_skill_ref on stopApproachBall to stm_approach_ball_ref on stopApproachBall
	connection stm_skill_ref on startCarryBall to stm_carry_ball_ref on startCarryBall
	connection stm_skill_ref on stopCarryBall to stm_carry_ball_ref on stopCarryBall
	connection stm_skill_ref on startMoveAwayFromPosition to stm_move_away_ref on startMoveAwayFromPosition
	connection stm_skill_ref on stopMoveAwayFromPosition to stm_move_away_ref on stopMoveAwayFromPosition
	
	connection stm_carry_ball_on_ball_placement_ref on carryBallOnBallPlacementSkill to stm_behavior_ref on carryBallOnBallPlacementSkill
	connection stm_behavior_ref on sendAction to BehaviorController on sendAction

	sref stm_halt_ref = HaltSTM
	connection stm_behavior_ref on startHalt to stm_halt_ref on startHalt
	connection stm_behavior_ref on stopHalt to stm_halt_ref on stopHalt
	connection stm_halt_ref on haltSkill to stm_behavior_ref on haltSkill
	connection stm_behavior_ref on sendSkill to stm_skill_ref on receiveSkill
	connection stm_go_to_behind_ball_ref on goToBehindBallAction to stm_skill_ref on goToBehindBallAction
	connection stm_approach_ball_ref on approachBallAction to stm_skill_ref on approachBallAction
	connection stm_carry_ball_ref on carryBallAction to stm_skill_ref on carryBallAction
	connection stm_move_away_ref on moveAwayAction to stm_skill_ref on moveAwayAction
	connection stm_skill_ref on sendAction to stm_behavior_ref on receiveAction
}
// END TODO

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

stm CarryBallOnBallPlacementSTM {
	// Controls the start/stop for this BehaviorSTM --> Input events.
	uses CarryBallOnBallPlacementI
	
	// Control the Skill for this behaviorSTM --> Output events.
	uses TacticI
	
	// Defines the status of each node within the Behavior Tree.
	requires NodeStatusI
	
	// Conditional variables.
	var robotHasMovedAwayFromBall: boolean
	var runningStm: string
	
	// States.
	initial sInitial
	final sFinal
	
	state sWaitStart {
		entry nodeStatus = NODE_STATUS :: RUNNING
	}
	state sRun {
		// Execution states.
		initial sInitial
		state sGoToBehindBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sGiveSpaceToGetBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sApproachBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sPlaceBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sMoveAwayFromBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		final sFinal
		
		// Success conditions.
		transition AdjustToCarryBall {
			from sInitial
			to sGoToBehindBall
			action skill=Skill::GO_TO_BEHIND_BALL
		}	
		transition TryGoToBehindBallAgain {
			from sGiveSpaceToGetBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::GO_TO_BEHIND_BALL
		}
		transition GetBallControl {
			from sGoToBehindBall
			to sApproachBall
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::APPROACH_BALL
		}
		transition PlaceBallInPosition {
			from sApproachBall
			to sPlaceBall
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::CARRY_BALL
		}
		transition MoveAway {
			from sPlaceBall
			to sMoveAwayFromBall
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::MOVE_AWAY_FROM_POSITION
		}
		transition Finish {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::NONE
		}
	
		// Failure Transitions.
		transition AvoidBall {
			from sGoToBehindBall
			to sGiveSpaceToGetBall
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::MOVE_AWAY_FROM_POSITION
		}
		transition ReadjustToCarryBall {
			from sApproachBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::GO_TO_BEHIND_BALL
		}
		transition LostBallOnCarry {
			from sPlaceBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::GO_TO_BEHIND_BALL
		}
		transition FinishWithFailOnMoveAway {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::NONE
		}
		transition FinishWithFailOnAvoidBall {
			from sGiveSpaceToGetBall
			to sFinal
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::NONE
		}
		transition BallIsOutOfPosition {
			from sMoveAwayFromBall
			to sGoToBehindBall
			condition robotHasMovedAwayFromBall
			action skill=Skill::GO_TO_BEHIND_BALL
		}
		
		// Self Transitions.
		transition KeepGoToBehindBall {
			from sGoToBehindBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepApproachBall {
			from sApproachBall
			to sApproachBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepPlaceBall {
			from sPlaceBall
			to sPlaceBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepMovingAway {
			from sMoveAwayFromBall
			to sMoveAwayFromBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepGivingSpace {
			from sGiveSpaceToGetBall
			to sGiveSpaceToGetBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
			
	}	

	transition waitStart {
		from sInitial
		to sWaitStart
	}
	
	transition run {
		from sWaitStart
		to sRun
		trigger startCarryBallOnBallPlacement
	}
	
	transition abort {
		from sRun
		to sFinal
		trigger stopCarryBallOnBallPlacement
		// Set NONE to stop all Skill STMs.
		action nodeStatus = NODE_STATUS::ABORTED; skill=Skill::NONE

	}
}
// END TODO

// --------------------------------------------
//               BEHAVIOR STM
// --------------------------------------------
stm BehaviorSTM {
	// Input and Output events.
	uses BehaviorI
	
	// Behavior Tree Control Interfaces.
	uses NodeStatusI
	
	// Controls the start/stop for this BehaviorSTM --> Output events.
	uses CarryBallOnBallPlacementI
	uses HaltI
	
	// Controls the Skill/Action for the current tactic.
	uses TacticI
	event sendSkill: Skill
	event receiveAction: Action
	
	// The current Action.
	//
	// Receives value from `receiveAction` event from SkillSTM.
	var currentAction: Action
	
	// The current Skill.
	//
	// Receives value from different skill events.
	var currentSkill:Skill
	
	// Current Tactic.
	//
	// Receives value from `receiveTactic` event.
	var currentTactic:Tactic
	
	// Last Tactic.
	var lastTactic:Tactic
	
	// States.
	initial sInitial
	state sWaitTacticOrSkillOrAction {}
	junction jCheckCurrentTactic
	junction jStopLastTactic
	junction jStartCurrentTactic
	junction jCheckSkillForPlaceBallInPositionTactic
	junction jCheckSkillForHaltTactic
	junction jSendAction
	
	// Transitions.
	//
	// Start transition. Just wait for a tactic.
	transition start {
		from sInitial
		to sWaitTacticOrSkillOrAction
	}
	
	// A tactic has been received.
	transition receiveTactic {
		from sWaitTacticOrSkillOrAction
		to jCheckCurrentTactic
		trigger receiveTactic?currentTactic
	}
	
	// The received tactic is equals to the last one.
	// In this case, we just keep the same behavior STM
	// running and don't trigger any event.
	transition sameTactic {
		from jCheckCurrentTactic
		to sWaitTacticOrSkillOrAction
		condition currentTactic == lastTactic
	}
	
	// The received tactic is different from the last one.
	// In this case, we have to stop the current behavior STM
	// that it is running to be able to start a new one later.
	transition differentTactic {
		from jCheckCurrentTactic
		to jStopLastTactic
		condition currentTactic != lastTactic
	}	

	// Triggers a `stopCarryBallOnBallPlacementBehavior` event to 
	// stop the CarryBallOnBallPlacementSTM if the last tactic was
	// Tactic::PLACE_BALL_IN_POSITION and the new one it is not.
	transition stopCarryBallOnBallPlacement {
		from jStopLastTactic
		to jStartCurrentTactic
		condition lastTactic == Tactic::PLACE_BALL_IN_POSITION
		action stopCarryBallOnBallPlacement
	}
	
	// Triggers a `stopHalt` event to stop the HaltSTM if the last 
	// tactic was Tactic::HALT and the new one it is not.
	transition stopHalt {
		from jStopLastTactic
		to jStartCurrentTactic
		condition lastTactic == Tactic :: HALT
		action stopHalt
	}

	// Triggers a `startCarryBallOnBallPlacementBehavior` event to 
	// start the CarryBallOnBallPlacementSTM if the current tactic
	// is Tactic::PLACE_BALL_IN_POSITION.
	transition startCarryBallOnBallPlacement {
		from jStartCurrentTactic
		to sWaitTacticOrSkillOrAction
		condition currentTactic == Tactic :: PLACE_BALL_IN_POSITION
		action startCarryBallOnBallPlacement
	}
	
	// Trigger a `startHalt` event to start the HaltSTM if the current 
	// tactic is Tactic::HALT.
	transition startHalt {
		from jStartCurrentTactic
		to sWaitTacticOrSkillOrAction
		condition currentTactic == Tactic :: HALT
		action startHalt
	}

	// Receives CarryBalloOnBallPlacementSkill.
	transition carryBallOnBallPlacementSkill {
		from sWaitTacticOrSkillOrAction
		to jCheckSkillForPlaceBallInPositionTactic
		trigger carryBallOnBallPlacementSkill
	}
	transition sendCarryBallPlacementSkill {
		from jCheckSkillForPlaceBallInPositionTactic
		to sWaitTacticOrSkillOrAction
		condition currentTactic == Tactic :: PLACE_BALL_IN_POSITION
		action sendSkill!currentSkill
	}
	transition carryBallPlacemenSkilltIsWrong {
		from jCheckSkillForPlaceBallInPositionTactic
		to sWaitTacticOrSkillOrAction
		condition currentTactic != Tactic :: PLACE_BALL_IN_POSITION
	}
	
	// Receives HaltSkill.
	transition haltSkill {
		from sWaitTacticOrSkillOrAction
		to jCheckSkillForHaltTactic
		trigger haltSkill
	}
	transition sendHaltSkill {
		from jCheckSkillForHaltTactic
		to sWaitTacticOrSkillOrAction
		condition currentTactic == Tactic :: HALT
		action sendSkill ! currentSkill
	}
	transition haltSkilltIsWrong {
		from jCheckSkillForHaltTactic
		to sWaitTacticOrSkillOrAction
		condition currentTactic != Tactic :: HALT
	}

	transition sendAction {
		from sWaitTacticOrSkillOrAction
		to jSendAction
		trigger receiveAction?currentAction
		action sendAction!currentAction
	}
	transition waitNextTacticOrSkillOrAction {
		from jSendAction
		to sWaitTacticOrSkillOrAction
	}
}

// --------------------------------------------
//               SKILL STM
// --------------------------------------------
stm SkillSTM {
	// Interface to define SkillSTM requirements.
	uses SkillI
	
	// Current Skill.
	//
	// Receives value from `receiveSkill` event.
	var currentSkill: Skill
	
	// Last Skill.
	var lastSkill:Skill
	
	// Controls the Action for the current skill.
	event sendAction: Action
	var currentAction: Action
	
	// States.
	initial sInitial
	state sWaitSkillOrAction {}
	junction jCheckCurrentSkill
	junction jStopLastSkill
	junction jStartCurrentSkill
	junction jCheckActionForGoToBehindBallSkill
	junction jCheckActionForApproachBallSkill
	junction jCheckActionForCarryBallSkill
	junction jCheckActionForMoveAwaySkill

	// Sub-FSMs --> Output events.
	uses behavior::GoToBehindBallI
	uses behavior::ApproachBallI
	uses behavior::CarryBallI
	uses behavior::MoveAwayFromPositionI	
	
	// Transitions.
	//
	// Start transition. Just wait for a Skill.
	transition start {
		from sInitial
		to sWaitSkillOrAction
	}
	
	// A Skill has been received.
	transition receiveSkill {
		from sWaitSkillOrAction
		to jCheckCurrentSkill
		trigger receiveSkill?currentSkill
	}
	
	// The received Skill is equals to the last one.
	// In this case, we just keep the same skill STM
	// running and don't trigger any event.
	transition sameSkill {
		from jCheckCurrentSkill
		to sWaitSkillOrAction
		condition currentSkill == lastSkill
	}
	
	// The received Skill is different from the last one.
	// In this case, we have to stop the current skill STM
	// that it is running to be able to start a new one later.
	transition differentSkill {
		from jCheckCurrentSkill
		to jStopLastSkill
		condition currentSkill != lastSkill
	}	

	// Triggers a `stopGoToBehindBall` event to 
	// stop the GoToBehindBallSTM if the last Skill was
	// Skill::GO_TO_BEHIND_BALL and the new one it is not.
	transition stopGoToBehindBall {
		from jStopLastSkill
		to jStartCurrentSkill
		condition lastSkill == Skill::GO_TO_BEHIND_BALL
		action stopGoToBehindBall
	}
	
	// Triggers a `stopApproachBall` event to 
	// stop the ApproachBallSTM if the last Skill was
	// Skill::APPROACH_BALL and the new one it is not.
	transition stopApproachBall {
		from jStopLastSkill
		to jStartCurrentSkill
		condition lastSkill == Skill::APPROACH_BALL
		action stopApproachBall
	}
	
	// Triggers a `stopCarryBall` event to 
	// stop the CarryBallSTM if the last Skill was
	// Skill::CARRY_BALL and the new one it is not.
	transition stopCarryBall {
		from jStopLastSkill
		to jStartCurrentSkill
		condition lastSkill == Skill::CARRY_BALL
		action stopCarryBall
	}
	
	// Triggers a `stopMoveAwayFromPosition` event to 
	// stop the MoveAwayFromPositionSTM if the last Skill was
	// Skill::MOVE_AWAY_FROM_POSITION and the new one it is not.
	transition stopMoveAwayFromPosition {
		from jStopLastSkill
		to jStartCurrentSkill
		condition lastSkill == Skill::MOVE_AWAY_FROM_POSITION
		action stopMoveAwayFromPosition
	}

	// Triggers a `startGoToBehindBall` event to 
	// start the GoToBehindBallSTM if the current skill
	// is Skill::GO_TO_BEHIND_BALL.
	transition startGoToBehindBall {
		from jStartCurrentSkill
		to sWaitSkillOrAction
		condition currentSkill == Skill::GO_TO_BEHIND_BALL
		action startGoToBehindBall
	}
	
	// Triggers a `startApproachBall` event to 
	// start the ApproachBallSTM if the current skill
	// is Skill::APPROACH_BALL.
	transition startApproachBall {
		from jStartCurrentSkill
		to sWaitSkillOrAction
		condition currentSkill == Skill :: APPROACH_BALL
		action startApproachBall
	}
	
	// Triggers a `startCarryBall` event to 
	// start the CarryBallSTM if the current skill
	// is Skill::CARRY_BALL.
	transition startCarryBall {
		from jStartCurrentSkill
		to sWaitSkillOrAction
		condition currentSkill == Skill :: CARRY_BALL
		action startCarryBall
	}
	
	// Triggers a `startMoveAwayFromPosition` event to 
	// start the MoveAwayFromPositionSTM if the current skill
	// is Skill::MOVE_AWAY_FROM_POSITION.
	transition startMoveAwayFromPosition {
		from jStartCurrentSkill
		to sWaitSkillOrAction
		condition currentSkill == Skill :: MOVE_AWAY_FROM_POSITION
		action startMoveAwayFromPosition
	}

	// Receives GoToBehindBallAction.
	transition goToBehindBallAction {
		from sWaitSkillOrAction
		to jCheckActionForGoToBehindBallSkill
		trigger goToBehindBallAction?currentAction
	}
	transition sendGoToBehindBallAction {
		from jCheckActionForGoToBehindBallSkill
		to sWaitSkillOrAction
		condition currentSkill == Skill :: GO_TO_BEHIND_BALL
		action sendAction ! currentAction
	}
	transition goToBehindBallActionIsWrong {
		from jCheckActionForGoToBehindBallSkill
		to sWaitSkillOrAction
		condition currentSkill != GO_TO_BEHIND_BALL
	}
	
	// Receives ApproachBallAction.
	transition approachBallAction {
		from sWaitSkillOrAction
		to jCheckActionForApproachBallSkill
		trigger approachBallAction ? currentAction
	}
	transition sendApproachBallAction {
		from jCheckActionForApproachBallSkill
		to sWaitSkillOrAction
		condition currentSkill == Skill :: APPROACH_BALL
		action sendAction ! currentAction
	}
	transition approachBallActionIsWrong {
		from jCheckActionForApproachBallSkill
		to sWaitSkillOrAction
		condition currentSkill != Skill :: APPROACH_BALL
	}
	
	// Receives CarryBallAction.
	transition carryBallAction {
		from sWaitSkillOrAction
		to jCheckActionForCarryBallSkill
		trigger carryBallAction ? currentAction
	}
	transition sendCarryBallAction {
		from jCheckActionForCarryBallSkill
		to sWaitSkillOrAction
		condition currentSkill == Skill :: CARRY_BALL
		action sendAction ! currentAction
	}
	transition carryBallActionIsWrong {
		from jCheckActionForCarryBallSkill
		to sWaitSkillOrAction
		condition currentSkill != Skill :: CARRY_BALL
	}
	
	// Receives MoveAwayAction.
	transition moveAwayAction {
		from sWaitSkillOrAction
		to jCheckActionForMoveAwaySkill
		trigger moveAwayAction ? currentAction
	}
	transition sendMoveAwayAction {
		from jCheckActionForMoveAwaySkill
		to sWaitSkillOrAction
		condition currentSkill == Skill :: MOVE_AWAY_FROM_POSITION
		action sendAction ! currentAction
	}
	transition moveAwayActionIsWrong {
		from jCheckActionForMoveAwaySkill
		to sWaitSkillOrAction
		condition currentSkill != Skill :: MOVE_AWAY_FROM_POSITION
	}
}


stm HaltSTM {
	// Controls the start/stop for this BehaviorSTM --> Input events.
	uses HaltI
	
	// Control the Skill for this behaviorSTM --> Output events.
	uses TacticI
	
	// Defines the status of each node within the Behavior Tree.
	requires NodeStatusI
	
	// States.
	initial sInitial
	final sFinal
	
	state sWaitStart {
		entry nodeStatus = NODE_STATUS :: RUNNING
	}
	state sRun {
		// Execution states.
		initial sInitial
		final sFinal
		
		transition finish {
			from sInitial
			to sFinal
		}	
	}	

	transition waitStart {
		from sInitial
		to sWaitStart
	}
	
	transition run {
		from sWaitStart
		to sRun
		trigger startHalt
		action skill=Skill::NONE
	}
	
	transition abort {
		from sRun
		to sFinal
		trigger stopHalt
		// Set NONE to stop all Skill STMs.
		action nodeStatus = NODE_STATUS::ABORTED; skill=Skill::NONE
	}
}
