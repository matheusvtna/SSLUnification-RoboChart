package carryBallOnBallPlacement

import goToBehindBall
import approachBall
import carryBall
import moveAwayFromPosition

// TODO: Move BehaviorSTM, IBehavior and BehaviorController away.
interface IBehavior {
	event receiveFrame: string
	event receiveField: string
	event receiveTactic: Tactic
	
	// Carry Ball On Ball Placement.
	event startCarryBallOnBallPlacementBehavior
	event stopCarryBallOnBallPlacementBehavior
	
	// Halt.
	event startHaltBehavior
	event stopHaltBehavior
	
	// TODO: Create other behavior events...
}

interface CarryBallOnBallPlacementI {
	event startCarryBallOnBallPlacement
	event stopCarryBallOnBallPlacement	
}

// This state machine makes the robot execute the
// Ball Placement procedure by carrying the ball.
//
// TODO: Add a FSM output -> makes robot move...
controller BehaviorController {
	uses IBehavior
	sref stm_ref0 = BehaviorSTM
}
// END TODO

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

stm CarryBallOnBallPlacementSTM {
	// Controls the start/stop for this BehaviorSTM.
	uses CarryBallOnBallPlacementI
	
	// Sub-FSMs
	uses GoToBehindBallI
	uses ApproachBallI
	uses CarryBallI
	uses MoveAwayFromPositionI	
	
	// Defines the status of each node within the Behavior Tree.
	requires NodeStatusI
	
	// Conditional variables.
	var robotHasMovedAwayFromBall: boolean

	// States.
	initial sInitial
	state sWaitStart {
		entry nodeStatus = NODE_STATUS::RUNNING	
	}
	state sRun {
		// Execution states.
		initial sInitial
		state sGoToBehindBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sGiveSpaceToGetBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sApproachBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sPlaceBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sMoveAwayFromBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		final sFinal
		
		// Success conditions.
		transition AdjustToCarryBall {
			from sInitial
			to sGoToBehindBall
			action startGoToBehindBall
		}	
		transition TryGoToBehindBallAgain {
			from sGiveSpaceToGetBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::DONE
			action stopMoveAwayFromPosition; startGoToBehindBall
		}
		transition GetBallControl {
			from sGoToBehindBall
			to sApproachBall
			condition nodeStatus == NODE_STATUS::DONE
			action stopGoToBehindBall; startApproachBall
		}
		transition PlaceBallInPosition {
			from sApproachBall
			to sPlaceBall
			condition nodeStatus == NODE_STATUS::DONE
			action stopApproachBall; startCarryBall
		}
		transition MoveAway {
			from sPlaceBall
			to sMoveAwayFromBall
			condition nodeStatus == NODE_STATUS::DONE
			action stopCarryBall; startMoveAwayFromPosition
		}
		transition Finish {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::DONE
			action stopMoveAwayFromPosition
		}
	
		// Failure Transitions.
		transition AvoidBall {
			from sGoToBehindBall
			to sGiveSpaceToGetBall
			condition nodeStatus == NODE_STATUS::FAILED
			action stopGoToBehindBall; startMoveAwayFromPosition
		}
		transition ReadjustToCarryBall {
			from sApproachBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::FAILED
			action stopApproachBall; startGoToBehindBall
		}
		transition LostBallOnCarry {
			from sPlaceBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::FAILED
			action stopCarryBall; startGoToBehindBall
		}
		transition FinishWithFailOnMoveAway {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::FAILED
			action stopMoveAwayFromPosition
		}
		transition FinishWithFailOnAvoidBall {
			from sGiveSpaceToGetBall
			to sFinal
			condition nodeStatus == NODE_STATUS::FAILED
			action stopGoToBehindBall
		}
		transition BallIsOutOfPosition {
			from sMoveAwayFromBall
			to sGoToBehindBall
			condition robotHasMovedAwayFromBall
			action stopMoveAwayFromPosition; startGoToBehindBall
		}
		
		// Self Transitions.
		transition KeepGoToBehindBall {
			from sGoToBehindBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepApproachBall {
			from sApproachBall
			to sApproachBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepPlaceBall {
			from sPlaceBall
			to sPlaceBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepMovingAway {
			from sMoveAwayFromBall
			to sMoveAwayFromBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepGivingSpace {
			from sGiveSpaceToGetBall
			to sGiveSpaceToGetBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		
		// Aborted Transitions.
		transition GameEventChangedOnGoToBall {
			from sGoToBehindBall
			to sFinal
			condition nodeStatus == NODE_STATUS::ABORTED
			action stopGoToBehindBall
		}
		transition GameEventChangedApproachBall {
			from sApproachBall
			to sFinal
			condition nodeStatus == NODE_STATUS::ABORTED
			action stopApproachBall
		}
		transition GameEventChangedCarryBall {
			from sPlaceBall
			to sFinal
			condition nodeStatus == NODE_STATUS::ABORTED
			action stopCarryBall
		}
		transition GameEventChangedOnMoveAwayFromBall {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::ABORTED
			action stopMoveAwayFromPosition
		}
		transition GameEventChangedOnGivingSpaceToBall {
			from sGiveSpaceToGetBall
			to sFinal
			condition nodeStatus == NODE_STATUS::ABORTED
			action stopMoveAwayFromPosition
		}	
	}	

	transition waitStart {
		from sInitial
		to sWaitStart
	}
	
	transition run {
		from sWaitStart
		to sRun
		trigger startCarryBallOnBallPlacement
	}
	
	transition abort {
		from sRun
		to sWaitStart
		trigger stopCarryBallOnBallPlacement
		action nodeStatus = NODE_STATUS::ABORTED
	}
}
// END TODO

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

stm BehaviorSTM {
	// Input and Output events.
	uses IBehavior
	
	// Behavior Tree Control Interfaces.
	uses NodeStatusI
	
	// Current Tactic.
	//
	// Receives value from `receiveTactic` event.
	var currentTactic:Tactic
	
	// Last Tactic.
	var lastTactic:Tactic
	
	// States.
	initial sInitial
	state sWaitTactic {}
	junction jCheckCurrentTactic
	junction jStopLastTactic
	junction jStartCurrentTactic
	
	// Transitions.
	//
	// Start transition. Just wait for a tactic.
	transition start {
		from sInitial
		to sWaitTactic
	}
	
	// A tactic has been received.
	transition receiveTactic {
		from sWaitTactic
		to jCheckCurrentTactic
		trigger receiveTactic?currentTactic
	}
	
	// The received tactic is equals to the last one.
	// In this case, we just keep the same behavior STM
	// running and don't trigger any event.
	transition sameTactic {
		from jCheckCurrentTactic
		to sWaitTactic
		condition currentTactic == lastTactic
	}
	
	// The received tactic is different from the last one.
	// In this case, we have to stop the current behavior STM
	// that it is running to be able to start a new one later.
	transition differentTactic {
		from jCheckCurrentTactic
		to jStopLastTactic
		condition currentTactic != lastTactic
	}	

	// Triggers a `stopCarryBallOnBallPlacementBehavior` event to 
	// stop the CarryBallOnBallPlacementSTM if the last tactic was
	// Tactic::PLACE_BALL_IN_POSITION and the new one it is not.
	transition stopCarryBallOnBallPlacement {
		from jStopLastTactic
		to jStartCurrentTactic
		condition lastTactic == Tactic::PLACE_BALL_IN_POSITION
		action stopCarryBallOnBallPlacementBehavior
	}
	
	// Triggers a `stopHalt` event to stop the HaltSTM if the last 
	// tactic was Tactic::HALT and the new one it is not.
	transition stopHalt {
		from jStopLastTactic
		to jStartCurrentTactic
		condition lastTactic == Tactic :: HALT
		action stopHaltBehavior
	}

	// Triggers a `startCarryBallOnBallPlacementBehavior` event to 
	// start the CarryBallOnBallPlacementSTM if the current tactic
	// is Tactic::PLACE_BALL_IN_POSITION.
	transition startCarryBallOnBallPlacement {
		from jStartCurrentTactic
		to sWaitTactic
		condition currentTactic == Tactic :: PLACE_BALL_IN_POSITION
		action startCarryBallOnBallPlacementBehavior
	}
	
	// Trigger a `startHalt` event to start the HaltSTM if the current 
	// tactic is Tactic::HALT.
	transition startHalt {
		from jStartCurrentTactic
		to sWaitTactic
		condition currentTactic == Tactic :: HALT
		action startHaltBehavior
	}
}

