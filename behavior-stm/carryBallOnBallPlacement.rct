package carryBallOnBallPlacement

import goToBehindBall
import approachBall
import carryBall
import moveAwayFromPosition

// TODO: Move BehaviorSTM, IBehavior and BehaviorController away.
interface IBehavior {
	event receiveFrame: string
	event receiveField: string
	event receiveTactic: Tactic
	
	event sendAction: string
}

interface CarryBallOnBallPlacementI {
	event startCarryBallOnBallPlacement
	event stopCarryBallOnBallPlacement	
}

interface HaltI {
	event startHalt
	event stopHalt
}

// TODO: Move to specific file...
controller BehaviorController {
	uses IBehavior
	uses NodeStatusI
	sref stm_behavior_ref = BehaviorSTM

	connection BehaviorController on receiveField to stm_behavior_ref on receiveField
	connection BehaviorController on receiveFrame to stm_behavior_ref on receiveFrame
	connection BehaviorController on receiveTactic to stm_behavior_ref on receiveTactic

	sref stm_carry_ball_on_ball_placement_ref = CarryBallOnBallPlacementSTM
	connection stm_behavior_ref on startCarryBallOnBallPlacement to stm_carry_ball_on_ball_placement_ref on startCarryBallOnBallPlacement
	connection stm_behavior_ref on stopCarryBallOnBallPlacement to stm_carry_ball_on_ball_placement_ref on stopCarryBallOnBallPlacement

	// Sub-FSMs.
	sref stm_go_to_behind_ball_ref = GoToBehindBallSTM
	sref stm_approach_ball_ref = ApproachBallSTM
	sref stm_carry_ball_ref = CarryBallSTM
	sref stm_move_away_ref = MoveAwayFromPositionSTM
	connection stm_carry_ball_on_ball_placement_ref on startGoToBehindBall to stm_go_to_behind_ball_ref on startGoToBehindBall
	connection stm_carry_ball_on_ball_placement_ref on stopGoToBehindBall to stm_go_to_behind_ball_ref on stopGoToBehindBall
	connection stm_carry_ball_on_ball_placement_ref on startApproachBall to stm_approach_ball_ref on startApproachBall
	connection stm_carry_ball_on_ball_placement_ref on stopApproachBall to stm_approach_ball_ref on stopApproachBall
	connection stm_carry_ball_on_ball_placement_ref on stopCarryBall to stm_carry_ball_ref on startCarryBall
	connection stm_carry_ball_on_ball_placement_ref on startCarryBall to stm_carry_ball_ref on stopCarryBall
	connection stm_carry_ball_on_ball_placement_ref on startMoveAwayFromPosition to stm_move_away_ref on startMoveAwayFromPosition
	connection stm_carry_ball_on_ball_placement_ref on stopMoveAwayFromPosition to stm_move_away_ref on stopMoveAwayFromPosition
	connection stm_behavior_ref on sendAction to BehaviorController on sendAction
}
// END TODO

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

stm CarryBallOnBallPlacementSTM {
	// Controls the start/stop for this BehaviorSTM --> Input events.
	uses CarryBallOnBallPlacementI
	
	// Sub-FSMs --> Output events.
	uses GoToBehindBallI
	uses ApproachBallI
	uses CarryBallI
	uses MoveAwayFromPositionI	
	
	// Defines the status of each node within the Behavior Tree.
	requires NodeStatusI
	
	// Conditional variables.
	var robotHasMovedAwayFromBall: boolean
	var runningStm: string
	
	// States.
	initial sInitial
	final sFinal
	
	state sWaitStart {
		entry nodeStatus = NODE_STATUS :: RUNNING
	}
	state sRun {
		// Execution states.
		initial sInitial
		state sGoToBehindBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sGiveSpaceToGetBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sApproachBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sPlaceBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sMoveAwayFromBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		final sFinal
		
		// Success conditions.
		transition AdjustToCarryBall {
			from sInitial
			to sGoToBehindBall
			action startGoToBehindBall
		}	
		transition TryGoToBehindBallAgain {
			from sGiveSpaceToGetBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::DONE
			action stopMoveAwayFromPosition; startGoToBehindBall
		}
		transition GetBallControl {
			from sGoToBehindBall
			to sApproachBall
			condition nodeStatus == NODE_STATUS::DONE
			action stopGoToBehindBall; startApproachBall
		}
		transition PlaceBallInPosition {
			from sApproachBall
			to sPlaceBall
			condition nodeStatus == NODE_STATUS::DONE
			action stopApproachBall; startCarryBall
		}
		transition MoveAway {
			from sPlaceBall
			to sMoveAwayFromBall
			condition nodeStatus == NODE_STATUS::DONE
			action stopCarryBall; startMoveAwayFromPosition
		}
		transition Finish {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::DONE
			action stopMoveAwayFromPosition
		}
	
		// Failure Transitions.
		transition AvoidBall {
			from sGoToBehindBall
			to sGiveSpaceToGetBall
			condition nodeStatus == NODE_STATUS::FAILED
			action stopGoToBehindBall; startMoveAwayFromPosition
		}
		transition ReadjustToCarryBall {
			from sApproachBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::FAILED
			action stopApproachBall; startGoToBehindBall
		}
		transition LostBallOnCarry {
			from sPlaceBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::FAILED
			action stopCarryBall; startGoToBehindBall
		}
		transition FinishWithFailOnMoveAway {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::FAILED
			action stopMoveAwayFromPosition
		}
		transition FinishWithFailOnAvoidBall {
			from sGiveSpaceToGetBall
			to sFinal
			condition nodeStatus == NODE_STATUS::FAILED
			action stopGoToBehindBall
		}
		transition BallIsOutOfPosition {
			from sMoveAwayFromBall
			to sGoToBehindBall
			condition robotHasMovedAwayFromBall
			action stopMoveAwayFromPosition; startGoToBehindBall
		}
		
		// Self Transitions.
		transition KeepGoToBehindBall {
			from sGoToBehindBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepApproachBall {
			from sApproachBall
			to sApproachBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepPlaceBall {
			from sPlaceBall
			to sPlaceBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepMovingAway {
			from sMoveAwayFromBall
			to sMoveAwayFromBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepGivingSpace {
			from sGiveSpaceToGetBall
			to sGiveSpaceToGetBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
			
	}	

	transition waitStart {
		from sInitial
		to sWaitStart
	}
	
	transition run {
		from sWaitStart
		to sRun
		trigger startCarryBallOnBallPlacement
	}
	
	transition abort {
		from sRun
		to sFinal
		trigger stopCarryBallOnBallPlacement
		// stops all machines
		action nodeStatus = NODE_STATUS::ABORTED; stopGoToBehindBall; stopApproachBall; stopCarryBall; stopMoveAwayFromPosition; stopMoveAwayFromPosition
	}
}
// END TODO

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

stm BehaviorSTM {
	// Input and Output events.
	uses IBehavior
	
	// Behavior Tree Control Interfaces.
	uses NodeStatusI
	
	// Controls the start/stop for this BehaviorSTM --> Input events.
	uses CarryBallOnBallPlacementI
	uses HaltI
	
	// Current Tactic.
	//
	// Receives value from `receiveTactic` event.
	var currentTactic:Tactic
	
	// Last Tactic.
	var lastTactic:Tactic
	
	// States.
	initial sInitial
	state sWaitTactic {}
	junction jCheckCurrentTactic
	junction jStopLastTactic
	junction jStartCurrentTactic
	
	// Transitions.
	//
	// Start transition. Just wait for a tactic.
	transition start {
		from sInitial
		to sWaitTactic
	}
	
	// A tactic has been received.
	transition receiveTactic {
		from sWaitTactic
		to jCheckCurrentTactic
		trigger receiveTactic?currentTactic
	}
	
	// The received tactic is equals to the last one.
	// In this case, we just keep the same behavior STM
	// running and don't trigger any event.
	transition sameTactic {
		from jCheckCurrentTactic
		to sWaitTactic
		condition currentTactic == lastTactic
	}
	
	// The received tactic is different from the last one.
	// In this case, we have to stop the current behavior STM
	// that it is running to be able to start a new one later.
	transition differentTactic {
		from jCheckCurrentTactic
		to jStopLastTactic
		condition currentTactic != lastTactic
	}	

	// Triggers a `stopCarryBallOnBallPlacementBehavior` event to 
	// stop the CarryBallOnBallPlacementSTM if the last tactic was
	// Tactic::PLACE_BALL_IN_POSITION and the new one it is not.
	transition stopCarryBallOnBallPlacement {
		from jStopLastTactic
		to jStartCurrentTactic
		condition lastTactic == Tactic::PLACE_BALL_IN_POSITION
		action stopCarryBallOnBallPlacement
	}
	
	// Triggers a `stopHalt` event to stop the HaltSTM if the last 
	// tactic was Tactic::HALT and the new one it is not.
	transition stopHalt {
		from jStopLastTactic
		to jStartCurrentTactic
		condition lastTactic == Tactic :: HALT
		action stopHalt
	}

	// Triggers a `startCarryBallOnBallPlacementBehavior` event to 
	// start the CarryBallOnBallPlacementSTM if the current tactic
	// is Tactic::PLACE_BALL_IN_POSITION.
	transition startCarryBallOnBallPlacement {
		from jStartCurrentTactic
		to sWaitTactic
		condition currentTactic == Tactic :: PLACE_BALL_IN_POSITION
		action startCarryBallOnBallPlacement
	}
	
	// Trigger a `startHalt` event to start the HaltSTM if the current 
	// tactic is Tactic::HALT.
	transition startHalt {
		from jStartCurrentTactic
		to sWaitTactic
		condition currentTactic == Tactic :: HALT
		action startHalt
	}
}

