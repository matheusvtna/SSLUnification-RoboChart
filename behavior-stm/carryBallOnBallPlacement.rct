import goToBehindBall
import approachBall
import carryBall
import moveAwayFromPosition

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

// This operation makes the robot execute the
// Ball Placement procedure by carrying the ball.
//
// @param frame: Frame.
// @param targetPosition: Point.
//
// TODO: Add a FSM output -> makes robot move...
operation carryBallOnBallPlacement (frame: Frame, targetPosition: Point) {
	requires GoToBehindBallI
	requires ApproachBallI
	requires CarryBallI
	requires MoveAwayFromPositionI
	
	requires GetDistanceBetweenTwoPointsI
	requires NodeStatusI
	
	// Robot instance.
	var robot: Robot = frame.robot
	var ball: Ball = frame.ball

	// Constants.
	const DIST_THRESHOLD_BALL_TO_TARGET: real = 150.0
	const DIST_THREHOLD_ROBOT_TO_TARGET_ON_FINISH: real = 500.0
	const DIST_THREHOLD_ROBOT_TO_BALL_WHEN_GO_TO_FAILED: real = 200.0
	const MIN_ANGLE_DIFF_TO_CONSIDER_ALIGNED_WITH_BALL_IN_DEGREES: real = 60.0
	const TIME_TO_PLACE_BALL_IN_SECONDS: nat = 30

	// States.
	initial sInitial
	state sGoToBehindBall {
		entry nodeStatus = NODE_STATUS::RUNNING; goToBehindBall(targetPosition, MIN_ANGLE_DIFF_TO_CONSIDER_ALIGNED_WITH_BALL_IN_DEGREES)
	}
	state sGiveSpaceToGetBall {
		entry nodeStatus = NODE_STATUS::RUNNING; moveAwayFromPosition(frame, ball.pos, DIST_THREHOLD_ROBOT_TO_BALL_WHEN_GO_TO_FAILED)
	}
	state sApproachBall {
		entry nodeStatus = NODE_STATUS::RUNNING; approachBall(ball, MIN_ANGLE_DIFF_TO_CONSIDER_ALIGNED_WITH_BALL_IN_DEGREES)
	}
	state sPlaceBall {
		entry nodeStatus = NODE_STATUS::RUNNING; carryBall(frame, targetPosition, DIST_THRESHOLD_BALL_TO_TARGET)
	}
	state sMoveAwayFromBall {
		entry nodeStatus = NODE_STATUS::RUNNING; moveAwayFromPosition(frame, targetPosition, DIST_THREHOLD_ROBOT_TO_TARGET_ON_FINISH); GetDistanceBetweenTwoPoints(robot.position, ball.pos)
	}
	final sFinal
	
	// Success Transitions.
	transition AdjustToCarryBall {
		from sInitial
		to sGoToBehindBall
	}	
	transition TryGoToBehindBallAgain {
		from sGiveSpaceToGetBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition GetBallControl {
		from sGoToBehindBall
		to sApproachBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition PlaceBallInPosition {
		from sApproachBall
		to sPlaceBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition MoveAway {
		from sPlaceBall
		to sMoveAwayFromBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition Finish {
		from sMoveAwayFromBall
		to sFinal
		condition nodeStatus == NODE_STATUS::DONE
	}

	// Failure Transitions.
	transition AvoidBall {
		from sGoToBehindBall
		to sGiveSpaceToGetBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition ReadjustToCarryBall {
		from sApproachBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition LostBallOnCarry {
		from sPlaceBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition FinishWithFailOnMoveAway {
		from sMoveAwayFromBall
		to sFinal
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition FinishWithFailOnAvoidBall {
		from sGiveSpaceToGetBall
		to sFinal
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition BallIsOutOfPosition {
		from sMoveAwayFromBall
		to sGoToBehindBall
		condition getDistanceBetweenTwoPointsResult > DIST_THRESHOLD_BALL_TO_TARGET
	}
}

