package carryBallOnBallPlacement

import goToBehindBall
import approachBall
import carryBall
import moveAwayFromPosition

// TODO: Move BehaviorSTM, IBehavior and BehaviorController away.
interface BehaviorI {
	// Input events.
	event receiveFrame: string
	event receiveField: string
	event receiveTactic: Tactic
		
	// Output events.
	event sendAction: string	
}

interface TacticI {
	var skill: Skill
}

interface CarryBallOnBallPlacementI {
	event startCarryBallOnBallPlacement
	event stopCarryBallOnBallPlacement
	event carryBallOnBallPlacementSkill
}

interface HaltI {
	event startHalt
	event stopHalt
	event haltSkill
}

// TODO: Move to specific file...
interface SkillI {
	event receiveSkill: Skill
}

enumeration Skill {
	NONE
	GO_TO_BEHIND_BALL
	APPROACH_BALL
	CARRY_BALL
	MOVE_AWAY_FROM_POSITION
}

controller BehaviorController {
	var currentTactic: Tactic
	
	uses BehaviorI
	uses TacticI
	uses NodeStatusI
		
	sref stm_behavior_ref = BehaviorSTM
	connection BehaviorController on receiveField to stm_behavior_ref on receiveField
	connection BehaviorController on receiveFrame to stm_behavior_ref on receiveFrame
	connection BehaviorController on receiveTactic to stm_behavior_ref on receiveTactic

	sref stm_carry_ball_on_ball_placement_ref = CarryBallOnBallPlacementSTM
	connection stm_behavior_ref on startCarryBallOnBallPlacement to stm_carry_ball_on_ball_placement_ref on startCarryBallOnBallPlacement
	connection stm_behavior_ref on stopCarryBallOnBallPlacement to stm_carry_ball_on_ball_placement_ref on stopCarryBallOnBallPlacement

	// Sub-FSMs.
	sref stm_go_to_behind_ball_ref = GoToBehindBallSTM
	sref stm_approach_ball_ref = ApproachBallSTM
	sref stm_carry_ball_ref = CarryBallSTM
	sref stm_move_away_ref = MoveAwayFromPositionSTM

	sref stm_skill_ref = SkillSTM
	connection stm_skill_ref on startGoToBehindBall to stm_go_to_behind_ball_ref on startGoToBehindBall
	connection stm_skill_ref on stopGoToBehindBall to stm_go_to_behind_ball_ref on stopGoToBehindBall
	connection stm_skill_ref on startApproachBall to stm_approach_ball_ref on startApproachBall
	connection stm_skill_ref on stopApproachBall to stm_approach_ball_ref on stopApproachBall
	connection stm_skill_ref on startCarryBall to stm_carry_ball_ref on startCarryBall
	connection stm_skill_ref on stopCarryBall to stm_carry_ball_ref on stopCarryBall
	connection stm_skill_ref on startMoveAwayFromPosition to stm_move_away_ref on startMoveAwayFromPosition
	connection stm_skill_ref on stopMoveAwayFromPosition to stm_move_away_ref on stopMoveAwayFromPosition
	
	connection stm_carry_ball_on_ball_placement_ref on carryBallOnBallPlacementSkill to stm_behavior_ref on carryBallOnBallPlacementSkill
	connection stm_behavior_ref on sendAction to BehaviorController on sendAction
}
// END TODO

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

stm CarryBallOnBallPlacementSTM {
	// Controls the start/stop for this BehaviorSTM --> Input events.
	uses CarryBallOnBallPlacementI
	
	// Control the Skill for this behaviorSTM --> Output events.
	uses TacticI
	
	// Defines the status of each node within the Behavior Tree.
	requires NodeStatusI
	
	// Conditional variables.
	var robotHasMovedAwayFromBall: boolean
	var runningStm: string
	
	// States.
	initial sInitial
	final sFinal
	
	state sWaitStart {
		entry nodeStatus = NODE_STATUS :: RUNNING
	}
	state sRun {
		// Execution states.
		initial sInitial
		state sGoToBehindBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sGiveSpaceToGetBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sApproachBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sPlaceBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		state sMoveAwayFromBall {
			entry nodeStatus = NODE_STATUS::RUNNING
		}
		final sFinal
		
		// Success conditions.
		transition AdjustToCarryBall {
			from sInitial
			to sGoToBehindBall
			action skill=Skill::GO_TO_BEHIND_BALL
		}	
		transition TryGoToBehindBallAgain {
			from sGiveSpaceToGetBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::GO_TO_BEHIND_BALL
		}
		transition GetBallControl {
			from sGoToBehindBall
			to sApproachBall
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::APPROACH_BALL
		}
		transition PlaceBallInPosition {
			from sApproachBall
			to sPlaceBall
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::CARRY_BALL
		}
		transition MoveAway {
			from sPlaceBall
			to sMoveAwayFromBall
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::MOVE_AWAY_FROM_POSITION
		}
		transition Finish {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::DONE
			action skill=Skill::NONE
		}
	
		// Failure Transitions.
		transition AvoidBall {
			from sGoToBehindBall
			to sGiveSpaceToGetBall
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::MOVE_AWAY_FROM_POSITION
		}
		transition ReadjustToCarryBall {
			from sApproachBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::GO_TO_BEHIND_BALL
		}
		transition LostBallOnCarry {
			from sPlaceBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::GO_TO_BEHIND_BALL
		}
		transition FinishWithFailOnMoveAway {
			from sMoveAwayFromBall
			to sFinal
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::NONE
		}
		transition FinishWithFailOnAvoidBall {
			from sGiveSpaceToGetBall
			to sFinal
			condition nodeStatus == NODE_STATUS::FAILED
			action skill=Skill::NONE
		}
		transition BallIsOutOfPosition {
			from sMoveAwayFromBall
			to sGoToBehindBall
			condition robotHasMovedAwayFromBall
			action skill=Skill::GO_TO_BEHIND_BALL
		}
		
		// Self Transitions.
		transition KeepGoToBehindBall {
			from sGoToBehindBall
			to sGoToBehindBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepApproachBall {
			from sApproachBall
			to sApproachBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepPlaceBall {
			from sPlaceBall
			to sPlaceBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepMovingAway {
			from sMoveAwayFromBall
			to sMoveAwayFromBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
		transition KeepGivingSpace {
			from sGiveSpaceToGetBall
			to sGiveSpaceToGetBall
			condition nodeStatus == NODE_STATUS::RUNNING
		}
			
	}	

	transition waitStart {
		from sInitial
		to sWaitStart
	}
	
	transition run {
		from sWaitStart
		to sRun
		trigger startCarryBallOnBallPlacement
	}
	
	transition abort {
		from sRun
		to sFinal
		trigger stopCarryBallOnBallPlacement
		// Set NONE to stop all Skill STMs.
		action nodeStatus = NODE_STATUS::ABORTED; skill=Skill::NONE

	}
}
// END TODO

// --------------------------------------------
//               BEHAVIOR STM
// --------------------------------------------
stm BehaviorSTM {
	// Input and Output events.
	uses BehaviorI
	
	// Behavior Tree Control Interfaces.
	uses NodeStatusI
	
	// Controls the start/stop for this BehaviorSTM --> Input events.
	uses CarryBallOnBallPlacementI
	uses HaltI
	
	// Current Tactic.
	//
	// Receives value from `receiveTactic` event.
	var currentTactic:Tactic
	
	// Last Tactic.
	var lastTactic:Tactic
	
	// States.
	initial sInitial
	state sWaitTactic {}
	junction jCheckCurrentTactic
	junction jStopLastTactic
	junction jStartCurrentTactic
	
	// Transitions.
	//
	// Start transition. Just wait for a tactic.
	transition start {
		from sInitial
		to sWaitTactic
	}
	
	// A tactic has been received.
	transition receiveTactic {
		from sWaitTactic
		to jCheckCurrentTactic
		trigger receiveTactic?currentTactic
	}
	
	// The received tactic is equals to the last one.
	// In this case, we just keep the same behavior STM
	// running and don't trigger any event.
	transition sameTactic {
		from jCheckCurrentTactic
		to sWaitTactic
		condition currentTactic == lastTactic
	}
	
	// The received tactic is different from the last one.
	// In this case, we have to stop the current behavior STM
	// that it is running to be able to start a new one later.
	transition differentTactic {
		from jCheckCurrentTactic
		to jStopLastTactic
		condition currentTactic != lastTactic
	}	

	// Triggers a `stopCarryBallOnBallPlacementBehavior` event to 
	// stop the CarryBallOnBallPlacementSTM if the last tactic was
	// Tactic::PLACE_BALL_IN_POSITION and the new one it is not.
	transition stopCarryBallOnBallPlacement {
		from jStopLastTactic
		to jStartCurrentTactic
		condition lastTactic == Tactic::PLACE_BALL_IN_POSITION
		action stopCarryBallOnBallPlacement
	}
	
	// Triggers a `stopHalt` event to stop the HaltSTM if the last 
	// tactic was Tactic::HALT and the new one it is not.
	transition stopHalt {
		from jStopLastTactic
		to jStartCurrentTactic
		condition lastTactic == Tactic :: HALT
		action stopHalt
	}

	// Triggers a `startCarryBallOnBallPlacementBehavior` event to 
	// start the CarryBallOnBallPlacementSTM if the current tactic
	// is Tactic::PLACE_BALL_IN_POSITION.
	transition startCarryBallOnBallPlacement {
		from jStartCurrentTactic
		to sWaitTactic
		condition currentTactic == Tactic :: PLACE_BALL_IN_POSITION
		action startCarryBallOnBallPlacement
	}
	
	// Trigger a `startHalt` event to start the HaltSTM if the current 
	// tactic is Tactic::HALT.
	transition startHalt {
		from jStartCurrentTactic
		to sWaitTactic
		condition currentTactic == Tactic :: HALT
		action startHalt
	}
}

// --------------------------------------------
//               SKILL STM
// --------------------------------------------
stm SkillSTM {
	// Interface to define SkillSTM requirements.
	uses SkillI
	
	// Current Skill.
	//
	// Receives value from `receiveSkill` event.
	var currentSkill: Skill
	
	// Last Skill.
	var lastSkill:Skill
	
	// States.
	initial sInitial
	state sWaitSkill {}
	junction jCheckCurrentSkill
	junction jStopLastSkill
	junction jStartCurrentSkill
	
	// Sub-FSMs --> Output events.
	uses GoToBehindBallI
	uses ApproachBallI
	uses CarryBallI
	uses MoveAwayFromPositionI	
	
	// Transitions.
	//
	// Start transition. Just wait for a Skill.
	transition start {
		from sInitial
		to sWaitSkill
	}
	
	// A Skill has been received.
	transition receiveSkill {
		from sWaitSkill
		to jCheckCurrentSkill
		trigger receiveSkill?currentSkill
	}
	
	// The received Skill is equals to the last one.
	// In this case, we just keep the same skill STM
	// running and don't trigger any event.
	transition sameSkill {
		from jCheckCurrentSkill
		to sWaitSkill
		condition currentSkill == lastSkill
	}
	
	// The received Skill is different from the last one.
	// In this case, we have to stop the current skill STM
	// that it is running to be able to start a new one later.
	transition differentSkill {
		from jCheckCurrentSkill
		to jStopLastSkill
		condition currentSkill != lastSkill
	}	

	// Triggers a `stopGoToBehindBall` event to 
	// stop the GoToBehindBallSTM if the last Skill was
	// Skill::GO_TO_BEHIND_BALL and the new one it is not.
	transition stopGoToBehindBall {
		from jStopLastSkill
		to jStartCurrentSkill
		condition lastSkill == Skill::GO_TO_BEHIND_BALL
		action stopGoToBehindBall
	}
	
	// Triggers a `stopApproachBall` event to 
	// stop the ApproachBallSTM if the last Skill was
	// Skill::APPROACH_BALL and the new one it is not.
	transition stopApproachBall {
		from jStopLastSkill
		to jStartCurrentSkill
		condition lastSkill == Skill::APPROACH_BALL
		action stopApproachBall
	}
	
	// Triggers a `stopCarryBall` event to 
	// stop the CarryBallSTM if the last Skill was
	// Skill::CARRY_BALL and the new one it is not.
	transition stopCarryBall {
		from jStopLastSkill
		to jStartCurrentSkill
		condition lastSkill == Skill::CARRY_BALL
		action stopCarryBall
	}
	
	// Triggers a `stopMoveAwayFromPosition` event to 
	// stop the MoveAwayFromPositionSTM if the last Skill was
	// Skill::MOVE_AWAY_FROM_POSITION and the new one it is not.
	transition stopMoveAwayFromPosition {
		from jStopLastSkill
		to jStartCurrentSkill
		condition lastSkill == Skill::MOVE_AWAY_FROM_POSITION
		action stopMoveAwayFromPosition
	}

	// Triggers a `startGoToBehindBall` event to 
	// start the GoToBehindBallSTM if the current skill
	// is Skill::GO_TO_BEHIND_BALL.
	transition startGoToBehindBall {
		from jStartCurrentSkill
		to sWaitSkill
		condition currentSkill == Skill::GO_TO_BEHIND_BALL
		action startGoToBehindBall
	}
	
//	// Trigger a `startHalt` event to start the HaltSTM if the current 
//	// tactic is Tactic::HALT.
//	transition startHalt {
//		from jStartCurrentTactic
//		to sWaitTactic
//		condition currentTactic == Tactic :: HALT
//		action startHalt
//	}
	transition t0 {
		from jStartCurrentSkill
		to sWaitSkill
		condition currentSkill == Skill :: APPROACH_BALL
		action startApproachBall
	}
	transition t1 {
		from jStartCurrentSkill
		to sWaitSkill
		condition currentSkill == Skill :: CARRY_BALL
		action startCarryBall
	}
	transition t2 {
		from jStartCurrentSkill
		to sWaitSkill
		condition currentSkill == Skill :: MOVE_AWAY_FROM_POSITION
		action startMoveAwayFromPosition
	}
}

