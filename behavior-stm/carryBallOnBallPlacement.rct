package carryBallOnBallPlacement

import goToBehindBall
import approachBall
import carryBall
import moveAwayFromPosition

stm BehaviorSTM {
	requires carryBallOnBallPlacementI
	uses NodeStatusI
	
	initial i0
	final f0
	transition t0 {
		from i0
		to f0
		action carryBallOnBallPlacement()
	}
}

interface IBehavior {
	event receiveFrame: string
	event receiveField: string
	event receiveTactic: string
	event sendAction: string
}

controller BehaviorController {
	uses IBehavior
	
	opref carryBallOp = carryBall
	opref approachBallOp = approachBall
	opref goToBehindBallOp = goToBehindBall
	opref moveAwayOp = moveAwayFromPosition
	opref superOperation = carryBallOnBallPlacement
	sref stm_ref0 = BehaviorSTM
}

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

interface carryBallOnBallPlacementI {
	carryBallOnBallPlacement()
}

// This operation makes the robot execute the
// Ball Placement procedure by carrying the ball.
//
// @param frame: Frame.
// @param targetPosition: Point.
//
// TODO: Add a FSM output -> makes robot move...
operation carryBallOnBallPlacement() {
	requires GoToBehindBallI
	requires ApproachBallI
	requires CarryBallI
	requires MoveAwayFromPositionI	
	requires NodeStatusI
	
	var robotHasMovedAwayFromBall: boolean

	// States.
	initial sInitial
	state sGoToBehindBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING;
			goToBehindBall()
	}
	state sGiveSpaceToGetBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING;
			moveAwayFromPosition()
	}
	state sApproachBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING;
			approachBall()
	}
	state sPlaceBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING;
			carryBall()
	}
	state sMoveAwayFromBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING; 
			moveAwayFromPosition() 
	}
	final sFinal
	
	// Success Transitions.
	transition AdjustToCarryBall {
		from sInitial
		to sGoToBehindBall
	}	
	transition TryGoToBehindBallAgain {
		from sGiveSpaceToGetBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition GetBallControl {
		from sGoToBehindBall
		to sApproachBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition PlaceBallInPosition {
		from sApproachBall
		to sPlaceBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition MoveAway {
		from sPlaceBall
		to sMoveAwayFromBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition Finish {
		from sMoveAwayFromBall
		to sFinal
		condition nodeStatus == NODE_STATUS::DONE
	}

	// Failure Transitions.
	transition AvoidBall {
		from sGoToBehindBall
		to sGiveSpaceToGetBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition ReadjustToCarryBall {
		from sApproachBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition LostBallOnCarry {
		from sPlaceBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition FinishWithFailOnMoveAway {
		from sMoveAwayFromBall
		to sFinal
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition FinishWithFailOnAvoidBall {
		from sGiveSpaceToGetBall
		to sFinal
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition BallIsOutOfPosition {
		from sMoveAwayFromBall
		to sGoToBehindBall
		condition robotHasMovedAwayFromBall
	}
	
	// Self Transitions.
	transition KeepGoToBehindBall {
		from sGoToBehindBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	transition KeepApproachBall {
		from sApproachBall
		to sApproachBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	transition KeepPlaceBall {
		from sPlaceBall
		to sPlaceBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	transition KeepMovingAway {
		from sMoveAwayFromBall
		to sMoveAwayFromBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	transition KeepGivingSpace {
		from sGiveSpaceToGetBall
		to sGiveSpaceToGetBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
}

