package carryBallOnBallPlacement

import goToBehindBall
import approachBall
import carryBall
import moveAwayFromPosition

// TODO: Move BehaviorSTM, IBehavior and BehaviorController away.
stm BehaviorSTM {
	// Possible behavior operations.
	requires carryBallOnBallPlacementI
	
	// Behavior Tree Control Interfaces.
	uses NodeStatusI
	uses BehaviorTreeControl
	
	// Current Tactic.
	//
	// Defaults to HALT.
	var currentTactic : Tactic = Tactic::HALT
	
	// States.
	initial sInitial
	state sExec {}
	state sAbort {}
	final sFinal
	
	// Transitions.
	transition start {
		from sInitial
		to sExec
	}

	// TODO: Check tactics and act according its value.
	// BallPlacementAlly -> carryBallOnBallPlacement
	// DirectAlly -> freeKick
	// ... -> ...
	transition carryBallOnBallPlacement {
		from sExec
		to sExec		
		action carryBallOnBallPlacement()	
	}
	
	transition abort {
		from sExec
		to sAbort
		// TODO: How we can check if the currentTactic is different from the received one.
		// condition receiveTactic[1] != currentTactic
		action behaviorHasChanged
	}
	
	transition reset {
		from sAbort
		to sExec
	}
}

interface IBehavior {
	event receiveFrame: string
	event receiveField: string
	event receiveTactic: Tactic
	event sendAction: string
}

controller BehaviorController {
	uses IBehavior
	
	opref carryBallOp = carryBall
	opref approachBallOp = approachBall
	opref goToBehindBallOp = goToBehindBall
	opref moveAwayOp = moveAwayFromPosition
	opref superOperation = carryBallOnBallPlacement
	sref stm_ref0 = BehaviorSTM
}
// END TODO

// --------------------------------------------
//         CARRY BALL ON BALL PLACEMENT
// --------------------------------------------

interface carryBallOnBallPlacementI {
	carryBallOnBallPlacement()
}

// This operation makes the robot execute the
// Ball Placement procedure by carrying the ball.
//
// @param frame: Frame.
// @param targetPosition: Point.
//
// TODO: Add a FSM output -> makes robot move...
operation carryBallOnBallPlacement() {
	// Sub-Operations
	requires GoToBehindBallI
	requires ApproachBallI
	requires CarryBallI
	requires MoveAwayFromPositionI	
	
	// Behavior Tree Control Interfaces.
	requires NodeStatusI
	uses BehaviorTreeControl
	
	// Conditional variables.
	var robotHasMovedAwayFromBall: boolean

	// States.
	initial sInitial
	state sGoToBehindBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING;
			goToBehindBall()
	}
	state sGiveSpaceToGetBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING;
			moveAwayFromPosition()
	}
	state sApproachBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING;
			approachBall()
	}
	state sPlaceBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING;
			carryBall()
	}
	state sMoveAwayFromBall {
		entry 
			nodeStatus = NODE_STATUS::RUNNING; 
			moveAwayFromPosition() 
	}
	final sFinal
	
	// Success Transitions.
	transition AdjustToCarryBall {
		from sInitial
		to sGoToBehindBall
	}	
	transition TryGoToBehindBallAgain {
		from sGiveSpaceToGetBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition GetBallControl {
		from sGoToBehindBall
		to sApproachBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition PlaceBallInPosition {
		from sApproachBall
		to sPlaceBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition MoveAway {
		from sPlaceBall
		to sMoveAwayFromBall
		condition nodeStatus == NODE_STATUS::DONE
	}
	transition Finish {
		from sMoveAwayFromBall
		to sFinal
		condition nodeStatus == NODE_STATUS::DONE
	}

	// Failure Transitions.
	transition AvoidBall {
		from sGoToBehindBall
		to sGiveSpaceToGetBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition ReadjustToCarryBall {
		from sApproachBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition LostBallOnCarry {
		from sPlaceBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition FinishWithFailOnMoveAway {
		from sMoveAwayFromBall
		to sFinal
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition FinishWithFailOnAvoidBall {
		from sGiveSpaceToGetBall
		to sFinal
		condition nodeStatus == NODE_STATUS::FAILED
	}
	transition BallIsOutOfPosition {
		from sMoveAwayFromBall
		to sGoToBehindBall
		condition robotHasMovedAwayFromBall
	}
	
	// Self Transitions.
	transition KeepGoToBehindBall {
		from sGoToBehindBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	transition KeepApproachBall {
		from sApproachBall
		to sApproachBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	transition KeepPlaceBall {
		from sPlaceBall
		to sPlaceBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	transition KeepMovingAway {
		from sMoveAwayFromBall
		to sMoveAwayFromBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	transition KeepGivingSpace {
		from sGiveSpaceToGetBall
		to sGiveSpaceToGetBall
		condition nodeStatus == NODE_STATUS::RUNNING
	}
	
	// Aborted Transitions.
	transition GameEventChangedOnGoToBall {
		from sGoToBehindBall
		to sFinal
		condition nodeStatus == NODE_STATUS::ABORTED
	}
	transition GameEventChangedApproachBall {
		from sApproachBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::ABORTED
	}
	transition GameEventChangedCarryBall {
		from sPlaceBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::ABORTED
	}
	transition GameEventChangedOnMoveAwayFromBall {
		from sMoveAwayFromBall
		to sFinal
		condition nodeStatus == NODE_STATUS::ABORTED
	}
	transition GameEventChangedOnGivingSpaceToBall {
		from sGiveSpaceToGetBall
		to sFinal
		condition nodeStatus == NODE_STATUS::ABORTED
	}
	transition GameEventChangedOnMovingAwayFromBall {
		from sMoveAwayFromBall
		to sGoToBehindBall
		condition nodeStatus == NODE_STATUS::ABORTED
	}
}