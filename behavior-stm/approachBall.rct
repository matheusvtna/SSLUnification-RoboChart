import utils


// --------------------------------------------
//              APPROACH BALL
// --------------------------------------------
interface ApproachBallI {
	approachBall(ball: Ball, angleThreshold: real)
}

// This operation makes robot move to ball smoothly.
// It succeeds when the robot touches the ball and
// fails when the robot is not behind the ball or
// close to it.
//
// @param ball: Ball.
// @param angleThreshold: real.
//
// TODO: Add a FSM output -> makes robot move...
operation approachBall(ball: Ball, angleThreshold: real) {
	requires NodeStatusI
	requires AllyIsBehindI
	requires AllyIsCloseToBallI
	requires AllyHasBallI
	
	// Start values.
	var robot: Robot
	var target: Point

	// Variables conditions.
	var allyIsBehindBall: boolean
	var allyIsCloseToBall: boolean
	var allyHasBall: boolean
	
	// States.
	initial sInitial
	state sApproach {
		entry
			nodeStatus = NODE_STATUS::RUNNING;
			AllyIsBehind(robot, ball.pos, target, angleThreshold); 
			allyIsBehindBall = allyIsBehindResult;

			AllyIsCloseToBall(robot, ball); 
			allyIsCloseToBall = allyIsCloseToBallResult;

			AllyHasBall(robot, ball);
			allyHasBall = allyHasBallResult
	}	
	final sFinal
	
	// Transitions.
	transition start {
		from sInitial
		to sApproach
	}
	
	transition success {		
		from sApproach
		to sFinal
		condition allyHasBall
		action nodeStatus = NODE_STATUS::DONE
	}
	
	transition recalculate {
		from sApproach
		to sApproach
		condition (not allyHasBall) /\ not (not allyIsBehindBall \/ not allyIsCloseToBall)
		action nodeStatus = NODE_STATUS::RUNNING
	}
	
	transition fail {
		from sApproach
		to sFinal
		condition (not allyIsBehindBall \/ not allyIsCloseToBall)
		action nodeStatus = NODE_STATUS::FAILED
	}
}	