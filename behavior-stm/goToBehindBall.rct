import utils

// --------------------------------------------
//              GO TO BEHIND BALL
// --------------------------------------------
interface GoToBehindBallI {
	event startGoToBehindBall
	event stopGoToBehindBall
}

// This operation makes robot move to behind the
// ball. It succeeds when the robot is at the point
// behind the ball looking to targetPosition.
//
// @param targetPosition: Point.
// @param angleThreshold: real.
//
// TODO: Add a FSM output -> makes robot move...
stm GoToBehindBallSTM {
	// Behavior Tree Control Interfaces.
	requires NodeStatusI
	uses GoToBehindBallI

	// Conditional variables.
	var allyIsBehindBall: boolean
	var allyIsCloseToBall: boolean
	var allyIsPushingBallWithHisBack: boolean

	// States.
	initial sInitial
	final sFinal
	
	state sWaitStart {}
	
	state sRun {
		
		initial sInitial
		final sFinal
		
		state sGoToBehindBall {
			entry nodeStatus = NODE_STATUS::RUNNING			
		}
		
		transition start {
			from sInitial
			to sGoToBehindBall
		}
		
		transition success {		
			from sGoToBehindBall
			to sFinal
			condition (allyIsBehindBall /\ allyIsCloseToBall) 
			action nodeStatus = NODE_STATUS::DONE
		}
		
		
		transition recalculate {
			from sGoToBehindBall
			to sGoToBehindBall
			condition not (allyIsBehindBall /\ allyIsCloseToBall) /\ not allyIsPushingBallWithHisBack
			action nodeStatus = NODE_STATUS::RUNNING
		}
		
		transition fail {		
			from sGoToBehindBall
			to sFinal
			condition allyIsPushingBallWithHisBack
			action nodeStatus = NODE_STATUS::FAILED
		}
	}
		
	
	// Transitions.
	transition waitStart {
		from sInitial
		to sWaitStart
	}
	
	transition goToBehindBall{
		from sWaitStart
		to sRun
		trigger startGoToBehindBall
	}
	
	
	
	transition abortFromRunning {		
		from sRun
		to sFinal
		trigger stopGoToBehindBall
		action nodeStatus = NODE_STATUS::ABORTED
	}
	
	transition abortFromStart {		
		from sWaitStart
		to sFinal
		trigger stopGoToBehindBall
		action nodeStatus = NODE_STATUS::ABORTED
	}
	
	
	
}	

