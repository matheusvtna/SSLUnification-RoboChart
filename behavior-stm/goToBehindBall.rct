import utils
import robot

// --------------------------------------------
//              GO TO BEHIND BALL
// --------------------------------------------
interface GoToBehindBallI {
	goToBehindBall(targetPosition: Point, angleThreshold: real)
}

// This operation makes robot move to behind the
// ball. It succeeds when the robot is at the point
// behind the ball looking to targetPosition.
//
// @param targetPosition: Point.
// @param angleThreshold: real.
//
// TODO: Add a FSM output -> makes robot move...
operation goToBehindBall(targetPosition: Point, angleThreshold: real) {
	requires AllyIsBehindI
	requires AllyIsCloseToBallI
	requires AllyIsPushingBallWithHisBackI
	requires NodeStatusI
	
	// Entities instances.
	var robot: Robot	
	var ball: Ball

	// Variables conditions.
	var allyIsBehindBall: boolean
	var allyIsCloseToBall: boolean
	var allyIsPushingBallWithHisBack: boolean

	// States.
	initial sInitial
	state sGoToBehindBall {
		entry 			
			AllyIsBehind(robot, ball.pos, targetPosition, angleThreshold); 
			allyIsBehindBall = allyIsBehindResult;
		
			AllyIsCloseToBall(robot, ball); 
			allyIsCloseToBall = allyIsCloseToBallResult;

			AllyIsPushingBallWithHisBack(robot, ball);
			allyIsPushingBallWithHisBack = allyIsPushingBallWithHisBackResult

	}	
	final sFinal
	
	// Transitions.
	transition goToBehindBall {
		from sInitial
		to sGoToBehindBall
		// action moveToBehindBall()
	}
	
	transition success {		
		from sGoToBehindBall
		to sFinal
		condition (allyIsBehindBall /\ allyIsCloseToBall) 
		action nodeStatus = NODE_STATUS::DONE
	}
	
	transition fail {		
		from sGoToBehindBall
		to sFinal
		condition allyIsPushingBallWithHisBack
		action nodeStatus = NODE_STATUS::FAILED
	}
}	

