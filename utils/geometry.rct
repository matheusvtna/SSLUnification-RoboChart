function smallestAngleDiff(source: real, target: real): real {
	// TODO: Fazer função de diferença angular...
}

interface cosI {
	var cosResult: real
}

operation cos(angle: real) {
	requires cosI

	// First Approximation.
	var cosseno: real = 1.0
	var term: real = 1.0

	// PI Approximation.
	var PI: real = 3.14159

	var number_of_terms: int = 100000

	var count: int = 0

	initial sInitial
	state sSeries {
		entry term = term * ((-1.0) * count * count / ((2.0 * count - 1.0) * 2.0 * count)); cosseno = cosseno + term; count = count + 1
	}
	final sFinal

	transition calculate {
		from sInitial
		to sSeries
	}
	transition finish {
		from sSeries
		to sFinal
		condition count >= number_of_terms
		action cosResult = cosseno
	}
}

interface sinI {
	var sinResult: real
}

operation sin(angle: real) {
	requires sinI

	// First Approximation.
	var seno: real = angle
	var term: real = angle

	// PI Approximation.
	var PI: real = 3.14159

	var number_of_terms: real = 100000

	var count: int = 0

	initial sInitial
	state sSeries {
		entry term = term * (-1.0) * angle * angle / ((2.0 * count) * (2.0 * count + 1.0)); seno = seno + term; count = count + 1
	}
	final sFinal

	transition calculate {
		from sInitial
		to sSeries
	}
	transition finish {
		from sSeries
		to sFinal
		condition count >= number_of_terms
		action sinResult = seno
	}
}

interface degreesToRadiansI {
	var degreesToRadiansResult: real
}

operation degreesToRadians(degrees: real) {
	requires degreesToRadiansI
	initial sInitial
	final sFinal

	// PI Approximation.
	var PI: real = 3.14159

	transition finish {
		from sInitial
		to sFinal
		action degreesToRadiansResult = degrees * PI / 180
	}
}


interface radiansToDegreesI {
	var radiansToDegreesResult: real
}

operation radiansToDegrees(radians: real) {
	requires radiansToDegreesI
	initial sInitial
	final sFinal

	// PI Approximation.
	var PI: real = 3.14159

	transition finish {
		from sInitial
		to sFinal
		action radiansToDegreesResult = radians / (PI / 180)
	}
}

interface sqrtI {
	var sqrtResult: real
}

operation sqrt(n: real) {
	requires sqrtI

	var precision: real = 0.0001

	// Initial Estimation.
	var x0: real = 1.0

	// Next Estimation.
	var x1: real = 0.0
    
	initial sInitial
	state sLoop {
		entry x0 = x1; x1 = (x0 + n / x0) / 2.0 // Newton-Raphson Formulas
	}
	final sFinal

	transition calculate {
		from sInitial
		to sLoop
	}
	transition finish {
		from sLoop
		to sFinal
		condition (x1 - x0) * (x1 - x0) < precision * precision
		action sqrtResult = x1
	}
}

interface atanI {
	var atanResult: real
}

operation atan(angle: real) {
	requires atanI

	var number_of_terms: int = 100000

	var count: int = 0
	var res: real = 0
	var offset: real = 0

	initial sInitial
	state sLoop {
		entry offset = ((angle^(2 * count + 1)) / (2 * count + 1)); if (count % 2 == 0) then res = res + offset else res = res - offset
	}
	final sFinal

	transition calculate {
		from sInitial
		to sLoop
	}
	transition finish {
		from sLoop
		to sFinal
		condition count >= number_of_terms
		action atanResult = res
	}
} 

interface atan2I {
	var atan2Result: real
}

operation atan2(y: real, x: real) {
	requires atanI
	requires atan2I

	var number_of_terms: int = 100000

	var count: int = 0
	var res: real = 0
	var offset: real = 0

	var PI: real = 3.14159

	initial sInitial	
	final sFinal

	transition finish {
		from sInitial
		to sFinal
		action atan(y/x); if(x > 0) then atan2Result = atanResult
						else if(y >= 0 /\ x < 0) then atan2Result = atanResult + PI
						else if(y < 0 /\ x < 0) then atan2Result = atanResult - PI
						else if(y > 0 /\ x == 0) then atan2Result = PI/2
						else if(y < 0 /\ x == 0) then atan2Result = -PI/2
						else atan2Result = 0
	}
}