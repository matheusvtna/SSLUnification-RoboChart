function smallestAngleDiff(source: real, target: real): real {
	// TODO: Fazer função de diferença angular...
}


// --------------------------------------------
//                   COSSENO
// --------------------------------------------
interface cosI {
	var cosResult: real
}

// This operation works as a function to calculates
// the cosine from an angle in radians. 
//
// @param angle: real [-PI, +PI]
//
// @return [real] cos(angle). 
operation cos(angle: real) {
	requires cosI

	// First Approximation.
	var cosseno: real = 1.0
	var term: real = 1.0

	// PI Approximation.
	var PI: real = 3.14159

	var number_of_terms: int = 100000

	var count: int = 0

	initial sInitial
	junction sSeries
	final sFinal

	transition calculate {
		from sInitial
		to sSeries
	}
	transition loop {
		from sSeries
		to sSeries
		action term = term * ((-1.0) * count * count / ((2.0 * count - 1.0) * 2.0 * count)); cosseno = cosseno + term; count = count + 1
	}
	transition finish {
		from sSeries
		to sFinal
		condition count >= number_of_terms
		action cosResult = cosseno
	}
}


// --------------------------------------------
//                   SENO
// --------------------------------------------
interface sinI {
	var sinResult: real
}

// This operation works as a function to calculates
// the sinus from an angle in radians. 
//
// @param angle: real [-PI, +PI]
//
// @return [real] sin(angle). 
operation sin(angle: real) {
	requires sinI

	// First Approximation.
	var seno: real = angle
	var term: real = angle

	// PI Approximation.
	var PI: real = 3.14159

	var number_of_terms: real = 100000

	var count: int = 0

	initial sInitial
	junction sSeries
	final sFinal

	transition calculate {
		from sInitial
		to sSeries
	}
	transition loop {
		from sSeries
		to sSeries
		action term = term * (-1.0) * angle * angle / ((2.0 * count) * (2.0 * count + 1.0)); seno = seno + term; count = count + 1
	}
	transition finish {
		from sSeries
		to sFinal
		condition count >= number_of_terms
		action sinResult = seno
	}
}

// --------------------------------------------
//             DEGREES TO RADIANS
// --------------------------------------------
interface degreesToRadiansI {
	var degreesToRadiansResult: real
}

// This operation works as a function to calculates
// the mapping from degrees to radians from an angle. 
//
// @param degrees: real [-180, +180]
//
// @return [real] The angle in radians. 
operation degreesToRadians(degrees: real) {
	requires degreesToRadiansI
	initial sInitial
	final sFinal

	// PI Approximation.
	var PI: real = 3.14159

	transition finish {
		from sInitial
		to sFinal
		action degreesToRadiansResult = degrees * PI / 180
	}
}


// --------------------------------------------
//             RADIANS TO DEGREES
// --------------------------------------------
interface radiansToDegreesI {
	var radiansToDegreesResult: real
}

// This operation works as a function to calculates
// the mapping from radians to degrees from an angle. 
//
// @param degrees: real [-PI, +PI]
//
// @return [real] The angle in degrees. 
operation radiansToDegrees(radians: real) {
	requires radiansToDegreesI
	initial sInitial
	final sFinal

	// PI Approximation.
	var PI: real = 3.14159

	transition finish {
		from sInitial
		to sFinal
		action radiansToDegreesResult = radians / (PI / 180)
	}
}

// --------------------------------------------
//                   SQRT
// --------------------------------------------
interface sqrtI {
	var sqrtResult: real
}

// This operation works as a function to calculates
// the square root from a real value. 
//
// @param n: real
//
// @return [real] The square root of n. 
operation sqrt(n: real) {
	requires sqrtI

	var precision: real = 0.0001

	// Initial Estimation.
	var x0: real = 1.0

	// Next Estimation.
	var x1: real = 0.0
    
	initial sInitial
	junction sLoop
	final sFinal

	transition calculate {
		from sInitial
		to sLoop
	}
	transition loop {
		from sLoop
		to sLoop
		action x0 = x1; x1 = (x0 + n / x0) / 2.0 // Newton-Raphson Formulas
	}
	transition finish {
		from sLoop
		to sFinal
		condition (x1 - x0) * (x1 - x0) < precision * precision
		action sqrtResult = x1
	}
}

// --------------------------------------------
//                   POWER
// --------------------------------------------
interface powI {
	var powResult: real
}

// This operation works as a function to calculates
// the power from a real value x with an exponent n. 
//
// @param n: real
//
// @return [real] x**n. 
operation pow(x: real, n: int) {
	requires powI
	
	var count: int = 1
	var res: real = 1.0
	
	initial sInitial
	junction sLoop
	final sFinal

	transition calculate {
		from sInitial
		to sLoop
	}
	transition loop {
		from sLoop
		to sLoop
		action res = res * x; count = count + 1	
	}
	transition finish {
		from sLoop
		to sFinal
		condition count == n
		action powResult = res
	}
}

// --------------------------------------------
//                   ATAN
// --------------------------------------------
interface atanI {
	var atanResult: real
}

// This operation works as a function to calculates
// the arc tangent from an angle in radians. 
//
// @param angle: real [-PI, +PI]
//
// @return [real] atan(angle). 
operation atan(angle: real) {
	requires atanI
	requires powI
	
	var number_of_terms: int = 100000

	var count: int = 0
	var res: real = 0
	var offset: real = 0

	initial sInitial
	junction sLoop
	final sFinal

	transition calculate {
		from sInitial
		to sLoop
	}
	transition loop {
		from sLoop
		to sLoop
		action pow(angle, (2 * count + 1)); offset = (powResult) / (2 * count + 1); if (count % 2 == 0) then res = res + offset else res = res - offset end
	}
	transition finish {
		from sLoop
		to sFinal
		condition count >= number_of_terms
		action atanResult = res
	}
} 

// --------------------------------------------
//                  ATAN 2
// --------------------------------------------
interface atan2I {
	var atan2Result: real
}

// This operation works as a function to calculates
// the arc tangent from a pair (x, y). 
//
// @param x: real
// @param y: real
//
// @return [real] atan(y/x) 
operation atan2(y: real, x: real) {
	requires atanI
	requires atan2I

	var number_of_terms: int = 100000

	var count: int = 0
	var res: real = 0
	var offset: real = 0

	var PI: real = 3.14159

	initial sInitial	
	final sFinal

	transition finish {
		from sInitial
		to sFinal
		action if(x > 0) then atan(y/x); atan2Result = atanResult
				else if(y >= 0 /\ x < 0) then atan(y/x); atan2Result = atanResult + PI
					else if(y < 0 /\ x < 0) then atan(y/x); atan2Result = atanResult - PI
						else if(y > 0 /\ x == 0) then atan2Result = PI/2
							else if(y < 0 /\ x == 0) then atan2Result = -PI/2
								else atan2Result = 0 end
							end
						end
					end
				end 
			}	
}