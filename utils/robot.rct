import ball
// Datatype to represent a RobotFeedback in SSL Environment.
// 
// A RobotFeedback contains informations of a Robot. It contains
// a boolean value to indicate whether the robot has the IR sensor
// activated, a real value to represent the battery charge and a
// real value to represent the capacitor charge.
datatype RobotFeedback {
	ir: boolean
	battery: real
	capacitor: real
}

// Datatype to represent a Robot in SSL Environment.
// 
// A Robot an integer value to represent the robot id,
// a Point to represent its position in the field, a
// Point value to represent its velocity, a real value
// to represent its angle and a RobotFeedback which
// contains physical informations of the robot
datatype Robot {
	id: int
	pos: Point
	vel: Point
	angle: real
	feedback: RobotFeedback
}

// --------------------------------------------
//               ROBOT RADIUS
// --------------------------------------------
interface GetRobotRadiusI {
	var robotRadius: int	
}

// This operation works as a function to get
// the radius of a robot
//
// @return [int] The robot radius
operation GetRobotRadius() {
	requires GetRobotRadiusI
	
	// States
	initial Initial
	final Stop
	transition finish {
		from Initial
		to Stop
		action robotRadius = 90
	}
}

/*
function ROBOT_RADIUS(): real {	
	return 90
}
*/

// --------------------------------------------
//               ROBOT POSITION
// --------------------------------------------
interface GetPositionFromRobotI {
	var getPositionFromRobotResult : Point
}

// This operation works as a function to get 
// the position from a robot.
//
// @param robot: Robot
//
// @return [Point] The robot position vector. 
operation getPositionFromRobot(robot: Robot) {
	requires GetPositionFromRobotI
	
	// States.
	initial Initial
	state GetPositionFromRobot {}	
	final Stop
	
	// Transitions.
	transition start {
		from Initial
		to GetPositionFromRobot
	}
	transition finish {		
		from GetPositionFromRobot
		to Stop
		action getPositionFromRobotResult = robot.pos
	}
}	

// --------------------------------------------
//               ROBOT ANGLE
// --------------------------------------------
interface GetAngleFromRobotI {
	var getAngleFromRobotResult : real
}

// This operation works as a function to get 
// the angle from a robot.
//
// @param robot: Robot
//
// @return [real] The robot angle. 
operation getAngleFromRobot(robot: Robot) {
	requires GetAngleFromRobotI
	
	// States.
	initial Initial
	state GetAngleFromRobot {}	
	final Stop
	
	// Transitions.
	transition start {
		from Initial
		to GetAngleFromRobot
	}
	transition finish {		
		from GetAngleFromRobot
		to Stop
		action getAngleFromRobotResult = robot.angle
	}
}	

// --------------------------------------------
//               ROBOT FEEDBACK
// --------------------------------------------
interface GetFeedbackFromRobotI {
	var getFeedbackFromRobotResult : RobotFeedback
}

// This operation works as a function to get 
// the feedback from a robot.
//
// @param robot: Robot
//
// @return [RobotFeedback] The robot feedback. 
operation getFeedbackFromRobot(robot: Robot) {
	requires GetFeedbackFromRobotI
	
	// States.
	initial Initial
	state GetFeedbackFromRobot {}	
	final Stop
	
	// Transitions.
	transition start {
		from Initial
		to GetFeedbackFromRobot
	}
	transition finish {		
		from GetFeedbackFromRobot
		to Stop
		action getFeedbackFromRobotResult = robot.feedback
	}
}	

// --------------------------------------------
//           ROBOT HAS BALL CONTACT
// --------------------------------------------
interface RobotHasBallContactI {
	var robotHasBallContactResult : boolean
}

// This operation works as a function to check 
// whether the current robot has ball contact.
//
// @param robot: Robot
//
// @return [boolean] A value which indicates if
// the robot has ball contact or not. 
operation robotHasBallContact(robot: Robot) {
	requires RobotHasBallContactI
	
	// States.
	initial Initial
	state RobotHasBallContact {}	
	final Stop
	
	// Transitions.
	transition start {
		from Initial
		to RobotHasBallContact
	}
	transition finish {		
		from RobotHasBallContact
		to Stop
		action robotHasBallContactResult = robot.feedback.ir
	}
}	

// FSM Utils
interface AllyIsBehindI {
	var allyIsBehindResult: boolean
}

operation AllyIsBehind(robot: Robot, point: Point, target: Point, angleThreshold: real) {
	requires AllyIsBehindI
	requires GetPositionFromRobotI
	requires CreateVectorI
	requires CreateUnitVectorI
	requires AngleBetweenVectorsI
	
	var robotPosition: Point
	var point2target: Point
	var ally2target: Point 
	var unitPoint2target: Point
	var unitAlly2point: Point
	var angleBetweenVectors: real
	
	initial Initial
	state setRobotPosition {
		entry getPositionFromRobot(robot)
	}
	state createVectorPointToTarget {
		entry createVector(point, target)
	}
	state createUnitVectorPointToTarget {
		entry createUnitVector(point2target)
	}
	state createVectorAllyToPoint {
		entry createVector(robotPosition, point)
	}
	state createUnitVectorAllyToPoint {
		entry createUnitVector(ally2target)
	}
	state getAngleBetweenVectors {
		entry angleBetweenVectors(unitPoint2target, unitAlly2point)
	}
	
	final stop
	
	transition calculateRobotPosition {
		from Initial
		to setRobotPosition
		action robotPosition = getPositionFromRobotResult
	}
	transition calculateVectorPoint2Target {
		from setRobotPosition
		to createVectorPointToTarget
		action point2target = createVectorResult
	}
	transition calculateUnitVectorPoint2Target {
		from createVectorPointToTarget
		to createUnitVectorPointToTarget
		action unitPoint2target = createUnitVectorResult
	}
	transition calculateVectorAlly2Point {
		from createUnitVectorPointToTarget
		to createVectorAllyToPoint
		action ally2target = createVectorResult
	}
	transition calculateUnitVectorAlly2target {
		from createVectorAllyToPoint
		to createUnitVectorAllyToPoint
		action unitAlly2point = createUnitVectorResult 
	}
	transition calculateAngleBetweenVectors {
		from createUnitVectorAllyToPoint
		to getAngleBetweenVectors
		action angleBetweenVectors = angleBetweenVectorsResult
	}
	transition finish {
		from createUnitVectorAllyToPoint
		to stop
		action allyIsBehindResult = -angleThreshold < angleBetweenVectors /\ angleBetweenVectors < angleThreshold
	}
}

interface AllyHasBallI {
	var allyHasBallResult: boolean
}
// TODO: fazer metodo de verificacao por posicao e angulo
operation AllyHasBall(robot: Robot, ball: Ball) {
	requires AllyHasBallI
	
	initial Initial
	final stop
	
	transition finish {
		from Initial
		to stop
		action allyHasBallResult = true
	}
}

interface AllyIsCloseToBallI {
	var allyIsCloseToBallResult: boolean
}

operation AllyIsCloseToBall(robot: Robot, ball: Ball) {
	requires AllyIsCloseToBallI
	requires GetPositionFromRobotI
	requires GetDistanceBetweenTwoPointsI
	
	var robotPosition: Point = robot.pos
	var ballPosition: Point = ball.pos
	var MIN_RADIUS_TO_CONSIDER_CLOSE_TO_BALL: real = 111
	
	initial Initial 
	state sInitial {
		entry GetDistanceBetweenTwoPoints(robotPosition, ballPosition)
	}
	final stop
	
	transition calculateRobotPosition {
		from Initial
		to sInitial
	}
	transition finish {
		from sInitial
		to stop
		action allyIsCloseToBallResult = getDistanceBetweenTwoPointsResult < MIN_RADIUS_TO_CONSIDER_CLOSE_TO_BALL
	}
}

function allyIsLookingToBall(robot: Robot, ball: Ball): boolean {
	var ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER: real = degreesToRadians(60)
	
	var robotCenter: Point = robot.pos
	var robotAngle: real = robot.angle
	var robotFront: Point = fromPolar(ROBOT_RADIUS(), robotAngle)
	var ballPosition: Point = ball.pos
	
	var robotCenterToFrontUnitVector: Point = createUnitVector(robotCenter, robotFront)
	var robotToBallUnitVector: Point = createUnitVector(robotCenter, ballPosition)
	
	var angle = angleBetween(robotCenterToFrontUnitVector, robotToBallUnitVector)
	return -ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER < angle /\ angle < +ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER;	
}

interface AllyIsLookingToBallI {
	var allyIsLookingToBallResult: boolean
}

operation AllyIsLookingToBall(robot: Robot, ball: Ball) {
	requires AllyIsLookingToBallI
	requires CreateUnitVectorI
	requires CreateVectorI
	requires AngleBetweenVectorsI
	requires FromPolarI
	
	var ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER: real = degreesToRadians(60)
	
	var robotCenter: Point = robot.pos
	var robotAngle: real = robot.angle
	var robotFront: Point
	var ballPosition: Point = ball.pos
	
	var robotCenterToFrontUnitVector: Point
	var robotToBallUnitVector: Point
	
	var angle: real
	
	initial Initial
	state createRobotCenterAndFrontUnitVector {
		entry FromPolar(ROBOT_RADIUS(), robotAngle);CreateVector(robotCenter, robotFront); CreateUnitVector(createVectorResult)
	}
	state createRobotCenterToBallUnitVector {
		entry CreateVector(robotCenter, ballPosition); CreateUnitVector(createVectorResult)
	}
	state calculateAngleBetweenUnitVectors {
		entry AngleBetweenVectors(robotCenterToFrontUnitVector, robotToBallUnitVector)
	}
	final stop
	
	transition robotCenterFrontUnitVetor {
		from Initial
		to createRobotCenterAndFrontUnitVector
		action robotFront = fromPolarResult; robotCenterToFrontUnitVector = createUnitVectorResult
	}
	transition robotCenterToBallUnitVector {
		from createRobotCenterAndFrontUnitVector
		to createRobotCenterToBallUnitVector
		action robotToBallUnitVector = createUnitVectorResult
	}
	transition calculateAngle {
		from createRobotCenterToBallUnitVector
		to calculateAngleBetweenUnitVectors
		action angle = angleBetweenVectorsResult
	}
	transition finish {
		from calculateAngleBetweenUnitVectors
		to stop
		action allyIsLookingToBallResult = (-ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER < angle) /\ (angle < ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER)
	}
}

function allyCanHaveBallOnDribbler(robot: Robot, ball: Ball): boolean {
	return allyIsLookingToBall(robot, ball) /\ allyIsCloseToBall(robot, ball)	
}

function allyIsPushingBallWithHisBack(robot: Robot, ball: Ball): boolean {
	return (!allyIsLookingToBall(robot, ball)) /\ allyIsCloseToBall(robot, ball)
}
