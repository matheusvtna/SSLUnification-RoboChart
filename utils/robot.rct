import ball

// ============================================
// =                DATATYPES                 =
// ============================================
//
// Datatype to represent a RobotFeedback in SSL Environment.
// 
// A RobotFeedback contains informations of a Robot. It contains
// a boolean value to indicate whether the robot has the IR sensor
// activated, a real value to represent the battery charge and a
// real value to represent the capacitor charge.
datatype RobotFeedback {
	ir: boolean
	battery: real
	capacitor: real
}

// Datatype to represent a Robot in SSL Environment.
// 
// A Robot an integer value to represent the robot id,
// a Point to represent its position in the field, a
// Point value to represent its velocity, a real value
// to represent its angle and a RobotFeedback which
// contains physical informations of the robot
datatype Robot {
	id: int
	position: Point
	vel: Point
	angle: real
	feedback: RobotFeedback
}

// ============================================
// =                FSM UTILS                 =
// ============================================
//
// --------------------------------------------
//           ROBOT HAS BALL CONTACT
// --------------------------------------------
interface RobotHasBallContactI {
	var robotHasBallContactResult : boolean
}

// This operation works as a function to check 
// whether the current robot has ball contact.
//
// @param robot: Robot
//
// @return [boolean] A value which indicates if
// the robot has ball contact or not. 
operation robotHasBallContact(robot: Robot) {
	requires RobotHasBallContactI
	
	// States.
	initial sInitial
	state sRobotHasBallContact {}	
	final sFinal
	
	// Transitions.
	transition start {
		from sInitial
		to sRobotHasBallContact
	}
	transition finish {		
		from sRobotHasBallContact
		to sFinal
		action robotHasBallContactResult = robot.feedback.ir
	}
}	

// FSM Utils

// --------------------------------------------
//   ROBOT IS BEHIND A POINT LOOKING TO TARGET
// --------------------------------------------
interface AllyIsBehindI {
	var allyIsBehindResult: boolean
}

// This operation works as a function to check 
// whether the current robot is behind a point
// looking to a target.
//
// @param robot: Robot.
// @param point: Point.
// @param target: Point.
// @param angleThreshold: real.
//
// @return [boolean] A value which indicates if
// the robot is behind the point looking to target.
operation AllyIsBehind(robot: Robot, point: Point, target: Point, angleThreshold: real) {
	requires AllyIsBehindI
	requires CreateVectorI
	requires CreateUnitVectorI
	requires AngleBetweenVectorsI
	
	var point2target: Point
	var ally2target: Point 	
	var angleBetweenVectors: real
	
	initial sInitial
	state sGetVectorPointToTarget {
		entry point2target = createUnitVectorResult
	}
	state sGetVectorAllyToPoint {
		entry ally2target = createUnitVectorResult
	}	
	state sGetAngleBetweenVectors {
		entry angleBetweenVectors = angleBetweenVectorsResult
	}
	final sFinal
	
	transition calculateVectorPointToTarget{
		from sInitial
		to sGetVectorPointToTarget
		action CreateVector(point, target); CreateUnitVector(createVectorResult)
	}
	transition calculateVectorAlly2Point {
		from sGetVectorPointToTarget
		to sGetVectorAllyToPoint
		action CreateVector(robot.position, point); CreateUnitVector(createVectorResult)
	}	
	transition calculateAngleBetweenVectors {
		from sGetVectorAllyToPoint
		to sGetAngleBetweenVectors
		action AngleBetweenVectors(point2target, ally2target)
	}
	transition finish {
		from sGetAngleBetweenVectors
		to sFinal
		action allyIsBehindResult = -angleThreshold < angleBetweenVectors /\ angleBetweenVectors < angleThreshold
	}
}

// --------------------------------------------
//   			ROBOT HAS BALL
// --------------------------------------------
interface AllyHasBallI {
	var allyHasBallResult: boolean
}

// This operation works as a function to ...
//
// @param robot: Robot.
// @param ball: Ball.
//
// @return [boolean] A value which indicates if
// the robot has ball or not.
// TODO: Fazer metodo de verificacao por posicao e angulo
operation AllyHasBall(robot: Robot, ball: Ball) {
	requires AllyHasBallI
	
	initial sInitial
	final sFinal
	
	transition finish {
		from sInitial
		to sFinal
		action allyHasBallResult = true
	}
}

// --------------------------------------------
//   	     ROBOT IS CLOSE TO BALL
// --------------------------------------------
interface AllyIsCloseToBallI {
	var allyIsCloseToBallResult: boolean
}

// This operation works as a function to ...
//
// @param robot: Robot.
// @param ball: Ball.
//
// @return [boolean] A value which indicates if
// the robot is close to ball or not.
operation AllyIsCloseToBall(robot: Robot, ball: Ball) {
	requires AllyIsCloseToBallI
	requires GetDistanceBetweenTwoPointsI
	
	var robotPosition: Point = robot.position
	var ballPosition: Point = ball.pos
	var distance: real
	var MIN_RADIUS_TO_CONSIDER_CLOSE_TO_BALL: real = 111
	
	initial sInitial 	
	final sFinal
	
	transition finish {
		from sInitial
		to sFinal
		action GetDistanceBetweenTwoPoints(robotPosition, ballPosition); distance = getDistanceBetweenTwoPointsResult; allyIsCloseToBallResult = distance < MIN_RADIUS_TO_CONSIDER_CLOSE_TO_BALL
	}
}

// --------------------------------------------
//   	     ROBOT IS CLOSE TO BALL
// --------------------------------------------
interface AllyIsLookingToBallI {
	var allyIsLookingToBallResult: boolean
}

// This operation works as a function to ...
//
// @param robot: Robot.
// @param ball: Ball.
//
// @return [boolean] A value which indicates if
// the robot is looking to ball or not.
operation AllyIsLookingToBall(robot: Robot, ball: Ball) {
	requires AllyIsLookingToBallI
	requires CreateVectorI
	requires CreateUnitVectorI
	requires AngleBetweenVectorsI
	requires FromPolarI
	requires degreesToRadiansI
	
	var ROBOT_RADIUS: real = 90.0
	var ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER: real
	
	var robotCenter: Point = robot.position
	var robotAngle: real = robot.angle
	var robotFront: Point
	var ballPosition: Point = ball.pos
	
	var robotCenterToFrontUnitVector: Point
	var robotToBallUnitVector: Point
	
	var angle: real
	
	initial sInitial
	state sGetRobotCenterToFrontUnitVector {
		entry robotCenterToFrontUnitVector = createUnitVectorResult
	}
	state sGetRobotCenterToBallUnitVector {
		entry robotToBallUnitVector = createUnitVectorResult
	}
	state sGetAngleBetweenUnitVectors {
		entry angle = angleBetweenVectorsResult
	}
	final sFinal

	transition calculateRobotCenterToFrontUnitVector {
		from sInitial
		to sGetRobotCenterToFrontUnitVector
		action degreesToRadians(60); ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER = degreesToRadiansResult; FromPolar(ROBOT_RADIUS, robotAngle); CreateVector(robotCenter, FromPolarResult); CreateUnitVector(createVectorResult)
	}
	
	transition calculateRobotCenterToBallUnitVector {
		from sGetRobotCenterToFrontUnitVector
		to sGetRobotCenterToBallUnitVector
		action CreateVector(robotCenter, ballPosition); CreateUnitVector(createVectorResult)
	}
	transition calculateAngleBetweenVectors {
		from sGetRobotCenterToBallUnitVector
		to sGetAngleBetweenUnitVectors
		action AngleBetweenVectors(robotCenterToFrontUnitVector, robotToBallUnitVector)
	}
	transition finish {
		from sGetAngleBetweenUnitVectors
		to sFinal
		action allyIsLookingToBallResult = (-ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER < angle) /\ (angle < ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER)
	}
}

// --------------------------------------------
//   	 ROBOT CAN HAVE BALL ON DRIBBLER
// --------------------------------------------
interface AllyCanHaveBallOnDribblerI {
	var allyCanHaveBallOnDribblerResult: boolean
}

// This operation works as a function to ...
//
// @param robot: Robot.
// @param ball: Ball.
//
// @return [boolean] A value which indicates if
// the robot has the ball on dribbler or not.
operation AllyCanHaveBallOnDribbler(robot: Robot, ball: Ball) {
	requires AllyCanHaveBallOnDribblerI
	requires AllyIsLookingToBallI
	requires AllyIsCloseToBallI

	initial sInitial
	final sFinal

	transition sCheck {
		from sInitial
		to sFinal
		action AllyIsLookingToBall(robot, ball) ; AllyIsCloseToBall(robot, ball); allyCanHaveBallOnDribblerResult = allyIsLookingToBallResult /\ allyIsCloseToBallResult
	}
}

// --------------------------------------------
//     ROBOT IS PUSHING BALL WITH HIS BACK
// --------------------------------------------
interface AllyIsPushingBallWithHisBackI {
	var allyIsPushingBallWithHisBackResult: boolean
}

// This operation works as a function to ...
//
// @param robot: Robot.
// @param ball: Ball.
//
// @return [boolean] A value which indicates if
// the robot has the ball on dribbler or not.
operation AllyIsPushingBallWithHisBack(robot: Robot, ball: Ball) {
	requires AllyIsPushingBallWithHisBackI
	requires AllyIsLookingToBallI
	requires AllyIsCloseToBallI

	initial sInitial
	final sFinal

	transition sCheck {
		from sInitial
		to sFinal
		// TODO: Como Ã© o NOT em RoboChart?
		action AllyIsLookingToBall(robot, ball) ; AllyIsCloseToBall(robot, ball); allyIsPushingBallWithHisBackResult = (not allyIsLookingToBallResult) /\ allyIsCloseToBallResult
	}
}


// ============================================
// =           GETTERS AND SETTERS            =
// ============================================
//
// --------------------------------------------
//               ROBOT POSITION
// --------------------------------------------
interface GetPositionFromRobotI {
	var getPositionFromRobotResult : Point
}

// This operation works as a function to get 
// the position from a robot.
//
// @param robot: Robot
//
// @return [Point] The robot position vector. 
operation getPositionFromRobot(robot: Robot) {
	requires GetPositionFromRobotI
	
	// States.
	initial sInitial
	state sGetPositionFromRobot {}	
	final sFinal
	
	// Transitions.
	transition start {
		from sInitial
		to sGetPositionFromRobot
	}
	transition finish {		
		from sGetPositionFromRobot
		to sFinal
		action getPositionFromRobotResult = robot.position
	}
}	

// --------------------------------------------
//               ROBOT ANGLE
// --------------------------------------------
interface GetAngleFromRobotI {
	var getAngleFromRobotResult : real
}

// This operation works as a function to get 
// the angle from a robot.
//
// @param robot: Robot
//
// @return [real] The robot angle. 
operation getAngleFromRobot(robot: Robot) {
	requires GetAngleFromRobotI
	
	// States.
	initial sInitial
	state sGetAngleFromRobot {}	
	final sFinal
	
	// Transitions.
	transition start {
		from sInitial
		to sGetAngleFromRobot
	}
	transition finish {		
		from sGetAngleFromRobot
		to sFinal
		action getAngleFromRobotResult = robot.angle
	}
}	

// --------------------------------------------
//               ROBOT FEEDBACK
// --------------------------------------------
interface GetFeedbackFromRobotI {
	var getFeedbackFromRobotResult : RobotFeedback
}

// This operation works as a function to get 
// the feedback from a robot.
//
// @param robot: Robot
//
// @return [RobotFeedback] The robot feedback. 
operation getFeedbackFromRobot(robot: Robot) {
	requires GetFeedbackFromRobotI
	
	// States.
	initial sInitial
	state sGetFeedbackFromRobot {}	
	final sFinal
	
	// Transitions.
	transition start {
		from sInitial
		to sGetFeedbackFromRobot
	}
	transition finish {		
		from sGetFeedbackFromRobot
		to sFinal
		action getFeedbackFromRobotResult = robot.feedback
	}
}	