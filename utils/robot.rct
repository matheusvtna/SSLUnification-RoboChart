// Datatype to represent a RobotFeedback in SSL Environment.
// 
// A RobotFeedback contains informations of a Robot. It contains
// a boolean value to indicate whether the robot has the IR sensor
// activated, a real value to represent the battery charge and a
// real value to represent the capacitor charge.
datatype RobotFeedback {
	ir: boolean
	battery: real
	capacitor: real
}

// Datatype to represent a Robot in SSL Environment.
// 
// A Robot an integer value to represent the robot id,
// a Point to represent its position in the field, a
// Point value to represent its velocity, a real value
// to represent its angle and a RobotFeedback which
// contains physical informations of the robot
datatype Robot {
	id: int
	pos: Point
	vel: Point
	angle: real
	feedback: RobotFeedback
}

function ROBOT_RADIUS(): real {	
	return 90
}

// --------------------------------------------
//               ROBOT POSITION
// --------------------------------------------
interface GetPositionFromRobotI {
	var getPositionFromRobotResult : Point
}

// This operation works as a function to get 
// the position from a robot.
//
// @param robot: Robot
//
// @return [Point] The robot position vector. 
operation getPositionFromRobot(robot: Robot) {
	requires GetPositionFromRobotI
	
	// States.
	initial Initial
	state GetPositionFromRobot {}	
	final Stop
	
	// Transitions.
	transition start {
		from Initial
		to GetPositionFromRobot
	}
	transition finish {		
		from GetPositionFromRobot
		to Stop
		action getPositionFromRobotResult = robot.pos
	}
}	

// --------------------------------------------
//               ROBOT ANGLE
// --------------------------------------------
interface GetAngleFromRobotI {
	var getAngleFromRobotResult : real
}

// This operation works as a function to get 
// the angle from a robot.
//
// @param robot: Robot
//
// @return [real] The robot angle. 
operation getAngleFromRobot(robot: Robot) {
	requires GetAngleFromRobotI
	
	// States.
	initial Initial
	state GetAngleFromRobot {}	
	final Stop
	
	// Transitions.
	transition start {
		from Initial
		to GetAngleFromRobot
	}
	transition finish {		
		from GetAngleFromRobot
		to Stop
		action getAngleFromRobotResult = robot.angle
	}
}	

// --------------------------------------------
//               ROBOT FEEDBACK
// --------------------------------------------
interface GetFeedbackFromRobotI {
	var getFeedbackFromRobotResult : RobotFeedback
}

// This operation works as a function to get 
// the feedback from a robot.
//
// @param robot: Robot
//
// @return [RobotFeedback] The robot feedback. 
operation getFeedbackFromRobot(robot: Robot) {
	requires GetFeedbackFromRobotI
	
	// States.
	initial Initial
	state GetFeedbackFromRobot {}	
	final Stop
	
	// Transitions.
	transition start {
		from Initial
		to GetFeedbackFromRobot
	}
	transition finish {		
		from GetFeedbackFromRobot
		to Stop
		action getFeedbackFromRobotResult = robot.feedback
	}
}	

// --------------------------------------------
//           ROBOT HAS BALL CONTACT
// --------------------------------------------
interface RobotHasBallContactI {
	var robotHasBallContactResult : boolean
}

// This operation works as a function to check 
// whether the current robot has ball contact.
//
// @param robot: Robot
//
// @return [boolean] A value which indicates if
// the robot has ball contact or not. 
operation robotHasBallContact(robot: Robot) {
	requires RobotHasBallContactI
	
	// States.
	initial Initial
	state RobotHasBallContact {}	
	final Stop
	
	// Transitions.
	transition start {
		from Initial
		to RobotHasBallContact
	}
	transition finish {		
		from RobotHasBallContact
		to Stop
		action robotHasBallContactResult = robot.feedback.ir
	}
}	

// FSM Utils
function allyIsBehind(robot: Robot, point: Point, target: Point, angleThreshold: real): boolean {
	var robotPosition = getPositionFromRobot(robot)
	var pointToTargetUnitVector = createUnitVector(point, target)
    var allyToPointUnitVector = createUnitVector(robotPosition, point)
    
    var angle = angleBetween(pointToTargetUnitVector, allyToPointUnitVector)

    return -angleThreshold < angle /\ angle < +angleThreshold;
}

function allyHasBall(robot: Robot, ball: Ball): boolean {
	// TODO: utilizar a verificação por posição e angulo...
	return robotHasIR(robot)
}

function allyIsCloseToBall(robot: Robot, ball: Ball): boolean {
	var MIN_RADIUS_TO_CONSIDER_CLOSE_TO_BALL: real = 111
	
	var robotPosition = getPositionFromRobot(robot)
	var ballPosition = getPositionFromBall(ball)
	return distance(robotPosition, ballPosition) < MIN_RADIUS_TO_CONSIDER_CLOSE_TO_BALL
}

function allyIsLookingToBall(robot: Robot, ball: Ball): boolean {
	var ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER: real = degreesToRadians(60)
	
	var robotCenter: Point = getPositionFromRobot(robot)
	var robotAngle: real = getAngleFromRobot(robot)
	var robotFront: Point = fromPolar(ROBOT_RADIUS(), robotAngle)
	var ballPosition: Point = getPositionFromBall(ball)
	
	var robotCenterToFrontUnitVector: Point = createUnitVector(robotCenter, robotFront)
	var robotToBallUnitVector: Point = createUnitVector(robotCenter, ballPosition)
	
	var angle = angleBetween(robotCenterToFrontUnitVector, robotToBallUnitVector)
	return -ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER < angle /\ angle < +ANGULAR_DIFF_TO_CONSIDER_BALL_ON_DRIBBLER;	
}

function allyCanHaveBallOnDribbler(robot: Robot, ball: Ball): boolean {
	return allyIsLookingToBall(robot, ball) /\ allyIsCloseToBall(robot, ball)	
}

function allyIsPushingBallWithHisBack(robot: Robot, ball: Ball): boolean {
	return (!allyIsLookingToBall(robot, ball)) /\ allyIsCloseToBall(robot, ball)
}
